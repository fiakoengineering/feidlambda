---
title: |
  Greenhorn:<br>feidlambda II
subtitle: |
  _**Exploring Dynamic Array + User Defined `Lambda` (UDL)**_<br>
  _`v1.0 -> 25 Oktober 2022`_<br>
  [_`v2.0 -> 8 November 2022`_]
date: |
  2022-11-08
author: |
  Taruma Sakti Megariansyah (**fiako**dev)
format:
  revealjs: 
    smaller: false
    scrollable: true
    slide-tone: false
    slide-number: true
    preview-links: true
    theme: [dark, presentation.scss]
      # [dark] >-> night > moon > dark
      # [light] >-> default > serif (formal) > simple (code-like) > sky (code | thin / broken) 
    logo: /assets/FEIDL2023_SQUARE_ORIGINAL_cropped.png
    transition: convex
    embed-resources: false
    touch: true
    controls: true
    incremental: false
    margin: 0.15
    # multiplex: true
    # highlight-style: arrow
    footer: |
      [Edit this presentation](https://github.com/fiakoenjiniring/feidlambda/edit/main/greenhorn/feidlambda-2/presentation.qmd){target="_blank" preview-link="false"} | [Report an issue](https://github.com/fiakoenjiniring/feidlambda/issues/new){target="_blank" preview-link="false"}
    code-copy: true
---

## {.smaller}

**Kegiatan**

Greenhorn

**Topik**

_Exploring Dynamic Array and User Defined `Lambda` (UDL)_<br>Memanfaatkan _Dynamic Array_ dan _User-Defined `LAMBDA` (UDL)_

**_Author_**

Bahan presentasi dibuat oleh **Taruma Sakti Megariansyah**

**Lisensi**

Seluruh materi presentasi menggunakan lisensi [CC-BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/){target="_blank" preview-link="false"}

**Kontak**

[hi@taruma.info](mailto:hi@taruma.info) / [team@dev.fiako.engineering](mailto:team@dev.fiako.engineering)

## Agenda

Agenda untuk _Greenhorn feidlambda II: Exploring Dynamic Array + User Defined `Lambda` (UDL)_

- Review [Daftar Istilah](https://lambda.fiako.engineering/docs/glossary.html)
- Eksplorasi tentang _Logical_
- _Dynamic Array Formula_ (DAF)
- Fungsi Baru dari Excel 2019 dan 2021
- _User Defined `Lambda`_ (UDL)

# 1 Review [Daftar Istilah](https://lambda.fiako.engineering/docs/glossary.html)

## _Vector_ dan _Array_ {.smaller}

- Istilah _array_ dapat diartikan _range_ yang memiliki 1 dimensi atau 2 dimensi.
- _Array_ dapat dibangkitkan menggunakan sintaks "`={...}`". Dengan "`,`" sebagai pemisah kolom (sepanjang baris), "`;`" sebagai pemisah baris (sepanjang kolom).  

$$
\texttt{{1,2,3}}
=
\begin{bmatrix}
  1 & 2 & 3
\end{bmatrix}
,
\texttt{{1;2;3}}
=
\begin{bmatrix}
  1\\
  2\\
  3
\end{bmatrix}
$$

$$
\texttt{\{}
  \underbrace{\texttt{1,2,3}}_{\textit{baris ke-}1}
  \texttt{;}
  \underbrace{\texttt{4,5,6}}_{\textit{baris ke-}2}
  \texttt{;}
  \underbrace{\texttt{7,8,9}}_{\textit{baris ke-}3}
\texttt{\}}
=
\begin{bmatrix}
  1 & 2 & 3\\
  4 & 5 & 6\\
  7 & 8 & 9
\end{bmatrix}
$$

# 2 Eksplorasi tentang _Logical_

Eksplorasi mengenai fungsi yang menghasilkan _logical_ yaitu `TRUE` atau `FALSE`.

# Fungsi _Logical_

`NOT(...)`, `AND(...)`, `OR(...)`, `XOR(...)`

# Fungsi `NOT(...)`

## `NOT` (1)

### Syntax

```vb 
=NOT(logical)
```

- Fungsi `NOT` membalikkan nilai argumennya. ^[[`NOT` (Fungsi `NOT`)](https://support.microsoft.com/id-id/office/not-fungsi-not-9cfc6011-a054-40c7-a140-cd4ba2d87d77), Microsoft Support.]
- Menghasilkan nilai `TRUE` ketika kondisi bernilai `FALSE`, dan berlaku sebaliknya. 
- `NOT(TRUE) = FALSE`
- `NOT(FALSE) = TRUE`

## `NOT` (2) {.smaller}

$$
\texttt{NOT}
\left(
  \begin{bmatrix}
    \texttt{TRUE}\\
    \texttt{FALSE}\\
    \texttt{TRUE}
  \end{bmatrix}
\right)
=
\begin{bmatrix}
  \texttt{FALSE}\\
  \texttt{TRUE}\\
  \texttt{FALSE}
\end{bmatrix}
$$

$$
\texttt{NOT}
\left(
  \begin{bmatrix}
    \texttt{TRUE} & \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
=
\begin{bmatrix}
  \texttt{FALSE} & \texttt{TRUE} & \texttt{FALSE}
\end{bmatrix}
$$

$$
\texttt{NOT}
\left(
  \begin{bmatrix}
    \texttt{TRUE} & \texttt{FALSE}\\
    \texttt{FALSE} & \texttt{TRUE}\\
  \end{bmatrix}
\right)
=
\begin{bmatrix}
  \texttt{FALSE} & \texttt{TRUE}\\
  \texttt{TRUE} & \texttt{FALSE}
\end{bmatrix}
$$

# Fungsi `AND(...)`

## `AND` (1) {.smaller}

- Fungsi logika, untuk menentukan apakah **semua kondisi** dalam sebuah tes adalah `TRUE`. ^[[AND (Fungsi AND)](https://support.microsoft.com/id-id/office/and-fungsi-and-5f19b2e8-e1df-4408-897a-ce285a19e9d9), Microsoft Support.]

```vb
=AND(logical1, [logical2], ...)
```

- Menghasilkan nilai `TRUE` ketika **seluruh kondisi** bernilai `TRUE`. Jika terdapat **satu atau lebih** bernilai `FALSE` maka menghasilkan nilai `FALSE`. 
- Jika input berupa _logical array_ saja (`AND(logical_array)`), maka akan mengevaluasi seluruh elemen pada _logical array_ (`AND(elemen_1, elemen_2, ...)`). 

## `AND` (2)

$$
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{TRUE}
\right)
= 
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{TRUE}, 
  \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{FALSE}
\right)
= 
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{AND}
\left(
  \texttt{FALSE}, \texttt{FALSE}
\right)
= 
\texttt{AND}
\left(
  \texttt{FALSE}, \texttt{FALSE}, 
  \texttt{FALSE}
\right)
=
\texttt{FALSE}
$$

## `AND` (3) {.smaller}

$$
\texttt{AND}
\left(
  \begin{bmatrix}
  \texttt{TRUE} & \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{AND}
\left(
  \begin{bmatrix}
  \texttt{TRUE} \\ \texttt{TRUE} \\ \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{TRUE}, 
  \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{AND}
\left(
  \begin{bmatrix}
  \texttt{TRUE} & \texttt{FALSE} \\ 
  \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{FALSE}, \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{AND}
\left(
  \begin{bmatrix}
  \texttt{TRUE} \\ 
  \texttt{FALSE} 
  \end{bmatrix}
  ,
  \begin{bmatrix}
  \texttt{TRUE} \\ 
  \texttt{FALSE}
  \end{bmatrix}
\right)
= 
\texttt{AND}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}, \texttt{FALSE}
\right)
=
\texttt{FALSE}
$$

# Fungsi `OR(...)`

## `OR` (1)

- Fungsi logika, untuk menentukan apakah **salah satu kondisi** dalam sebuah tes adalah `TRUE`. ^[[`OR` function](https://support.microsoft.com/en-us/office/or-function-7d17ad14-8700-4281-b308-00b131e22af0), Microsoft Support.]

```vb 
=OR(logical1, [logical2], ...)
```

- Menghasilkan nilai `TRUE` ketika salah satu kondisi bernilai `TRUE`. 
- Jika input berupa _logical array_ saja (`OR(logical_array)`), maka akan mengevaluasi seluruh elemen pada _logical array_ (`OR(elemen_1, elemen_2, ...)`). 

## `OR` (2)

$$
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{TRUE}
\right)
= 
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{TRUE}, 
  \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{FALSE}
\right)
= 
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{OR}
\left(
  \texttt{FALSE}, \texttt{FALSE}
\right)
= 
\texttt{OR}
\left(
  \texttt{FALSE}, \texttt{FALSE}, 
  \texttt{FALSE}
\right)
=
\texttt{FALSE}
$$

## `OR` (3) {.smaller}

$$
\texttt{OR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} & \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{OR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} \\ \texttt{TRUE} \\ \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{TRUE}, 
  \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{OR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} & \texttt{FALSE} \\ 
  \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{FALSE}, \texttt{TRUE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{OR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} \\ 
  \texttt{FALSE} 
  \end{bmatrix}
  ,
  \begin{bmatrix}
  \texttt{TRUE} \\ 
  \texttt{FALSE}
  \end{bmatrix}
\right)
= 
\texttt{OR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}, \texttt{FALSE}
\right)
=
\texttt{TRUE}
$$

# Fungsi `XOR(...)`

## `XOR` (1)

- Fungsi `XOR` mengembalikan logika **Exclusive Or** dari semua argumen. ^[[`XOR` function](https://support.microsoft.com/id-id/office/xor-fungsi-xor-1548d4c2-5e47-4f77-9a92-0533bba14f37), Microsoft Support.]

```vb 
=XOR(logical1, [logical2], ...)
```

- Menghasilkan nilai `TRUE` ketika hanya satu kondisi bernilai `TRUE`. 
- Jika input berupa _logical array_ saja (`XOR(logical_array)`), maka akan mengevaluasi seluruh elemen pada _logical array_ (`XOR(elemen_1, elemen_2, ...)`). 

## `XOR` (2)

$$
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{TRUE}
\right)
= 
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{TRUE}, 
  \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}
\right)
= 
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{FALSE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{XOR}
\left(
  \texttt{FALSE}, \texttt{FALSE}
\right)
= 
\texttt{XOR}
\left(
  \texttt{FALSE}, \texttt{FALSE}, 
  \texttt{FALSE}
\right)
=
\texttt{FALSE}
$$

## `XOR` (3) {.smaller}

$$
\texttt{XOR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} & \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{XOR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} \\ \texttt{FALSE} \\ \texttt{FALSE}
  \end{bmatrix}
\right)
= 
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{FALSE}
\right)
=
\texttt{TRUE}
$$

$$
\texttt{XOR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} & \texttt{FALSE} \\ 
  \texttt{FALSE} & \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{FALSE}, \texttt{TRUE}
\right)
=
\texttt{FALSE}
$$

$$
\texttt{XOR}
\left(
  \begin{bmatrix}
  \texttt{TRUE} \\ 
  \texttt{FALSE} 
  \end{bmatrix}
  ,
  \begin{bmatrix}
  \texttt{FALSE} \\ 
  \texttt{FALSE}
  \end{bmatrix}
\right)
= 
\texttt{XOR}
\left(
  \texttt{TRUE}, \texttt{FALSE}, 
  \texttt{FALSE}, \texttt{FALSE}
\right)
=
\texttt{TRUE}
$$

# _Logical_ $\iff$ _Number_

## _Logical_ $\Rightarrow$ _Number_ (1)

- $\texttt{FALSE} = 0$. Bernilai `FALSE` jika bernilai `0`. $\{ x = 0 \}$
- $\texttt{TRUE} \neq 0$. Bernilai `TRUE` jika nilai **bukan** `0`. $\{ x \in \mathbb{R}\ |\ x \neq 0 \}$

- Mengubah _logical_ menjadi _number_ dapat menggunakan fungsi `INT(...)`. ^[[INT (FUNGSI INT)](https://support.microsoft.com/id-id/office/int-fungsi-int-a6c4af9e-356d-4369-ab6a-cb1fd9d343ef), Microsoft Support.]
- $\texttt{INT}(\texttt{TRUE}) = 1$.
- $\texttt{INT}(\texttt{FALSE}) = 0$.
 
## _Logical_ dan operator aritmatika (1) {.smaller}

- _Logical array_ akan diubah menjadi _numeric array_ ketika bertemu operator aritmatika (`+`, `*`, `-`, `/`).
- Perubahan _logical_ menjadi _number_ sama dengan proses penggunaan fungsi `INT(...)`.
- Operator aritmatika perkalian (`*` / $\times$) dan penambahan (`+`) dapat berperilaku seperti fungsi _logical_ `AND` (`*`) dan `OR` (`+`). 
- Umumnya operator perkalian setiap elemen dalam suatu vector atau matriks (_array_) menggunakan simbol $\odot$. Akan tetapi, pada materi ini simbol $\times$ diartikan sebagai **perkalian setiap elemen** (_element-wise_) dan **bukan perkalian matriks**.

## _Logical_ dan operator aritmatika (2) {.smaller}

$$
\mathbf{X}
\underbrace{\textsf{ operator }}_{\times\ |\ +}
\mathbf{Y} 
\Rightarrow 
\mathbf{P}
\underbrace{\textsf{ operator }}_{\times\ |\ +}
\mathbf{Q}
$$

$$
\mathbf{X} \in \mathbb{B}_l, \mathbf{Y} \in \mathbb{B}_l, 
\mathbf{P} \in \mathbb{B}_i, \mathbf{Q} \in \mathbb{B}_i
$$ 

- Simbol $\mathbb{B}$ untuk menyatakan nilai _logical_ atau _boolean_. ^[[Boolean Domain](https://en.wikipedia.org/wiki/Boolean_domain)]

$$
\mathbb{B}_l = 
\{
  \texttt{TRUE, FALSE}
\}
=
\{
  \text{T}, \text{F}
\}
,
\mathbb{B}_i = 
\{
  0, 1
\}
$$

$$
\overbrace{
  \begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{FALSE}\\
  \texttt{FALSE}
  \end{bmatrix}
}^{\text{logical array}}
\underbrace{\ \times\ |\ +\ }_\text{operator}
\overbrace{
  \begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{TRUE}\\
  \texttt{FALSE}
  \end{bmatrix}
}^{\text{logical array}}
\Rightarrow
\overbrace{
  \begin{bmatrix}
  1\\
  0\\
  0
  \end{bmatrix}
}^{\text{numeric array}}
\underbrace{\ \times\ |\ +\ }_\text{operator}
\overbrace{
  \begin{bmatrix}
  1\\
  1\\
  0
  \end{bmatrix}
}^{\text{numeric array}}
$$

# Operator perkalian

## Operator perkalian `*` sebagai `AND` (1)

- Setiap nilai yang dikalikan dengan `0` akan bernilai `0`. 

$$
x \times 0 = 0,\ \{x \in \mathbb{R}\}
$$

- Setiap nilai yang dikalikan dengan `FALSE` akan bernilai `FALSE`. 

## Operator perkalian `*` sebagai `AND` (2)

$$
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{FALSE}\\
  \texttt{FALSE}
\end{bmatrix}
\times
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{TRUE}\\
  \texttt{FALSE}
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
  1\\
  0\\
  0
\end{bmatrix}
\times
\begin{bmatrix}
  1\\
  1\\
  0
\end{bmatrix}
=
\underbrace{
\begin{bmatrix}
  1\\
  0\\
  0
\end{bmatrix}
}_{\textit{hasil akhir}}
$$

$$
\Rightarrow
\underbrace{
  \left(
    \begin{bmatrix}
    1\\
    0\\
    0
  \end{bmatrix}
  \neq 0
  \right)
}_{\textit{mengubah menjadi logical}}
=
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{FALSE}\\
  \texttt{FALSE}
\end{bmatrix}
$$

# Operator penambahan

## Operator penambahan `+` sebagai `OR` (1)

- Berlaku seperti penambahan pada umumnya.

$$
x + 0 = x, x \in \mathbb{R}
$$

$$
x + y = x + y,  x \in \mathbb{R}, y \in \mathbb{R}
$$ 

- Setiap nilai yang **bukan `0`** bernilai `TRUE`. $\texttt{TRUE} \neq 0$

## Operator penambahan `+` sebagai `OR` (2) {.smaller}

$$
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{FALSE}\\
  \texttt{FALSE}
\end{bmatrix}
+
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{TRUE}\\
  \texttt{FALSE}
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
  1\\
  0\\
  0
\end{bmatrix}
+
\begin{bmatrix}
  1\\
  1\\
  0
\end{bmatrix}
=
\underbrace{
\begin{bmatrix}
  2\\
  1\\
  0
\end{bmatrix}
}_{\textit{hasil akhir}}
$$

$$
\Rightarrow
\underbrace{
  \left(
    \begin{bmatrix}
      2\\
      1\\
      0
    \end{bmatrix}
    \neq 0
  \right)
}_{\textit{mengubah menjadi logical}}
=
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{TRUE}\\
  \texttt{FALSE}
\end{bmatrix}
$$

# _Number_ $\Rightarrow$ _Logical_

## _Number_ $\Rightarrow$ _Logical_ (1)

- _Numeric array_ dapat digunakan sebagai kondisi _logical_. 
- Setiap _numeric array_ yang digunakan sebagai _conditional_ secara tidak langsung berubah menjadi _logical array_. 
- Perubahan tersebut sama saja jika membandingkan _array_ **tidak sama dengan `0`**. 
$$
\left(
  \mathbf{x}_{\text{number}} \neq 0
\right)
=
\mathbf{x}_{\text{logical}}
$$

## _Number_ $\Rightarrow$ _Logical_ (2)

$$
\texttt{NOT}
\left(
  \underbrace{
    \begin{bmatrix}
      3\\
      -1\\
      0
    \end{bmatrix}
  }_{\textit{numeric}}
  \equiv
  0
\right)
=
\left(
  \underbrace{
    \begin{bmatrix}
      3\\
      -1\\
      0
    \end{bmatrix}
  }_{\textit{numeric}}
  \neq
  0
\right)
=
\underbrace{
  \begin{bmatrix}
    \texttt{TRUE}\\
    \texttt{TRUE}\\
    \texttt{FALSE}
  \end{bmatrix}
}_{\textit{logical}}
$$

- Sama saja dengan formula `=NOT(array=0)` atau `=array<>0`.

## _Number_ $\Rightarrow$ _Logical_ (2) {.smaller}

$$
\texttt{IF}
\left(
  \underbrace{
    \begin{bmatrix}
      3\\
      -1\\
      0
    \end{bmatrix}
  }_{\textit{numeric}}
  ,
  \underbrace{\dots}_{\texttt{TRUE}}
  ,
  \underbrace{\dots}_{\texttt{FALSE}}
\right)
\Rightarrow
\texttt{IF}
\left(
  \underbrace{
    \begin{bmatrix}
      \texttt{TRUE}\\
      \texttt{TRUE}\\
      \texttt{FALSE}
    \end{bmatrix}
  }_{\textit{logical}}
  ,
  \underbrace{\dots}_{\texttt{TRUE}}
  ,
  \underbrace{\dots}_{\texttt{FALSE}}
\right)
$$

## Yang perlu diperhatikan {.smaller}

- Hasil dari _logical array_ bertemu dengan operator aritmatika **selalu _numeric array_**.

$$
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{FALSE}\\
  \texttt{FALSE}
\end{bmatrix}
\times
\begin{bmatrix}
  \texttt{TRUE}\\
  \texttt{TRUE}\\
  \texttt{FALSE}
\end{bmatrix}
+
\begin{bmatrix}
  \texttt{FALSE}\\
  \texttt{TRUE}\\
  \texttt{TRUE}
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
  1\\
  0\\
  0
\end{bmatrix}
\times
\begin{bmatrix}
  1\\
  1\\
  0
\end{bmatrix}
+
\begin{bmatrix}
  0\\
  1\\
  1
\end{bmatrix}
=
\begin{bmatrix}
  1\\
  1\\
  1
\end{bmatrix}
$$

- Jika _numeric array_ digunakan sebagai argumen _conditional_, maka akan dikonversikan menjadi _logical array_. 

# Mengenal Fungsi `IS*(...)`

Kumpulan fungsi logika untuk mevalidasi _input_. 

## Fungsi `IS*(...)`

### SYNTAX

```scala
=IS*(value)
```

- Memeriksa nilai tertentu dan mengembalikan `TRUE` atau `FALSE` bergantung pada hasilnya. ^[[Fungsi IS](https://support.microsoft.com/id-id/office/fungsi-is-0f2d7971-6019-40a0-a171-f2d869135665), Microsoft Support.]
- `ISBLANK(...)` bernilai `TRUE` jika sel kosong.
- `ISNUMBER(...)` bernilai `TRUE` jika sel berisikan angka.

# Koleksi Fungsi `IS*`

## Periksa _error_ / kosong

- `ISNA(...)`: Cek nilai apakah `#N/A`.
- `ISERR(...)`: Cek nilai apakah error selain `#N/A` (`#VALUE!`, `#REF!`, `#DIV/0!`, `#NUM!`, `#NAME?`, atau `#NULL!`).
- `ISERROR(...)`: Cek nilai apakah error (seluruh jenis error).
- `ISBLANK(...)`: Cek nilai apakah kosong.

## Periksa jenis sel

- `ISLOGICAL(...)`: Cek nilai apakah _logical_ (`TRUE` atau `FALSE`).
- `ISNUMBER(...)`: Cek nilai apakah angka ($\mathbb{R}$).
- `ISTEXT(...)`: Cek nilai apakah teks. Dan `ISNONTEXT(...)`: Cek niai apakah bukan teks (_number_, _logical_, _error_)
- `ISFORMULA(...)`: Cek nilai apakah formula.

## Periksa jenis bilangan

- `ISEVEN(...)`: Cek nilai apakah bilangan genap.
- `ISODD(...)`: Cek nilai apakah bilangan ganjil.

# Validasi _input_ dengan `ISNUMBER(...)`

## Validasi dengan `ISNUMBER(...)` (1) {.smaller}

$$ 
f : \mathbb{R} \to \mathbb{R}
$$

$$
f(\mathbf{x}) = \mathbf{y} = \mathbf{x} + 2
$$

$$
\mathbf{x} \in \mathbb{R}, \mathbf{y} \in \mathbb{R}
$$

$$
\mathbf{x}
\mapsto
\mathbf{x} + 2
$$

- Umumnya nilai $\mathbf{y}$ dihitung dengan formula `=x+2` dengan asumsi $\mathbf{x}$ bernilai **angka** $\{ \mathbf{x} \in \mathbb{R} \}$.

$$
\mathbf{x}
=
\begin{bmatrix}
  3 \\ 2 \\ 7
\end{bmatrix}
\mapsto
f(\mathbf{x})
=
\begin{bmatrix}
  3 \\ 2 \\ 7
\end{bmatrix}
+ 2 
=
\begin{bmatrix}
  5 \\ 4 \\ 9
\end{bmatrix}
$$

## Validasi dengan `ISNUMBER(...)` (2) 

- Bagaimana jika $\mathbf{x}$ memiliki elemen yang bukan angka yaitu _text_ / _error_ / _logical_?

$$
\mathbf{x}
=
\begin{bmatrix}
  3 \\ \textrm{bob} \\ 2
\end{bmatrix}
\mapsto
f(\mathbf{x})
=
\begin{bmatrix}
  3 \\ \textrm{bob} \\ 2
\end{bmatrix}
+ 2 
=
\begin{bmatrix}
  5 \\ \texttt{#VALUE!} \\ 2
\end{bmatrix}
$$

## Validasi dengan `ISNUMBER(...)` (3)  {.smaller}

- Validasi input menggunakan `ISNUMBER(...)`  

$$
\mathbf{x}
=
\begin{bmatrix}
  3 \\ \textrm{bob} \\ 2
\end{bmatrix}
\mapsto
\texttt{ISNUMBER}
\left(
  \mathbf{x}
\right)
=
\texttt{ISNUMBER}
\left(
  \begin{bmatrix}
    3 \\ \textrm{bob} \\ 2
  \end{bmatrix}
\right)
=
\begin{bmatrix}
  \texttt{TRUE} \\ \texttt{FALSE} \\ \texttt{TRUE}
\end{bmatrix}
$$

$$
\begin{bmatrix}
  \texttt{TRUE} \\ \texttt{FALSE} \\ \texttt{TRUE}
\end{bmatrix}
\mapsto
\texttt{AND}
\left(
  \mathbf{x}
\right)
=
\texttt{AND}
\left(
  \begin{bmatrix}
    \texttt{TRUE} \\ \texttt{FALSE} \\ \texttt{TRUE}
  \end{bmatrix}
\right)
= 
\texttt{FALSE}
$$

$$
\mathbf{x}
\mapsto
\texttt{AND}(
  \texttt{ISNUMBER}(
    \mathbf{x}
  )
)
=
\texttt{AND}(
  \texttt{ISNUMBER}(
    \begin{bmatrix}
      3 \\ \textrm{bob} \\ 2
    \end{bmatrix}
  )
) 
=
\texttt{FALSE}
$$

## Validasi dengan `ISNUMBER(...)` (4) {.smaller}

$$
\begin{equation}
  \mathbf{x} 
  \mapsto 
  \texttt{AND}
  (
    \texttt{ISNUMBER}(\mathbf{x})
  )
  =
  \begin{cases}
    \texttt{TRUE} & f : \mathbf{x} \in \mathbb{R} \rightarrow \mathbb{R}\\
    \texttt{FALSE} & \textrm{return}\ \texttt{#VALUE!} \\
    \texttt{FALSE} & \mathbf{x} \mapsto g(\mathbf{x}) = \texttt{FILTER}(\dots) \mapsto \\
    & f: g(\mathbf{x}) \in \mathbb{R} \rightarrow \mathbb{R}\\
  \end{cases}
\end{equation}
$$

- Validasi ini dapat diimplementasikan ketika terdapat ketidakpastian jika $\mathbf{x}$ dapat bernilai bukan angka ($\mathbf{x} \in \mathbb{R} \lor \mathbf{x} \notin \mathbb{R}$)
- Solusi lain dengan melakukan _filter_ pada $\mathbf{x}$ dan hanya mengambil elemen yang angka dengan `FILTER(...)`. 

# 3 _Dynamic Array Formula_ (DAF)

Koleksi fungsi baru (Excel 2021) yang memanfaatkan _dynamic array_. 

# Menyeleksi/memilih data

Menggunakan `FILTER(...)` dan `UNIQUE(...)`

## `FILTER(...)` (1)

- `FILTER(...)`: Fungsi `FILTER` memungkinkan Anda memfilter rentang data berdasarkan kriteria yang ditetapkan. ^[[Fungsi FILTER](https://support.microsoft.com/id-id/office/fungsi-filter-f4f7cb66-82eb-4767-8f7c-4877ad80c759), Microsoft Support.]

```scala
=FILTER(array, include, [if_empty])
```

- Argumen `include` harus berupa _vector_ (kolom atau baris). dan jumlah kolom/baris harus sama dengan `array`. 
- Argumen `if_empty` dapat diisi dengan nilai ketika argumen include kosong atau `FALSE`.

## `FILTER(...)` (2) {.smaller}

$$
\texttt{FILTER}
\left(
  \underbrace{
    \begin{bmatrix}
      10 & 8\\
      \textit{A} & -100\\
      -3 & \textit{y}
    \end{bmatrix}
  }_{\texttt{array}}
  ,
  \underbrace{
    \overbrace{
      \begin{bmatrix}
        \texttt{TRUE}\\
        \texttt{FALSE}\\
        \texttt{TRUE}
      \end{bmatrix}
    }^{\textit{logical column vector}}
  }_{\texttt{include}}
\right)
=
\underbrace{
  \begin{bmatrix}
      10 & 8\\
      -3 & \textit{y}
    \end{bmatrix}
}_{\textit{hasil}}
$$

$$
\texttt{FILTER}
\left(
  \underbrace{
    \begin{bmatrix}
      10 & 8\\
      \textit{A} & -100\\
      -3 & \textit{y}
    \end{bmatrix}
  }_{\texttt{array}}
  ,
  \underbrace{
    \overbrace{
      \begin{bmatrix}
        \texttt{FALSE} & \texttt{TRUE}
      \end{bmatrix}
    }^{\textit{logical row vector}}
  }_{\texttt{include}}
\right)
=
\underbrace{
  \begin{bmatrix}
      8\\
      -100\\
      \textit{y}
    \end{bmatrix}
}_{\textit{hasil}}
$$

## `FILTER(...)` (3) {.smaller}

$$
\texttt{FILTER}
\left(
  \underbrace{
    \begin{bmatrix}
      10 & 8\\
      \textit{A} & -100\\
      -3 & \textit{y}
    \end{bmatrix}
  }_{\texttt{array}}
  ,
  \underbrace{
    \overbrace{
      \begin{bmatrix}
        \texttt{FALSE}\\
        \texttt{FALSE}\\
        \texttt{FALSE}
      \end{bmatrix}
    }^{\textit{logical column vector}}
  }_{\texttt{include}}
  ,
  \underbrace{
    \textrm{tidak ada}
  }_{\texttt{if_empty}}
\right)
=
\textrm{tidak ada}
$$

## `FILTER(...)` (4) {.smaller}

$$
\texttt{array} = \mathbf{A} \rightarrow \mathbf{A} \in \mathbb{U}^{m \times n}, \{m, n \in \mathbb{N}\ |\ m, n \neq 0 \}
$$

$$
\mathbb{U} = \{ \textrm{seluruh nilai } u \textrm{ yang dapat digunakan di Excel}\}
$$

- $m$ menunjukkan jumlah baris dan $n$ menunjukkan jumlah kolom. 

$$
\texttt{include} = \mathbf{i} \rightarrow \mathbf{i} \in \mathbb{B}^{k}, \{k = m \lor k = n\}
$$

- $\mathbf{i}$ selalu berupa _logical vector_ dengan jumlah baris/kolom $k$ sama dengan $m \lor n$. 

## `UNIQUE(...)` (1) {.smaller}

- `UNIQUE(...)`: Fungsi `UNIQUE` menghasilkan daftar nilai yang unik dalam daftar atau rentang. ^[[Fungsi UNIQUE](https://support.microsoft.com/id-id/office/fungsi-unique-c5ab87fd-30a3-4ce9-9d1a-40204fb85e1e), Microsoft Support.]

```scala
=UNIQUE(array, [by_col], [exactly_once])
```

- Penggunaan argumen `by_col` untuk mencari nilai unik untuk setiap baris atau kolom. Nilai _default_ argumen `by_col <- FALSE`.
- Argumen `exactly_once` dapat digunakan untuk menyaring nilai unik yang muncul lebih dari satu kali. Jika `exactly_once <- TRUE`, maka jika terdapat nilai unik yang muncul dua kali akan dihapus. Nilai _default_ argumen `exactly_once <- FALSE`. 

## `UNIQUE(...)` (2)

$$
\texttt{UNIQUE}
\left(
  \underbrace{
    \overbrace{
      \begin{bmatrix}
        1 & 1 & 3 & 1\\
        4 & 2 & 7 & 2\\
        3 & 2 & 8 & 2\\
        1 & 1 & 3 & 1\\
        5 & 2 & 9 & 2
      \end{bmatrix}      
    }^{\textit{array / vector}}
  }_{\texttt{array}}
\right)
\Rightarrow
  \underbrace{
    \begin{bmatrix}
        1 & 1 & 3 & 1\\
        4 & 2 & 7 & 2\\
        3 & 2 & 8 & 2\\
        5 & 2 & 9 & 2
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `UNIQUE(...)` (3) {.smaller}

$$
\texttt{UNIQUE}
\left(
  \underbrace{
    \overbrace{
      \begin{bmatrix}
        1 & 1 & 3 & 1\\
        4 & 2 & 7 & 2\\
        3 & 2 & 8 & 2\\
        1 & 1 & 3 & 1\\
        5 & 2 & 9 & 2
      \end{bmatrix}      
    }^{\textit{array / vector}}
  }_{\texttt{array}}
  ,
  \underbrace{
    \texttt{ TRUE }
  }_{\texttt{by_col}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        1 & 1 & 3\\
        4 & 2 & 7\\
        3 & 2 & 8\\
        1 & 1 & 3\\
        5 & 2 & 9
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `UNIQUE(...)` (4) {.smaller}

$$
\texttt{UNIQUE}
\left(
  \underbrace{
    \overbrace{
      \begin{bmatrix}
        1 & 1 & 3 & 1\\
        4 & 2 & 7 & 2\\
        3 & 2 & 8 & 2\\
        1 & 1 & 3 & 1\\
        5 & 2 & 9 & 2
      \end{bmatrix}      
    }^{\textit{array / vector}}
  }_{\texttt{array}}
  ,
  \underbrace{
    \texttt{ FALSE }
  }_{\texttt{by_col}}
  ,
  \underbrace{
    \texttt{ TRUE }
  }_{\texttt{exactly_once}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        4 & 2 & 7 & 2\\
        3 & 2 & 8 & 2\\
        5 & 2 & 9 & 2
      \end{bmatrix}
  }_{\textit{hasil}}
$$

# Membangkitkan data

Menggunakan `SEQUENCE(...)` dan `RANDARRAY(...)`.

## `SEQUENCE(...)` (1)

- `SEQUENCE(...)`: Fungsi `SEQUENCE` memungkinkan Anda menghasilkan daftar angka yang berurutan dalam larik seperti ${1, 2, 3, 4, \dots}$. ^[[Fungsi SEQUENCE](https://support.microsoft.com/id-id/office/fungsi-sequence-57467a98-57e0-4817-9f14-2eb78519ca90), Microsoft Support.]

```scala
=SEQUENCE(rows, [columns], [start], [step])
```
- Hasil `SEQUENCE(...) => numeric vector/array`. 
- Nilai _default_ argumen: `columns <- 1`, `start <- 1`, `step <- 1`. 

## `SEQUENCE(...)` (2) {.smaller}

$$
\texttt{SEQUENCE}
\left(
  \underbrace{
    5
  }_{\texttt{rows}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        1\\
        2\\
        3\\
        4\\
        5
      \end{bmatrix}
  }_{\textit{hasil}}
$$

$$
\texttt{SEQUENCE}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
  ,
  \underbrace{
    4
  }_{\texttt{columns}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        1	& 2	 & 3	& 4\\
        5	& 6	 & 7	& 8\\
        9	& 10 & 11	& 12
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `SEQUENCE(...)` (3) {.smaller}

$$
\texttt{SEQUENCE}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
  ,
  \underbrace{
    4
  }_{\texttt{columns}}
  ,
  \underbrace{
    10
  }_{\texttt{start}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        10 & 11 & 12 & 13\\
        14 & 15 & 16 & 17\\
        18 & 19 & 20 & 21\\
      \end{bmatrix}
  }_{\textit{hasil}}
$$

$$
\texttt{SEQUENCE}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
  ,
  \underbrace{
    4
  }_{\texttt{columns}}
  ,
  \underbrace{
    10
  }_{\texttt{start}}
  ,
  \underbrace{
    3
  }_{\texttt{step}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        10 & 13 & 16 & 19\\
        22 & 25 & 28 & 31\\
        34 & 37 & 40 & 43\\
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `RANDARRAY(...)` (1) {.smaller}

- `RANDARRAY(...)`: Fungsi `RANDARRAY` menghasilkan larik angka acak. Anda dapat menentukan jumlah baris dan kolom yang akan diisi, nilai minimum dan maksimum, dan apakah fungsi mengembalikan bilangan bulat atau nilai desimal. ^[[Fungsi RANDARRAY](https://support.microsoft.com/id-id/office/randarray-fungsi-randarray-21261e55-3bec-4885-86a6-8b0a47fd4d33), Microsoft Support.]

```scala
=RANDARRAY([rows], [columns], [min], [max], [whole_number])
```

- Nilai _default_ argumen: `rows <- 1`, `columns <- 1`, `min <- 0`, `max <- 1`, `whole_number <- FALSE`. 
- Jika tidak diisi argumen maka hasil `RANDARRAY()` adalah bilangan _real_ $\mathbb{R}$ acak dengan rentang $[0, 1]$. 

## `RANDARRAY(...)` (2) {.smaller}

$$
\texttt{RANDARRAY}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        0.036290129\\
        0.831941087\\
        0.596526220
      \end{bmatrix}
  }_{\textit{hasil}}
$$

$$
\texttt{RANDARRAY}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
  ,
  \underbrace{
    2
  }_{\texttt{columns}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        0.950708256 & 0.044725252\\
        0.111202134 & 0.34866703\\
        0.119602266 & 0.792763221
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `RANDARRAY(...)` (3) {.smaller}

$$
\texttt{RANDARRAY}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
  ,
  \underbrace{
    2
  }_{\texttt{columns}}
  ,
  \underbrace{
    3
  }_{\texttt{min}}
  ,
  \underbrace{
    10
  }_{\texttt{max}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        5.033450196 & 7.903953859\\
        7.918426053 & 6.750036234\\
        7.926034250 & 3.596169723\\
      \end{bmatrix}
  }_{\textit{hasil}}
$$

$$
\texttt{RANDARRAY}
\left(
  \underbrace{
    3
  }_{\texttt{rows}}
  ,
  \underbrace{
    2
  }_{\texttt{columns}}
  ,
  \underbrace{
    3
  }_{\texttt{min}}
  ,
  \underbrace{
    10
  }_{\texttt{max}}
  ,
  \underbrace{
    \texttt{ TRUE }
  }_{\texttt{whole_number}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        9 & 4\\
        5 & 6\\
        7 & 8
      \end{bmatrix}
  }_{\textit{hasil}}
$$

# Menyusun data

Menggunakan `SORT(...)` dan `SORTBY(...)`.

## `SORT(...)` (1) 

- `SORT(...)`: Fungsi `SORT` mengurutkan konten rentang atau larik. ^[[Fungsi SORT](https://support.microsoft.com/id-id/office/fungsi-sort-22f63bd0-ccc8-492f-953d-c20e8e44b86c), Microsoft Support.]

```vb
=SORT(array, [sort_index], [sort_order], [by_col])
```

- Nilai _default_ argumen: `sort_index <- 1`, `sort_order <- 1 (Ascending)`, `by_col <- FALSE`.

## `SORT(...)` (2) {.smaller}

$$
\texttt{SORT}
\left(
  \underbrace{
    \begin{bmatrix}
      3 & 2 & 4 & 4\\
      2 & 3 & 1 & 2\\
      4 & 2 & 3 & 2
    \end{bmatrix}
  }_{\texttt{array}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        2 & 3 & 1 & 2\\
        3 & 2 & 4 & 4\\
        4 & 2 & 3 & 2
      \end{bmatrix}
  }_{\textit{hasil}}
$$

$$
\texttt{SORT}
\left(
  \underbrace{
    \begin{bmatrix}
      3 & 2 & 4 & 4\\
      2 & 3 & 1 & 2\\
      4 & 2 & 3 & 2
    \end{bmatrix}
  }_{\texttt{array}}
  ,
  \underbrace{
    3
  }_{\texttt{sort_index}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        2 & 3 & 1 & 2\\
        4 & 2 & 3 & 2\\
        3 & 2 & 4 & 4
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `SORT(...)` (3) {.smaller}

$$
\texttt{SORT}
\left(
  \underbrace{
    \begin{bmatrix}
      3 & 2 & 4 & 4\\
      2 & 3 & 1 & 2\\
      4 & 2 & 3 & 2
    \end{bmatrix}
  }_{\texttt{array}}
  ,
  \underbrace{
    3
  }_{\texttt{sort_index}}
  ,
  \underbrace{
    -1
  }_{\texttt{sort_order}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        3 & 2 & 4 & 4\\
        4 & 2 & 3 & 2\\
        2 & 3 & 1 & 2
      \end{bmatrix}
  }_{\textit{hasil}}
$$

$$
\texttt{SORT}
\left(
  \underbrace{
    \begin{bmatrix}
      3 & 2 & 4 & 4\\
      2 & 3 & 1 & 2\\
      4 & 2 & 3 & 2
    \end{bmatrix}
  }_{\texttt{array}}
  ,
  \underbrace{
    2
  }_{\texttt{sort_index}}
  ,
  \underbrace{
    1
  }_{\texttt{sort_order}}
  ,
  \underbrace{
    \texttt{ TRUE }
  }_{\texttt{by_col}}
\right)
\Rightarrow
  \underbrace{
      \begin{bmatrix}
        4 & 3 & 4 & 2\\
        1 & 2 & 2 & 3\\
        3 & 4 & 2 & 2
      \end{bmatrix}
  }_{\textit{hasil}}
$$

## `SORTBY(...)` (1) {.smaller}

- `SORTBY(...)`: Fungsi `SORTBY` mengurutkan konten rentang atau larik berdasarkan nilai dalam rentang atau larik yang terkait. ^[[Fungsi SORTBY](https://support.microsoft.com/id-id/office/fungsi-sortby-cd2d7a62-1b93-435c-b561-d6a35134f28f), Microsoft Support.]

```vb
=SORTBY(array, by_array1, [sort_order1], [by_array2], [sort_order2], ...)
```

- Nilai default `sort_order <- 1` (_ascending_).
- Nilai `by_array` harus berupa vektor atau _array_ 1 dimensi. Dan jenisnya harus sama dengan nilai `by_array` lainnya (tidak boleh berbeda dimensinya). 
- Jika diurutkan hanya berdasarkan satu _array_ dan berdasarkan kolom/baris di dalam _array_ tersebut, sebaiknya menggunakan `SORT`. 

## `SORTBY(...)` (2) {.smaller}

$$
\mathbf{A} 
= 
\begin{bmatrix}
  \textrm{A} & \textrm{BA} & \textrm{CBBA}\\
  \textrm{B} & \textrm{CB} & \textrm{DCCB}\\
  \textrm{C} & \textrm{DC} & \textrm{EDDC}\\
  \textrm{D} & \textrm{ED} & \textrm{FEED}\\
  \textrm{E} & \textrm{FE} & \textrm{GFFE}\\
  \textrm{F} & \textrm{GF} & \textrm{IGGF}\\
  \textrm{G} & \textrm{IG} & \textrm{AIG}
\end{bmatrix},
\mathbf{c}_1
= 
\begin{bmatrix}
  1\\
  3\\
  3\\
  2\\
  2\\
  1\\
  4\\
\end{bmatrix}
,
\mathbf{c}_2
= 
\begin{bmatrix}
  1\\
  3\\
  5\\
  6\\
  2\\
  7\\
  8\\
\end{bmatrix}
$$

$$
\mathbf{r}_1
=
\begin{bmatrix}
  3 & 1 & 1
\end{bmatrix}
,
\mathbf{r}_2
=
\begin{bmatrix}
  7 & 1 & 3
\end{bmatrix}
$$

$$
\texttt{SORTBY}(
  \mathbf{A}, \mathbf{c}_1
) \lor
\texttt{SORTBY}(
  \mathbf{A}, 
  \mathbf{r}_1,
  -1,
)
$$

$$
\texttt{SORTBY}(
  \mathbf{A}, 
  \mathbf{c}_1,,
  \mathbf{c}_2,-1
) \lor
\texttt{SORTBY}(
  \mathbf{A}, 
  \mathbf{r}_2,-1,
  \mathbf{r}_1
)
$$

## `SORTBY(...)` (3) {.smaller}

$$
\mathbf{A}, \mathbf{c}_1
\overbrace{\longmapsto}^{
  \texttt{SORTBY}(
    \mathbf{A}, \mathbf{c}_1
  )
}
\begin{bmatrix}
  A & BA & CBBA\\
  F & GF & IGGF\\
  D & ED & FEED\\
  E & FE & GFFE\\
  B & CB & DCCB\\
  C & DC & EDDC\\
  G & IG & AIG\\
\end{bmatrix}
,
\texttt{index} \leftarrow
\begin{bmatrix}
  1\\
  6\\
  4\\
  5\\
  2\\
  3\\
  7\\
\end{bmatrix}
,
\texttt{SORT}(\mathbf{c}_1) =
\begin{bmatrix}
  1\\
  1\\
  2\\
  2\\
  3\\
  3\\
  4\\
\end{bmatrix}
$$

## `SORTBY(...)` (4) {.smaller}

$$
\mathbf{A}, \mathbf{c}_1, \mathbf{c}_2
\overbrace{\longmapsto}^{
  \texttt{SORTBY}(
    \mathbf{A}, \mathbf{c}_1,, \mathbf{c}_2, -1
  )
}
\begin{bmatrix}
  F & GF & IGGF\\
  A & BA & CBBA\\
  D & ED & FEED\\
  E & FE & GFFE\\
  C & DC & EDDC\\
  B & CB & DCCB\\
  G & IG & AIG\\
\end{bmatrix}
,
\texttt{index} \leftarrow
\begin{bmatrix}
  6\\
  1\\
  4\\
  5\\
  3\\
  2\\
  7\\
\end{bmatrix}
$$

$$
\texttt{SORT}(\mathbf{c}_1) =
\begin{bmatrix}
  1\\
  1\\
  2\\
  2\\
  3\\
  3\\
  4\\
\end{bmatrix}
,
\texttt{SORT}(\mathbf{c}_2, -1) =
\begin{bmatrix}
  7\\
  1\\
  6\\
  2\\
  5\\
  3\\
  8\\
\end{bmatrix}
$$

# Mencari data

## `XLOOKUP(...)` (1) 

- `XLOOKUP(...)`: Fungsi `XLOOKUP` mencari rentang atau array, lalu mengembalikan item yang terkait dengan kecocokan pertama yang ditemukannya. Jika tidak ada kecocokan, `XLOOKUP` dapat mengembalikan kecocokan terdekat (perkiraan). ^[[Fungsi XLOOKUP](https://support.microsoft.com/id-id/office/fungsi-xlookup-b7fd680e-6d10-43e6-84f9-88eae8bf5929), Microsoft Support.]

```scala
=XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])
```

## `XMATCH(...)` (1) 

- `XMATCH(...)`: Fungsi `XMATCH` mengembalikan posisi relatif item dalam array atau rentang sel. ^[[Fungsi XMATCH](https://support.microsoft.com/id-id/office/fungsi-xmatch-d966da31-7a6b-4a13-a1c6-5a33ed6a0312), Microsoft Support.]

```scala
=XMATCH(lookup_value, lookup_array, [match_mode], [search_mode])
```

# 4 Fungsi Baru (2019-2021)

# Penggabungan Teks {.smaller}

## `CONCAT(...)` dan `TEXTJOIN(...)` (1) {.smaller}

- `CONCAT(...)`: Fungsi `CONCAT` menggabungkan teks dari beberapa rentang dan/atau string, tetapi tidak menyediakan argumen pemisah atau IgnoreEmpty. ^[[Fungsi CONCAT](https://support.microsoft.com/id-id/office/concat-fungsi-concat-9b1a9a3f-94ff-41af-9736-694cbd6b4ca2), Microsoft Support.]

```scala
=CONCAT(text1, [text2], ...)
```

- `TEXTJOIN(...)`: Fungsi `TEXTJOIN` menggabungkan teks dari beberapa rentang dan/atau string, serta menyertakan pemisah yang Anda tentukan antara tiap nilai teks yang akan digabungkan. Jika pemisah adalah string teks kosong, fungsi ini akan secara efektif menggabungkan rentang. ^[[Fungsi TEXTJOIN](https://support.microsoft.com/id-id/office/textjoin-fungsi-textjoin-357b449a-ec91-49d0-80c3-0e8fc845691c), Microsoft Support.]

```scala
=TEXTJOIN(delimiter, ignore_empty, text1, [text2], ...)
```

## `CONCAT(...)` dan `TEXTJOIN(...)` (2) {.smaller}

- Hal yang membedakan `TEXTJOIN(...)` dengan `CONCAT(...)` adalah argumen karakter diantara teks gabungan dengan kondisi ketika sel kosong. Nilai `TEXTJOIN(...) === CONCAT(...)` ketika argumen `delimeter <- ""` dan `ignore_empty <- TRUE`. 

$$
\mathbf{T} = 
\begin{bmatrix}
  \textrm{nama} &
  \textrm{saya} &
  \textrm{taruma}\\
  1 &
  \textrm{pergi} &
  3 \\
  \texttt{TRUE} &
  100 &
  \texttt{FALSE}\\
\end{bmatrix}
$$

## `CONCAT(...)` dan `TEXTJOIN(...)` (3) {.smaller}

$$
\mathbf{T} = 
\begin{bmatrix}
  \textrm{nama} &
  \textrm{saya} &
  \textrm{taruma}\\
  1 &
  \textrm{pergi} &
  3 \\
  \texttt{TRUE} &
  100 &
  \texttt{FALSE}\\
\end{bmatrix}
$$

$$
\texttt{CONCAT}(\mathbf{T}) =
\textrm{namasayataruma1pergi3TRUE100FALSE}
$$

$$
\texttt{TEXTJOIN}(\texttt{""}, \texttt{TRUE}, \mathbf{T}) =
\textrm{namasayataruma1pergi3TRUE100FALSE}
$$

$$
\texttt{TEXTJOIN}(\texttt{" "}, \texttt{TRUE}, \mathbf{T}) =
\textrm{nama saya taruma 1 pergi 3 TRUE 100 FALSE}
$$

# KOLEKSI `IF*`

## `IFS(...)` dan `MINIFS(...)` {.smaller}

- `IFS(...)`: Fungsi `IFS` memeriksa apakah satu atau beberapa kondisi terpenuhi dan mengembalikan nilai yang sesuai dengan kondisi `TRUE` pertama. `IFS` dapat menggantikan beberapa pernyataan `IF` yang bertumpuk, dan jauh lebih mudah dibaca dengan beberapa kondisi. ^[[Fungsi IFS](https://support.microsoft.com/id-id/office/ifs-fungsi-ifs-36329a26-37b2-467c-972b-4a39bd951d45), Microsoft Support.]

```scala
=IFS(logical_test1, value_if_true1, [logical_test2, value_if_true2], [logical_test3, value_if_true3], ..., value_if_false)
```

- `MINIFS(...)` / `MAXIFS(...)`: Fungsi `MINIFS` mengembalikan nilai minimal di antara sel yang ditentukan oleh kumpulan persyaratan atau kriteria tertentu / Fungsi `MAXIFS` mengembalikan nilai maksimal di antara sel yang ditentukan oleh kumpulan persyaratan atau kriteria tertentu. ^[[Fungsi MINIFS](https://support.microsoft.com/id-id/office/minifs-fungsi-minifs-6ca1ddaa-079b-4e74-80cc-72eef32e6599), Microsoft Support.] ^[[Fungsi MAXIFS](https://support.microsoft.com/id-id/office/maxifs-fungsi-maxifs-dfd611e6-da2c-488a-919b-9b6376b28883), Microsoft Support.]

```scala
=[MIN/MAX]IFS([min/max]_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)
```

## CONTOH `IFS` (`IF(...)`) {auto-animate="true"}

$$
[-\infty,70) \Rightarrow \text{C}\\
[70,85) \Rightarrow \text{B}\\
[85,\infty) \Rightarrow \text{A}
$$

```{.scala}
=IF(
  x < 70, "C", 
  IF(
    x < 85, "B",
    "A"
  )
)
```

## CONTOH `IFS` (`IFS(...)`) {auto-animate="true"}

$$
[-\infty,70) \Rightarrow \text{C}\\
[70,85) \Rightarrow \text{B}\\
[85,\infty) \Rightarrow \text{A}
$$

```{.scala}
=IFS(
  x < 70, "C", 
  x < 85, "B",
  TRUE, "A"
)
```

# `SWITCH(...)` dan `LET(...)`

## `SWITCH(...)`

- `SWITCH(...)`: Fungsi `SWITCH` mengevaluasi satu nilai (disebut ekspresi) terhadap daftar nilai, dan mengembalikan hasil yang terkait dengan nilai cocok pertama. Jika tidak terdapat kecocokan, nilai default opsional mungkin akan dikembalikan. ^[[Fungsi SWITCH](https://support.microsoft.com/id-id/office/switch-fungsi-switch-47ab33c0-28ce-4530-8a45-d532ec4aa25e), Microsoft Support.] 

```scala
=SWITCH(expression, value1, result1, [default or value2, result2], ..., [default or value3, result3])
```

## `LET(...)`

- `LET(...)`: Fungsi `LET` menetapkan nama ke hasil perhitungan. Ini memungkinkan menyimpan perhitungan menengah, nilai, atau menetapkan nama di dalam rumus. Nama ini hanya berlaku di dalam lingkup `LET` fungsi. Mirip dengan variabel dalam pemrograman, `LET` dilakukan melalui Excel rumus asli Anda. ^[[Fungsi LET](https://support.microsoft.com/id-id/office/fungsi-let-34842dd8-b92b-4d3f-b325-b8b8f9908999), Microsoft Support.] 

```scala
=LET(name1, name_value1, calculation_or_name2, [name_value2, calculation_or_name2], ..., calculation)
```

## CONTOH `LET(...)` dan `SWITCH(...)` {auto-animate="true"}

$$
\text{A} \Rightarrow 90,
\text{B} \Rightarrow 80,
\text{C} \Rightarrow 70,
\text{D} \Rightarrow 60,\\
\notin \{\text{A}, \text{B}, \text{C}, \text{D}\} \Rightarrow 20
$$

```{.scala}
=IFS(
  C$2 = "A", 90,
  C$2 = "B", 80,
  C$2 = "C", 70,
  C$2 = "D", 60,
  TRUE, 20
)
```

## CONTOH `LET(...)` dan `SWITCH(...)` {auto-animate="true"}

$$
\text{A} \Rightarrow 90,
\text{B} \Rightarrow 80,
\text{C} \Rightarrow 70,
\text{D} \Rightarrow 60,\\
\notin \{\text{A}, \text{B}, \text{C}, \text{D}\} \Rightarrow 20
$$

```{.scala code-line-numbers="1,2,4-7"}
=LET(
  data, C$2,
  IFS(
    data = "A", 90,
    data = "B", 80,
    data = "C", 70,
    data = "D", 60,
    TRUE, 20
  )
)
```

## CONTOH `LET(...)` dan `SWITCH(...)` {auto-animate="true"}

$$
\text{A} \Rightarrow 90,
\text{B} \Rightarrow 80,
\text{C} \Rightarrow 70,
\text{D} \Rightarrow 60,\\
\notin \{\text{A}, \text{B}, \text{C}, \text{D}\} \Rightarrow 20
$$

```{.scala code-line-numbers="3-10"}
=LET(
  data, C$2,
  SWITCH(
    data,
    "A", 90,
    "B", 80,
    "C", 70,
    "D", 60,
    20
  )
)
```

# Implementasi pada validasi input
Memperbaiki validasi input dari kasus sebelumnya.

## Kasus validasi {.smaller}

$$ 
f : \mathbb{R} \to \mathbb{R}
$$

$$
f(\mathbf{x}) = \mathbf{y} = \mathbf{x} + 2
$$

$$
\mathbf{x} \in \mathbb{R}, \mathbf{y} \in \mathbb{R}
$$

$$
\mathbf{x}
\mapsto
\mathbf{x} + 2
$$

$$
\begin{equation}
  \mathbf{x} 
  \mapsto 
  \texttt{AND}
  (
    \texttt{ISNUMBER}(\mathbf{x})
  )
  =
  \begin{cases}
    \texttt{TRUE} & f : \mathbf{x} \in \mathbb{R} \rightarrow \mathbb{R}\\
    \texttt{FALSE} & \textrm{return}\ \texttt{#VALUE!} \\
    \texttt{FALSE} & \mathbf{x} \mapsto g(\mathbf{x}) = \texttt{FILTER}(\dots) \mapsto \\
    & f: g(\mathbf{x}) \in \mathbb{R} \rightarrow \mathbb{R}\\
  \end{cases}
\end{equation}
$$

- $\mathbf{x}$ akan dievaluasi terlebih dahulu dan di filter dengan memilih elemen yang berupa angka saja.
- $\mathbf{x} \mapsto \mathbf{y}$ dengan $y \in \mathbb{R}$ dan $x \in \mathbb{?}$.

## Formula {auto-animate="true"}

$$
g : \mathbf{x} \in \mathbb{?} \to \mathbb{R}
$$

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

## Formula {auto-animate="true"}

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

```{.scala}
=LET(
  ...
)
```

## Formula {auto-animate="true"}

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

```{.scala code-line-numbers="2-3"}
=LET(
  x, H8:H15,
  ...
)
```

## Formula {auto-animate="true"}

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

```{.scala code-line-numbers="3-4"}
=LET(
  x, H8:H15,
  logical_isnumber, ISNUMBER(x),
  ...
)
```

## Formula {auto-animate="true"}

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

```{.scala code-line-numbers="3-5"}
=LET(
  x, H8:H15,
  logical_isnumber, ISNUMBER(x),
  y, FILTER(x, logical_isnumber),
  ...
)
```

## Formula {auto-animate="true"}

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

```{.scala code-line-numbers="3-4"}
=LET(
  x, H8:H15,
  y, FILTER(x, ISNUMBER(x)),
  y + 2
)
```

## Formula {auto-animate="true"}

$$
g(\mathbf{x}) = f(
  \underbrace{
    \texttt{FILTER}(\mathbf{x}, \texttt{ISNUMBER}(\mathbf{x}))
  }_{\mathbf{y\ \in\ \mathbb{R}}}
)
=
\underbrace{
  f(\mathbf{y})
}_{\in\ \mathbb{R}}
= 
\mathbf{y} + 2
$$

```{.scala}
=LET(
  x, H8:H15,
  y, FILTER(x, ISNUMBER(x)),
  y + 2
)
```

# 5 _User Defined Lambda_ (UDL) dengan `LAMBDA`

## `LAMBDA` dan UDL {.smaller}

- `LAMBDA(...)`: Gunakan fungsi `LAMBDA` untuk membuat fungsi kustom yang dapat digunakan kembali dan memanggilnya dengan nama yang mudah dikenali. Fungsi baru tersedia di seluruh buku kerja dan disebut seperti fungsi asli Excel. ^[[Fungsi LAMBDA](https://support.microsoft.com/id-id/office/fungsi-lambda-bd212d27-1cd1-4321-a34a-ccbf254b8b67), Microsoft Support.] 

```scala
=LAMBDA(parameter1, [parameter2, parameter3, ...], calculation)
```

- _User Defined Lambda_ (UDL) sama halnya dengan _User Defined Function_ (UDF) hanya spesifik pada penggunaan `LAMBDA`. UDF sendiri adalah fungsi yang dibuat oleh pengguna. 

## `LAMBDA` dan `LET`

- `LAMBDA` dan `LET` biasanya digunakan bersamaan untuk memudahkan pembuatan UDL ataupun membaca/_troubleshooting_.
- `LAMBDA` berfungsi menerima `input` dan membungkusnya sebagai fungsi baru di Excel sebagai UDL. 
- `LET` digunakan untuk melakukan perhitungan/kalkulasi setelah menerima input dari `LAMBDA`. 
- Jika UDL cukup sederhana, `LET` tidak perlu digunakan.

## Sintaks `LAMBDA` dan `LET` {auto-animate="true"}

```{.scala code-line-numbers="true"}
=LAMBDA(parameter1, [parameter2, parameter3, ...], calculation)
```

- Untuk memudahkan membaca kode, buat baris baru diantara `(...)`.

## Sintaks `LAMBDA` dan `LET` {auto-animate="true"}

```{.scala code-line-numbers="2-4"}
=LAMBDA(
  parameter1, 
  [parameter2, parameter3, ...],
  calculation
)
```

- Ubah `calculation` dengan `LET(...)`.

## Sintaks `LAMBDA` dan `LET` {auto-animate="true"}

```{.scala code-line-numbers="4-8|"}
=LAMBDA(
  parameter1, 
  [parameter2, parameter3, ...],
  LET(
    name1, value1,
    [name2, value2, name3, value3, ...],
    calculation
  )
)
```

- Argumen `parameter` yang berasal dari `LAMBDA`, dapat langsung digunakan di `LET` tanpa melakukan pendefinisian ulang.

## Sintaks `LAMBDA` dan `LET` {auto-animate="true"}

```{.scala code-line-numbers="2-4,6-8"}
=LAMBDA(
  parameter1, 
  parameter2,
  parameter3,
  LET(
    name1, parameter1 + parameter2,
    name2, parameter3 - name1
    name1 / parameter2
  )
)
```

::: {.nonincremental}
- `parameter2` bisa langsung digunakan pada `LET` tanpa pendefinisian ulang.
:::

# Contoh Kasus
Mengurangi setiap elemen pada vektor dengan setengah rata-ratanya.

## Deskripsi Kasus

- Mengurangi setiap elemen dari _numeric vector_ ($\mathbf{x}$) dengan setengah dari rata-ratanya ($\frac{\texttt{mean}(\mathbf{x})}{2}$).

$$
f : \mathbf{x} \in \mathbb{R} \to \mathbb{R}
$$

$$
f(\mathbf{x}) = 
\mathbf{x} - \frac{\overline{\mathbf{x}}}{2}
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

## Fungsi `LAMBDA` {auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="2-3"}
=LAMBDA(
  parameter1, 
  [parameter2, parameter3, ...],
  calculation
)
```

- menentukan _input_ variabel untuk fungsi `LAMBDA`.
- $f(\mathbf{x})$ menunjukkan input fungsi $f$ hanya vektor $\mathbf{x}$

## _input_ `LAMBDA` {auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="2|3"}
=LAMBDA(
  vector,
  calculation
)
```

- Karena fungsi $f$ memiliki perhitungan `AVERAGE(...)`, yang sebaiknya disimpan di variabel sementara, maka diperlukan kalkulasi menggunakan `LET(...)`. 

## Menggunakan `LET` {auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="3-7"}
=LAMBDA(
  vector,
  LET(
    name1, value1,
    [name2, value2, name3, value3, ...],
    calculation
  )
)
```

- Karena pada persamaan asli $f$ menggunakan simbol $\mathbf{x}$, bisa dilakukan _assignment_ / pendefinisian berupa `x <- vector`.

## Argumen _redundant_ / berulang {.smaller auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="4"}
=LAMBDA(
  vector,
  LET(
    x, vector,
    ..., ...,
    calculation
  )
)
```

- `x <- vector` merupakan argumen yang tidak perlu (_redundant_ / berulang) dikarenakan tidak ada modifikasi pada input _vector_.
- Selain itu, pada proses pengembangan `LAMBDA` lebih baik menggunakan nama variabel yang mudah diingat atau dipahami. 

## Perhitungan dalam fungsi `LET` {.smaller auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="4"}
=LAMBDA(
  vector,
  LET(
    ..., ...,
    calculation
  )
)
```

- Nilai rata-rata bisa disimpan sebagai variabel `avg`.

```r
avg <- AVERAGE(vector)
```

- Variabel `halfavg` menyatakan nilai setengah dari rata-rata vektor.

```r
halfavg <- avg / 2
```

- Hasil akhir dapat disimpan sebagai variabel `result`.

```r
result <- vector - halfavg
```

## Mengisi hasil dari `LAMBDA` {.smaller auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="4-6|7"}
=LAMBDA(
  vector,
  LET(
    avg, AVERAGE(vector),
    halfavg, avg / 2,
    result, vector - halfavg,
    ...
  )
)
```

- Fungsi `LAMBDA` ini masih belum mengeluarkan hasil atau _return_ dari fungsinya. 
- Pada argumen terakhir `LET` disampaikan kembali hasil yang diperoleh dari seluruh perhitungan. Yaitu `result`. 

## Menghindari pendefinisian berulang {.smaller auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="6-7"}
=LAMBDA(
  vector,
  LET(
    avg, AVERAGE(vector),
    halfavg, avg / 2,
    result, vector - halfavg,
    result
  )
)
```

- Pada baris ke-6 dan ke-7 bisa dibuat lebih sederhana menjadi satu baris dan langsung memberikan _return_ atau hasil dari fungsi `LAMBDA`.

## Formula akhir {auto-animate="true"}

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```{.scala code-line-numbers="6|"}
=LAMBDA(
  vector,
  LET(
    avg, AVERAGE(vector),
    halfavg, avg / 2,
    vector - halfavg
  )
)
```

- Fungsi `LAMBDA` sudah lengkap dan bisa langsung digunakan.

## Rekap {auto-animate="true"}

$$
f : \mathbf{x} \in \mathbb{R} \to \mathbb{R}
$$

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```scala
=LAMBDA(
  vector,
  LET(
    avg, AVERAGE(vector),
    halfavg, avg / 2,
    vector - halfavg
  )
)
```

## Menggunakan formula di Excel (1) {.smaller auto-animate="true"}

$$
f : \mathbf{x} \in \mathbb{R} \to \mathbb{R}
$$

$$
f(\mathbf{x})
=
\mathbf{x} - \frac{\texttt{AVERAGE}(\mathbf{x})}{2}
$$

```scala
=LAMBDA(
  vector,
  LET(
    avg, AVERAGE(vector),
    halfavg, avg / 2,
    vector - halfavg
  )
)
```

- Salin formula diatas dan simpan sebagai fungsi bernama `HALFAVG(...)`.

## Menggunakan formula di Excel (2)

![](assets/feidlambda-2-formula-excel.gif)

# Pengembangan lebih lanjut

## Validasi _input_ (1) {.smaller auto-animate="true"}

$$
g : \mathbf{y} \in \mathbb{?} \to \mathbb{R}
$$

$$
\mathbb{y}_{\textit{filtered}} \leftarrow \text{VALIDASI}(\mathbf{y})
$$

$$
g(\mathbf{y})
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{2}
$$

```{.scala code-line-numbers="2,4,5,7"}
=LAMBDA(
  vector,
  LET(
    ...,...,
    avg, AVERAGE(vector),
    halfavg, avg / 2,
    vector - halfavg
  )
)
```

## Validasi _input_ (2) {auto-animate="true"}

$$
g(\mathbf{y})
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{2}
$$

```{.scala code-line-numbers="2,4,5,7"}
=LAMBDA(
  vector,
  LET(
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    avg, AVERAGE(vector_filtered),
    halfavg, avg / 2,
    vector_filtered - halfavg
  )
)
```

## _Refactoring_ (1) {.smaller auto-animate="true"}

$$
g(\mathbf{y})
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{2}
$$

```{.scala code-line-numbers="5-6"}
=LAMBDA(
  vector,
  LET(
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    avg, AVERAGE(vector_filtered),
    halfavg, avg / 2,
    vector_filtered - halfavg
  )
)
```

- _Refactoring_ merupakan perubahan dari kode program yang sudah ada tanpa mengubah hasil dari program tersebut.
- variabel `avg` bisa langsung diterapkan pada variabel `halfavg`. 

## _Refactoring_ (2) {auto-animate="true"}

$$
g(\mathbf{y})
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{2}
$$

```{.scala code-line-numbers="5"}
=LAMBDA(
  vector,
  LET(
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    halfavg, AVERAGE(vector_filtered) / 2,
    vector_filtered - halfavg
  )
)
```

## _Optional argument_ (1) {auto-animate="true"}

$$
g(\mathbf{y})
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{2}
$$

$$
\mathbf{y}, n \mapsto g(\mathbf{y}, n)
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{n}
$$

$$
\begin{equation}
  n = 
  \begin{cases}
    \dots & \mathbf{y}, n = 2 \mapsto g(\mathbf{y}, 2) = f(\mathbf{y}_{\textit{filtered}})\\
    n & \mathbf{y}, n \mapsto g(\mathbf{y}, n)
  \end{cases}
\end{equation}
$$

## _Optional argument_ (2) {auto-animate="true"}

$$
\mathbf{y}, n \mapsto g(\mathbf{y}, n)
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{n}
$$

```{.scala code-line-numbers="true"}
=LAMBDA(
  vector,
  LET(
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    halfavg, AVERAGE(vector_filtered) / 2,
    vector_filtered - halfavg
  )
)
```

## _Optional argument_ (3) {auto-animate="true"}

$$
\mathbf{y}, n \mapsto g(\mathbf{y}, n)
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{n}
$$

```{.scala code-line-numbers="3,5,7"}
=LAMBDA(
  vector,
  ...,
  LET(
    ...,...,
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    halfavg, AVERAGE(vector_filtered) / 2,
    vector_filtered - halfavg
  )
)
```

## _Optional argument_ (4) {auto-animate="true"}

$$
\mathbf{y}, n \mapsto g(\mathbf{y}, n)
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{n}
$$

```{.scala code-line-numbers="3,5,7"}
=LAMBDA(
  vector,
  [n],
  LET(
    ...,...,
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    halfavg, AVERAGE(vector_filtered) / n,
    vector_filtered - halfavg
  )
)
```

## _Optional argument_ (5) {.smaller auto-animate="true"}

$$
\mathbf{y}, n \mapsto g(\mathbf{y}, n)
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{n}
$$

```{.scala code-line-numbers="3,5,7"}
=LAMBDA(
  vector,
  [n],
  LET(
    n, IF(ISOMITTED(n), 2, n),
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    halfavg, AVERAGE(vector_filtered) / n,
    vector_filtered - halfavg
  )
)
```

$$
\begin{equation}
  n \mapsto \texttt{ISOMITTED}(n) =
  \begin{cases}
    \texttt{TRUE} & n \leftarrow 2 \\
    \texttt{FALSE} & n \leftarrow n
  \end{cases}
\end{equation}
$$

## Formula Akhir {.smaller auto-animate="true"}

$$
\mathbf{y}, n \mapsto g(\mathbf{y}, n)
=
\mathbf{y}_{\textit{filtered}} - \frac{\texttt{AVERAGE}(\mathbf{y}_{\textit{filtered}})}{n}
$$

```{.scala code-line-numbers="true"}
=LAMBDA(
  vector,
  [n],
  LET(
    n, IF(ISOMITTED(n), 2, n),
    vector_filtered, FILTER(vector, ISNUMBER(vector)),
    halfavg, AVERAGE(vector_filtered) / n,
    vector_filtered - halfavg
  )
)
```

- Formula tersebut disimpan sebagai `HALFAVGN` di _Formulas Name Manager_.
- Sintaksnya `=HALFAVGN(vector, [n])`.
- `=HALFAVGN(D5:D10)` (maka $n=2$).
- `=HALFAVGN(D5#, 4)` (maka $n=4$).

# feidlambda III
Pengenalan mengembangkan `LAMBDA` dan fungsi yang berkaitan dengan `LAMBDA`

## Pengenalan _Advanced Formula Environment_ (AFE)

- Excel add-ins yang memudahkan mengatur kumpulan formula pada lembar kerja. 
- Alternatif _Formulas Name Manager_.
- Memiliki fitur _syntax highlighting_ dan _shortcut_ umum untuk _coding_.
- Dapat _import_ UDL hasil dari orang lain menggunakan GitHub Gist.

## Demonstrasi menggunakan AFE (1)

![](assets/feidlambda-2-afe-1.gif)

## Demonstrasi menggunakan AFE (1)

![](assets/feidlambda-2-afe-2.gif)

## Daftar fungsi yang dibahas di feidlambda III {.smaller}

::: {.nonincremental}
- Fungsi vektorisasi `SCAN`, `MAP`, `REDUCE`. 
- Transformasi kolom dengan `TOCOL`, `TOROW`, `WRAPCOLS`, `WRAPROWS`.
- Menggabungkan _array_ dengan `VSTACK` dan `HSTACK`
- Manipulasi _array_ dengan `DROP`, `EXPAND`.
- Memilih kolom/baris dengan `CHOOSECOLS` dan `CHOOSEROWS`, `TAKE`
- Fungsi teks `TEXTAFTER`, `TEXTBEFORE`, `TEXTSPLIT`, `VALUETOTEXT`, `ARRAYTOTEXT`. 
- Iterasi dengan `BYCOL` dan `BYROW`,
:::

# Terima Kasih

Taruma Sakti Megariansyah, [hi@taruma.info](mailto:hi@taruma.info)

# [Lanjut ke Latihan >](/greenhorn/feidlambda-2/index.html)
