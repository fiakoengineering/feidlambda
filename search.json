[
  {
    "objectID": "release/feidlambda-0-2-0.html",
    "href": "release/feidlambda-0-2-0.html",
    "title": "feidlambda 0.2.0",
    "section": "",
    "text": "Official GIST feid_utils (v0.2.0)\n\n\n\nhttps://gist.github.com/taruma/60610672a9bd94724cba46f68b5614fa Pre-release Page (GitHub)\nBerikut daftar fungsi yang tersedia di koleksi feidlambda versi 0.2.0:"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#comparevector",
    "href": "release/feidlambda-0-2-0.html#comparevector",
    "title": "feidlambda 0.2.0",
    "section": "6 COMPAREVECTOR",
    "text": "6 COMPAREVECTOR\n\n\n\n\n\n\n\nfeid_utils.COMPAREVECTOR\n\nMemeriksa apakah setiap elemen di left_vector memiliki nilai yang sama di isian right_vector.\n\nreturn\n\nLOGICAL VECTOR\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.COMPAREVECTOR(left_vector, right_vector)\n\n\n\n\n\nfeid_utils.COMPAREVECTOR"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#multicheck",
    "href": "release/feidlambda-0-2-0.html#multicheck",
    "title": "feidlambda 0.2.0",
    "section": "7 MULTICHECK",
    "text": "7 MULTICHECK\n\n\n\n\n\n\n\nfeid_utils.MULTICHECK\n\nMemeriksa apakah setiap kolom pada array memiliki nilai isian search_vector. Dan diproses setiap barisnya menggunakan check_condition yang dapat diisi dengan \"AND\" atau \"OR\".\n\nreturn\n\nBOOLEAN VECTOR\n\n\n\n\n\n\n\n\n\n\n\n\nPeringatan\n\n\n\ncheck_condition diisi \"OR\" atau \"AND\", jika tidak diisi dianggap \"AND\".\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.MULTICHECK(array, search_vector, [check_condition])\n\n\n\n\n\nfeid_utils.MULTICHECK"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#droprows",
    "href": "release/feidlambda-0-2-0.html#droprows",
    "title": "feidlambda 0.2.0",
    "section": "8 DROPROWS",
    "text": "8 DROPROWS\n\n\n\n\n\n\n\nfeid_utils.DROPROWS\n\nMenghapus baris berdasarkan index_to_drop dari array.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.DROPROWS(array, index_to_drop)\n\n\n\n\n\nfeid_utils.DROPROWS"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#dropcols",
    "href": "release/feidlambda-0-2-0.html#dropcols",
    "title": "feidlambda 0.2.0",
    "section": "9 DROPCOLS",
    "text": "9 DROPCOLS\n\n\n\n\n\n\n\nfeid_utils.DROPCOLS\n\nMenghapus kolom berdasarkan index_to_drop dari array.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.DROPCOLS(array, index_to_drop)\n\n\n\n\n\nfeid_utils.DROPCOLS"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#countmulticheck",
    "href": "release/feidlambda-0-2-0.html#countmulticheck",
    "title": "feidlambda 0.2.0",
    "section": "10 COUNTMULTICHECK",
    "text": "10 COUNTMULTICHECK\n\n\n\n\n\n\n\nfeid_utils.COUNTMULTICHECK\n\nMenghitung jumlah TRUE dari MULTICHECK.\n\nreturn\n\nINTEGER\n\n\n\n\n\n\n\n\n\n\n\n\nPeringatan\n\n\n\ncheck_condition diisi \"OR\" atau \"AND\", jika tidak diisi dianggap \"AND\".\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.COUNTMULTICHECK(array, search_vector, [check_condition])\n\n\n\n\n\nfeid_utils.COUNTMULTICHECK"
  },
  {
    "objectID": "release/feidlambda-0-3-0.html",
    "href": "release/feidlambda-0-3-0.html",
    "title": "feidlambda v0.3",
    "section": "",
    "text": "Official GIST feidlambda (v0.3)\n\n\n\nOfficial GIST feidlambda (feid)\n\n\nBagi yang sebelumnya menggunakan versi feidlambda v0.2 wajib untuk membaca perubahan penting dan migrasi v0.2 ke v0.3. Tapi, bagi yang baru menggunakan bisa langsung ke bagian fungsi feidlambda v0.3.\n\n\n\n\nFungsi feidlambda v0.3\nPada feidlambda v0.3, setiap fungsi dikategorikan sesuai kegunaannya. Berikut kategori yang tersedia di feidlambda v0.3:\n\nFILTER_*: Melakukan filtering atau subsetting (memilah) dari data.\nGET_*: Mengambil informasi dari data.\nIS_*: Fungsi logical tambahan.\nMAKE_*: Membangkitkan data.\nREPEAT_*: Mengulangi/merepetisi data.\nRESHAPE_*: Mengubah dimensi data.\nROTATE_*: Merubah posisi data dengan diputar.\nSWAP_*: Menukar posisi data.\nTEXT_*: Fungsi tambahan yang berkaitan dengan teks.\n\nDownload excel demonstrasi RELEASE_feidlambda_v0_3.xlsx, untuk memudahkan mengeksplorasi fungsi baru di feidlambda v0.3.\n\n\n\n\n\nKategori FILTER_*\nKategori FILTER_* merupakan kumpulan fungsi yang melakukan filtering atau subsetting (memilah) dari data berupa vektor ataupun array. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 2.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> FILTER_DROP_ROWS\n  NONE --> FILTER_DROP_COLUMNS\n  NONE --> FILTER_FUNC_COLUMN\n  FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\n  FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n  _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n  _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\n\n\n\n\n\nGambar 2.1: Grafik dependencies kategori FILTER_*\n\n\n\n\nFungsi utama kategori FILTER_* yaitu FILTER_DROP_ROWS(), FILTER_DROP_COLUMNS(), dan FILTER_MINMAX_ARRAY().\n\n\nSource Code FILTER_*\n\n// NONE --> FILTER_DROP_ROWS\nFILTER_DROP_ROWS = LAMBDA(array, row_index,\n    LET(\n        row_index, TOCOL(row_index),\n        row_index_clean, FILTER(row_index, NOT(ISBLANK(row_index))),\n        nrows, ROWS(array),\n        row_sequence, SEQUENCE(nrows),\n        selected_row, BYROW(row_sequence, LAMBDA(each_row, OR(each_row = row_index_clean))),\n        FILTER(array, NOT(selected_row))\n    )\n);\n\n// NONE --> FILTER_DROP_COLUMNS\nFILTER_DROP_COLUMNS = LAMBDA(array, column_index,\n    LET(\n        column_index, TOROW(column_index),\n        column_index_clean, FILTER(column_index, NOT(ISBLANK(column_index))),\n        ncols, COLUMNS(array),\n        col_sequence, SEQUENCE(1, ncols),\n        selected_col, BYCOL(col_sequence, LAMBDA(each_col, OR(each_col = column_index_clean))),\n        FILTER(array, NOT(selected_col))\n    )\n);\n\n// NONE --> FILTER_FUNC_COLUMN\nFILTER_FUNC_COLUMN = LAMBDA(array, [col], [label_col], [with_label], [function], [label_function],\n    LET(\n        col, IF(ISOMITTED(col), 1, col),\n        label_col, IF(ISOMITTED(label_col), col, label_col),\n        with_label, IF(ISOMITTED(with_label), FALSE, with_label),\n        function, IF(ISOMITTED(function), LAMBDA(x, MAX(x)), function),\n        label_function, IF(ISOMITTED(label_function), \"func\", label_function),\n        selected_vector, CHOOSECOLS(array, col),\n        func_value, function(selected_vector),\n        selected_logical, selected_vector = func_value,\n        array_max, FILTER(array, selected_logical),\n        label, MAKEARRAY(ROWS(array_max), 1, LAMBDA(x, y, CONCAT(label_col, \"_\", label_function))),\n        IF(with_label, HSTACK(label, array_max), array_max)\n    )\n);\n\n// FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\nFILTER_MINMAX_COLUMN = LAMBDA(array, [col], [label_col], [with_label],\n    LET(\n        func_1, LAMBDA(x, MIN(x)),\n        label_func_1, \"min\",\n        func_2, LAMBDA(x, MAX(x)),\n        label_func_2, \"max\",\n        func1_result, FILTER_FUNC_COLUMN(array, col, label_col, with_label, func_1, label_func_1),\n        func2_result, FILTER_FUNC_COLUMN(array, col, label_col, with_label, func_2, label_func_2),\n        VSTACK(func1_result, func2_result)\n    )\n);\n\n// FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n// _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n_RECURSIVE_FILTER_MINMAX = LAMBDA(array, ntry, [ignore_first_column], [label_vector], [with_label],\n    LET(\n        ignore_first_column, IF(ISOMITTED(ignore_first_column), FALSE, ignore_first_column),\n        stop_col, IF(ignore_first_column, 2, 1),\n        label_vector, IF(ISOMITTED(label_vector), SEQUENCE(1, COLUMNS(array)), label_vector),\n        new_label, IF(stop_col = 2, HSTACK({\" \"}, label_vector), label_vector),\n        label_col, CHOOSECOLS(new_label, ntry),\n        IF(\n            ntry = stop_col,\n            FILTER_MINMAX_COLUMN(array, ntry, label_col, with_label),\n            LET(\n                results, FILTER_MINMAX_COLUMN(array, ntry, label_col, with_label),\n                next_try, ntry - 1,\n                VSTACK(\n                    _RECURSIVE_FILTER_MINMAX(\n                        array,\n                        next_try,\n                        ignore_first_column,\n                        label_vector,\n                        with_label\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\nFILTER_MINMAX_ARRAY = LAMBDA(array, [ignore_first_column], [with_labels], [label_vector],\n    _RECURSIVE_FILTER_MINMAX(array, COLUMNS(array), ignore_first_column, label_vector, with_labels)\n);\n\n\nFILTER_DROP_ROWS()\nFungsi FILTER_DROP_ROWS(array, row_index) digunakan untuk menghapus baris dari data.\n\n\n\nSyntax\n\nFILTER_DROP_ROWS(array, row_index)\n\nOutput\n\narray\n\n\n\n\n\narray := [array | vector]\n\nData berupa array atau vector yang memiliki baris lebih dari satu.\n\nrow_index := [integer number | integer vector]\n\nIndeks baris yang ingin dihapus.\n\n\n\n\n\n\n\nGambar 2.2: Demonstrasi FILTER_DROP_ROWS()\n\n\n\n\n\nFILTER_DROP_COLUMNS()\nFungsi FILTER_DROP_COLUMNS(array, column_index) digunakan untuk menghapus kolom dari data.\n\n\n\nSyntax\n\nFILTER_DROP_COLUMNS(array, column_index)\n\nOutput\n\narray\n\n\n\n\n\narray := [array | vector]\n\nData berupa array atau vector yang memiliki kolom lebih dari satu.\n\ncolumn_index := [integer number | integer vector]\n\nIndeks kolom yang ingin dihapus.\n\n\n\n\n\n\n\nGambar 2.3: Demonstrasi FILTER_DROP_COLUMNS()\n\n\n\n\n\nFILTER_MINMAX_ARRAY()\nFungsi FILTER_MINMAX_ARRAY(array, [ignore_first_column], [with_labels], [label_vector]) digunakan untuk melakukan filtering (memilah) data berdasarkan nilai minimum dan maksimum setiap kolomnya dan mengeluarkan hasil dalam berupa dynamic array.\n\n\n\nSyntax\n\nFILTER_MINMAX_ARRAY(array, [ignore_first_column], [with_labels], [label_vector])\n\nOutput\n\narray\n\n\n\n\n\narray := [array | numeric array]\n\nData berupa array dengan ketentuan array berisikan angka kecuali kolom pertama jika menggunakan opsi ignore_first_column.\n\n[ignore_first_column] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka kolom pertama dari array akan diabaikan dan tidak dilakukan filtering nilai minimum/maksimum.\n\n[with_labels] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka kolom pertama dari output adalah label informasi minimum dan maksimum seperti 1_min, 1_max, atau no.column_min dan no.column_max. Untuk menggunakan label sendiri, masukin vector label di argumen label_vector.\n\n[label_vector] := NONE :: [vector]\n\nNilai default yaitu NONE. Jika NONE, maka label setiap baris akan dinomori berdasarkan kolomnya (1_min, 1_max). Jika ingin menggunakan label dari nama kolom, jumlah elemen vector harus sama dengan jumlah kolom dari array. Untuk menggunakan label nilai with_label harus TRUE.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGambar 2.4: Demonstrasi FILTER_MINMAX_ARRAY()\n\n\n\n\n\n\n\n\nKategori GET_*\nKategori GET_* merupakan kumpulan fungsi yang digunakan untuk mengambil informasi dari suatu data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 3.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> GET_INDEX_2D\n\n\n\n\n\nGambar 3.1: Grafik dependencies kategori GET_*\n\n\n\n\nDari Gambar 3.1, diketahui untuk versi v0.3 hanya tersedia fungsi GET_INDEX_2D().\n\n\nSource Code GET_*\n\n// NONE --> GET_INDEX_2D\nGET_INDEX_2D = LAMBDA(lookup_value, array, [return_order_only],\n    LET(\n        return_order_only, IF(ISOMITTED(return_order_only), FALSE, return_order_only),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        size, nrows * ncols,\n        array_flatten, TOCOL(array, , TRUE),\n        index_sequence, SEQUENCE(nrows, ncols, 1, 1),\n        rows_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, x)),\n        columns_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, y)),\n        rows_flatten, TOCOL(rows_sequence, , TRUE),\n        columns_flatten, TOCOL(columns_sequence, , TRUE),\n        index_flatten, TOCOL(index_sequence, , TRUE),\n        lookup_table, HSTACK(index_flatten, rows_flatten, columns_flatten),\n        lookup_result, FILTER(lookup_table, array_flatten = lookup_value),\n        IF(return_order_only, CHOOSECOLS(lookup_result, 1), lookup_result)\n    )\n);\n\n\nGET_INDEX_2D()\nFungsi GET_INDEX_2D(lookup_value, array, [return_order_only]) dapat digunakan untuk mengambil informasi urutan nilai yang dicari ataupun posisi baris/kolom dari array.\n\n\n\nSyntax\n\nGET_INDEX_2D(lookup_value, array, [return_order_only])\n\nOutput\n\narray ([order, row index, column index]) atau number (order)\n\n\n\n\n\nlookup_value := [scalar]\n\nNilai yang dicari dalam array. Nilai lookup_value adalah nilai tunggal berupa scalar.\n\narray := [array]\n\nData berupa array.\n\n[return_order_only] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, hasil fungsi memberikan urutan angka nilai yang dicari. Urutan dimulai dari horizontal kiri teratas sampai kanan terbawah. Jika FALSE, maka output terdiri dari nomor urut, indeks kolom, dan indeks baris.\n\n\n\n\n\n\n\nGambar 3.2: Demonstrasi GET_INDEX_2D()\n\n\n\n\n\n\n\n\n\nKategori IS_*\nKategori IS_* merupakan kumpulan fungsi yang dapat digunakan untuk melakukan fungsi logical di data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 4.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> IS_ALL_IN_LOOKUP_VECTOR\n  NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\n  IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\n  NONE --> IS_ROWS_LOGICAL\n  NONE --> IS_COLUMNS_LOGICAL\n\n\n\n\n\nGambar 4.1: Grafik dependencies kategori IS_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code IS_*\n\n// NONE --> IS_ALL_IN_LOOKUP_VECTOR\nIS_ALL_IN_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOCOL(lookup_vector),\n        MAP(array, LAMBDA(element, OR(BYROW(lookup_vector, LAMBDA(lookup, element = lookup)))))\n    )\n);\n\n// NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\nIS_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOROW(lookup_vector),\n        ncols_vector, COLUMNS(lookup_vector),\n        ncols_array, COLUMNS(array),\n        nrows_array, ROWS(array),\n        IF(\n            ncols_array = ncols_vector,\n            LET(\n                repeat_array, CHOOSEROWS(lookup_vector, SEQUENCE(nrows_array, , 1, 0)),\n                MAP(array, repeat_array, LAMBDA(x, y, x = y))\n            ),\n            \"N/A\"\n        )\n    )\n);\n\n// IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\nIS_ALL_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array, [logical_function],\n    LET(\n        logical_function, IF(ISOMITTED(logical_function), LAMBDA(x, OR(x)), logical_function),\n        array_boolean, IS_COLS_EQUAL_VECTOR(lookup_vector, array),\n        BYROW(array_boolean, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_ROWS_LOGICAL\nIS_ROWS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(ISOMITTED(logical_function), LAMBDA(x, OR(x)), logical_function),\n        BYROW(logical_array, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_COLUMNS_LOGICAL\nIS_COLUMNS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(ISOMITTED(logical_function), LAMBDA(x, OR(x)), logical_function),\n        BYCOL(logical_array, LAMBDA(each_col, logical_function(each_col)))\n    )\n);\n\n\nIS_ALL_IN_VECTOR()\nFungsi IS_ALL_IN_VECTOR(lookup_vector, array) digunakan untuk memeriksa apakah setiap elemen di array termasuk dari lookup_vector.\n\n\n\nSyntax\n\nIS_ALL_IN_VECTOR(lookup_vector, array)\n\nOutput\n\nlogical array\n\n\n\n\n\nlookup_vector := [scalar | vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan.\n\narray := [array | vector]\n\nData berupa array atau vector.\n\n\n\n\n\n\n\nGambar 4.2: Demonstrasi IS_ALL_IN_VECTOR()\n\n\n\n\n\nIS_COLS_EQUAL_VECTOR()\nFungsi IS_COLS_EQUAL_VECTOR(lookup_vector, array) digunakan untuk memeriksa apakah setiap kolom di array termasuk dari setiap elemen di lookup_vector.\n\n\n\nSyntax\n\nIS_COLS_EQUAL_VECTOR(lookup_vector, array)\n\nOutput\n\nlogical array\n\n\n\n\n\nlookup_vector := [vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan. Jumlah elemen lookup_vector harus sama dengan jumlah kolom array.\n\narray := [array | vector]\n\nData berupa array .\n\n\n\n\n\n\n\nGambar 4.3: Demonstrasi IS_COLS_EQUAL_VECTOR()\n\n\n\n\n\nIS_ALL_COLS_EQUAL_VECTOR()\nFungsi IS_ALL_COLS_EQUAL_VECTOR(lookup_vector, array, [logical_function]) digunakan untuk memeriksa apakah setiap kolom di array termasuk dari setiap elemen di lookup_vector, dan diperiksa apakah setiap barisnya sesuai dengan logical_function. Fungsi ini menggunakan fungsi IS_COLS_EQUAL_VECTOR().\n\n\n\nSyntax\n\nIS_ALL_COLS_EQUAL_VECTOR(lookup_vector, array, [logical_function])\n\nOutput\n\ncolumn logical vector\n\n\n\n\n\nlookup_vector := [scalar | vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan. Jumlah elemen lookup_vector harus sama dengan jumlah kolom array.\n\narray := [array | vector]\n\nData berupa array .\n\nlogical_function := OR() :: [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap barisnya.\n\n\n\n\n\n\n\nGambar 4.4: Demonstrasi IS_ALL_COLS_EQUAL_VECTOR()\n\n\n\n\n\nIS_ROWS_LOGICAL()\nFungsi IS_ROWS_LOGICAL(logical_array, [logical_function]) mengaggregasi setiap baris dari logical_array menggunakan fungsi logical_function.\n\n\n\nSyntax\n\nIS_ROWS_LOGICAL(logical_array, [logical_function])\n\nOutput\n\ncolumn vector\n\n\n\n\n\nlogical_array := [logical array]\n\nData berupa logical array .\n\n[logical_function] := OR() [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap barisnya.\n\n\n\n\n\nIS_COLUMNS_LOGICAL()\nFungsi IS_COLUMNS_LOGICAL(logical_array, [logical_function]) mengaggregasi setiap kolom dari logical_array menggunakan fungsi logical_function.\n\n\n\nSyntax\n\nIS_COLUMNS_LOGICAL(logical_array, [logical_function])\n\nOutput\n\nrow vector\n\n\n\n\n\nlogical_array := [logical array]\n\nData berupa logical array .\n\n[logical_function] := OR() [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap kolomnya.\n\n\n\n\n\n\n\nGambar 4.5: Demonstrasi IS_ROWS_LOGICAL() dan IS_COLUMNS_LOGICAL()\n\n\n\n\n\n\n\n\n\nKategori MAKE_*\nKategori MAKE_* merupakan kumpulan fungsi yang membangkitkan (generate) data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 5.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n  _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\n\n\n\n\n\nGambar 5.1: Grafik dependencies kategori MAKE_*\n\n\n\n\nFungsi utama pada kategori ini adalah MAKE_SEQUENCE_FROM_VECTOR().\n\n\nSource Code MAKE_*\n\n// _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n_RECURSIVE_MAKE_SEQUENCE = LAMBDA(start_vector, end_vector, ntry, [stack_horizontally],\n    LET(\n        seq_start, INDEX(start_vector, ntry),\n        seq_end, INDEX(end_vector, ntry),\n        stack_horizontally, IF(ISOMITTED(stack_horizontally), FALSE, stack_horizontally),\n        IF(\n            ntry = 1,\n            SEQUENCE(seq_end - seq_start + 1, , seq_start),\n            LET(\n                next_try, ntry - 1,\n                results, SEQUENCE(seq_end - seq_start + 1, , seq_start),\n                IF(\n                    stack_horizontally,\n                    HSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    ),\n                    VSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    )\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\nMAKE_SEQUENCE_FROM_VECTOR = LAMBDA(start_vector, end_vector, [stack_horizontally],\n    _RECURSIVE_MAKE_SEQUENCE(start_vector, end_vector, ROWS(start_vector), stack_horizontally)\n);\n\n\nMAKE_SEQUENCE_FROM_VECTOR()\nFungsi MAKE_SEQUENCE_FROM_VECTOR(start_vector, end_vector, [stack_horizontally]) digunakan untuk mebangkitkan sequence dari setiap baris/elemen di start_vector dan end_vector.\n\n\n\nSyntax\n\nMAKE_SEQUENCE_FROM_VECTOR(start_vector, end_vector, [stack_horizontally])\n\nOutput\n\ncolumn vector atau array\n\n\n\n\n\nstart_vector := [integer vector]\n\nVector yang terdiri dari bilangan bulat memulai sequence.\n\nend_vector := [integer vector]\n\nVector yang terdiri dari bilangan bulat akhir sequence.\n\n[stack_horizontally] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka setiap sequence yang dibangkitkan akan disusun horizontal.\n\n\n\n\n\n\n\nGambar 5.2: Demonstrasi MAKE_SEQUENCE_FROM_VECTOR()\n\n\n\n\n\n\n\n\n\nKategori REPEAT_*\nKategori REPEAT_* merupakan kumpulan fungsi yang digunakan untuk melakukan pengulangan array ataupun vector dan menghasilkannya dalam bentuk dynamic array. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 6.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\n  REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\n  REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\n\n\n\n\n\nGambar 6.1: Grafik dependencies kategori REPEAT_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code REPEAT_*\n\n// REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\nREPEAT_ARRAY = LAMBDA(array, [num_repeat], [by_row],\n    LET(\n        by_row, IF(ISOMITTED(by_row), TRUE, by_row),\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            by_row,\n            REPEAT_ARRAY_BY_ROW(array, num_repeat),\n            REPEAT_ARRAY_BY_COLUMN(array, num_repeat)\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\nREPEAT_ARRAY_BY_ROW = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(next_repeat, num_repeat - 1, VSTACK(REPEAT_ARRAY_BY_ROW(array, next_repeat), array))\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\nREPEAT_ARRAY_BY_COLUMN = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                HSTACK(REPEAT_ARRAY_BY_COLUMN(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n\nREPEAT_ARRAY_BY_ROW()\nFungsi REPEAT_ARRAY_BY_ROW(array, [num_repeat]) digunakan untuk mengulangi array sepanjang baris (ke bawah).\n\n\n\nSyntax\n\nREPEAT_ARRAY_BY_ROW(array, [num_repeat])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n\n\n\n\n\n\nGambar 6.2: Demonstrasi REPEAT_ARRAY_BY_ROW()\n\n\n\n\n\nREPEAT_ARRAY_BY_COLUMN()\nFungsi REPEAT_ARRAY_BY_COLUMN(array, [num_repeat]) digunakan untuk mengulangi array sepanjang kolom (ke kanan).\n\n\n\nSyntax\n\nREPEAT_ARRAY_BY_COLUMN(array, [num_repeat])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n\n\n\n\n\n\nGambar 6.3: Demonstrasi REPEAT_ARRAY_BY_COLUMN()\n\n\n\n\n\nREPEAT_ARRAY()\nFungsi REPEAT_ARRAY(array, [num_repeat], [by_row]) digunakan untuk mengulangi array sepanjang baris/kolom (ke bawah/ke kanan).\n\n\n\nSyntax\n\nREPEAT_ARRAY(array, [num_repeat], [by_row])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n[by_row] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka pengulangan akan sepanjang baris (ke bawah), dan berlaku sebaliknya juga.\n\n\n\n\n\n\n\nGambar 6.4: Demonstrasi REPEAT_ARRAY()\n\n\n\n\n\n\n\n\n\nKategori RESHAPE_*\nKategori RESHAPE_* merupakan kumpulan fungsi yang dapat digunakan untuk melakukan fungsi logical di data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 7.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> RESHAPE_BY_COLUMNS\n\n\n\n\n\nGambar 7.1: Grafik dependencies kategori RESHAPE_*\n\n\n\n\nFungsi utama yang tersedia saat ini hanya RESHAPE_BY_COLUMNS().\n\n\nSource Code RESHAPE_*\n\n// NONE --> RESHAPE_BY_COLUMNS\nRESHAPE_BY_COLUMNS = LAMBDA(array, [num_split],\n    LET(\n        num_split, IF(ISOMITTED(num_split), 2, num_split),\n        ncols, COLUMNS(array),\n        nrows, ROWS(array),\n        IF(\n            MOD(ncols, num_split) = 0,\n            LET(\n                divider, ncols / num_split,\n                divider_sequence, CHOOSEROWS(SEQUENCE(1, divider), SEQUENCE(num_split, , 1, 0)),\n                divider_flatten, TOCOL(divider_sequence, , TRUE),\n                divider_repeat, CHOOSEROWS(TOROW(divider_flatten), SEQUENCE(nrows, , 1, 0)),\n                divider_repeat_col, TOCOL(divider_repeat),\n                array_flatten, TOCOL(array),\n                array_sorted, SORTBY(array_flatten, divider_repeat_col),\n                WRAPROWS(array_sorted, num_split)\n            ),\n            \"#INVALID_NUM_SPLIT\"\n        )\n    )\n);\n\n\nRESHAPE_BY_COLUMNS()\nFungsi RESHAPE_BY_COLUMNS(array, [num_split]) digunakan untuk mengubah dimensi (transformasi) array berdasarkan jumlah pembagi kolomnya.\n\n\n\nSyntax\n\nRESHAPE_BY_COLUMNS(array, [num_split])\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array atau vector.\n\n[num_split] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pembagi kolom. Jumlah kolom array harus habis dibagi (MOD()) dengan num_split.\n\n\n\n\n\n\n\nGambar 7.2: Demonstrasi RESHAPE_BY_COLUMNS()\n\n\n\n\n\n\n\n\n\nKategori ROTATE_*\nKategori ROTATE_* merupakan kumpulan fungsi yang digunakan untuk menggeser atau memutar array ataupun vector. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 8.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> ROTATE_VECTOR\n  ROTATE_VECTOR --> ROTATE_ARRAY\n\n\n\n\n\nGambar 8.1: Grafik dependencies kategori ROTATE_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code ROTATE_*\n\n// NONE --> ROTATE_VECTOR\nROTATE_VECTOR = LAMBDA(vector, n, [as_column_vector],\n    LET(\n        vector, TOCOL(vector),\n        rotated_array, IFS(\n            OR(n = 0, n >= ROWS(vector), n <= -ROWS(vector)),\n            vector,\n            n > 0,\n            VSTACK(DROP(vector, n), TAKE(vector, n)),\n            n < 0,\n            VSTACK(TAKE(vector, n), DROP(vector, n))\n        ),\n        as_column_vector, IF(ISOMITTED(as_column_vector), FALSE, TRUE),\n        IF(as_column_vector, TOROW(rotated_array), TOCOL(rotated_array))\n    )\n);\n\n// ROTATE_VECTOR --> ROTATE_ARRAY\nROTATE_ARRAY = LAMBDA(array, n, [rotate_columns],\n    LET(\n        rotate_columns, IF(ISOMITTED(rotate_columns), TRUE, FALSE),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        seqrows, SEQUENCE(nrows),\n        seqcols, SEQUENCE(1, ncols),\n        results, IF(\n            rotate_columns,\n            CHOOSECOLS(array, ROTATE_VECTOR(seqcols, n, TRUE)),\n            CHOOSEROWS(array, ROTATE_VECTOR(seqrows, n, FALSE))\n        ),\n        results\n    )\n);\n\n\nROTATE_VECTOR()\nFungsi ROTATE_VECTOR(vector, n, [as_column_vector]) digunakan untuk menggeser/memutar elemen yang ada di vector sebanyak n.\n\n\n\nSyntax\n\nROTATE_VECTOR(vector, n, [as_column_vector])\n\nOutput\n\nvector\n\n\n\n\n\nvector := [vector]\n\nData berupa vector (column vector atau row vector).\n\nn := [integer]\n\nJumlah berapa kali vector diputar/digeser. Nilai negatif untuk digeser berlawanan arah.\n\n[as_column_vector] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka output berupa column vector.\n\n\n\n\n\n\n\nGambar 8.2: Demonstrasi ROTATE_VECTOR()\n\n\n\n\n\nROTATE_ARRAY()\nFungsi ROTATE_ARRAY(array, n, [rotate_columns]) digunakan untuk menggeser/memutar elemen yang ada di array sebanyak n berdasarkan baris atau kolom.\n\n\n\nSyntax\n\nROTATE_ARRAY(array, n, [rotate_columns])\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array.\n\nn := [scalar | vector]\n\nJumlah berapa kali vector diputar/digeser. Nilai negatif untuk digeser berlawanan arah.\n\n[rotate_columns] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka array diputar berdasarkan kolom. Jika FALSE, maka array diputar berdasarkan baris.\n\n\n\n\n\n\n\nGambar 8.3: Demonstrasi ROTATE_ARRAY()\n\n\n\n\n\n\n\n\n\nKategori SWAP_*\nKategori SWAP_* merupakan kumpulan fungsi yang digunakan untuk mengganti atau mengubah posisi elemen atau vector. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 9.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> SWAP_COLUMNS\n  NONE --> SWAP_ROWS\n\n\n\n\n\nGambar 9.1: Grafik dependencies kategori SWAP_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code SWAP_*\n\n// NONE --> SWAP_COLUMNS\nSWAP_COLUMNS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), 2, to_index),\n        column_sequence, SEQUENCE(1, COLUMNS(array)),\n        from_logical, column_sequence = from_index,\n        to_logical, column_sequence = to_index,\n        replace_from, IF(from_logical, to_index, column_sequence),\n        replace_to, IF(to_logical, from_index, replace_from),\n        CHOOSECOLS(array, replace_to)\n    )\n);\n\n// NONE --> SWAP_ROWS\nSWAP_ROWS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), 2, to_index),\n        row_sequence, SEQUENCE(ROWS(array)),\n        from_logical, row_sequence = from_index,\n        to_logical, row_sequence = to_index,\n        replace_from, IF(from_logical, to_index, row_sequence),\n        replace_to, IF(to_logical, from_index, replace_from),\n        CHOOSEROWS(array, replace_to)\n    )\n);\n\n\nSWAP_COLUMNS()\nFungsi SWAP_COLUMNS(array, [from_index], [to_index]) digunakan untuk menukar posisi kolom ke-from_index dengan kolom ke-to_index.\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [row vector | array]\n\nData dapat berupa array atau row vector.\n\n[from_index] := 1 :: [integer]\n\nNilai default yaitu 1. Posisi index kolom yang ingin dipindahkan.\n\n[to_index] := 2 :: [integer]\n\nNilai default yaitu 2. Posisi index tujuan kolom.\n\n\n\n\n\nSWAP_ROWS()\nFungsi SWAP_ROWS(array, [from_index], [to_index]) digunakan untuk menukar posisi baris ke-from_index dengan baris ke-to_index.\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [column vector | array]\n\nData dapat berupa array atau column vector.\n\n[from_index] := 1 :: [integer]\n\nNilai default yaitu 1. Posisi index baris yang ingin dipindahkan.\n\n[to_index] := 2 :: [integer]\n\nNilai default yaitu 2. Posisi index tujuan baris.\n\n\n\n\n\n\n\nGambar 9.2: Demonstrasi SWAP_COLUMNS() dan SWAP_ROWS()\n\n\n\n\n\n\n\n\n\nKategori TEXT_*\nKategori TEXT_* merupakan kumpulan fungsi yang digunakan untuk memproses data teks. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 10.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> TEXT_SPLIT_VECTOR\n\n\n\n\n\nGambar 10.1: Grafik dependencies kategori TEXT_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code TEXT_*\n\n// NONE --> TEXT_SPLIT_VECTOR\nTEXT_SPLIT_VECTOR = LAMBDA(\n    text_vector,\n    [text_delimiter],\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    LET(\n        text_delimiter, IF(ISOMITTED(text_delimiter), \" \", text_delimiter),\n        row_delimiter, IF(ISOMITTED(row_delimiter), \"|<#>|\", row_delimiter),\n        pad_with, IF(ISOMITTED(pad_with), \"\", pad_with),\n        reduce_text, REDUCE(, text_vector, LAMBDA(acc, curr, CONCAT(acc, row_delimiter, curr))),\n        TEXTSPLIT(reduce_text, text_delimiter, row_delimiter, ignore_empty, match_mode, pad_with)\n    )\n);\n\n\nTEXT_SPLIT_VECTOR()\nFungsi TEXT_SPLIT_VECTOR(text_vector, [text_delimiter], [row_delimiter], [ignore_empty], [match_mode], [pad_with]) merupakan fungsi pengembangan lanjutan dari TEXTSPLIT() yang mampu menerima input data berupa vector dan menghasilkan dalam bentuk dynamic array.\n\n\n\nSyntax\n\nTEXT_SPLIT_VECTOR(text_vector, [text_delimiter], [row_delimiter], [ignore_empty], [match_mode], [pad_with])\n\nOutput\n\narray\n\n\n\n\n\ntext_vector := [text vector]\n\nData harus berupa text column vector.\n\n[text_delimiter] := \" \" :: [text]\n\nNilai default yaitu \" \" (spasi). Teks pemisah untuk setiap kolomnya.\n\n[row_delimiter] := \"|<#>|\" :: [text]\n\nNilai default yaitu \"|<#>|\" (spasi). Teks pemisah untuk setiap barisnya. Fungsi TEXT_SPLIT_VECTOR() akan membuat text_vector menjadi tipe teks scalar sebelum diubah menjadi dynamic array. Sehingga, opsi ini sebaiknya disesuaikan dengan teks yang ada di text_vector.\n\n[ignore_empty] := FALSE :: [TRUE | FALSE]\n\nTentukan TRUE untuk mengabaikan pemisah berurutan. Default ke FALSE, yang membuat sel kosong. Opsional.\n\n[match_mode] := 0 :: [0 | 1]\n\nTentukan 1 untuk melakukan kecocokan yang tidak peka huruf besar kecil. Default ke 0, yang melakukan kecocokan peka huruf besar kecil. Opsional.\n\n[pad_with] := #N/A :: [text | number]\n\nNilai untuk mengalihkan hasil. Defaultnya adalah #N/A.\n\n\n\nDeskripsi ignore_empty, match_mode, dan pad_with diambil dari halaman Fungsi TEXTSPLIT.\n\n\n\n\nGambar 10.2: Demonstrasi TEXT_SPLIT_VECTOR\n\n\n\n\n\n\nFungsi feidlambda v0.3 memiliki \\(9\\) kategori dengan total \\(23\\) fungsi utama dan pendukung. Dengan perombakan struktur dan penamaan dari v0.2 ke v0.3, harapannya v0.3 sudah memiliki struktur dan penamaan yang konsisten sehingga untuk memproduksi fungsi ataupun fitur barunya lebih cepat di versi-versi berikutnya.\nJika ada ide untuk pengembangan feidlambda atau fungsi baru bisa langsung membuat isu di github. Dan jika bertemu masalah saat penggunaan feidlambda v0.3, bisa juga membuat isu di github."
  },
  {
    "objectID": "release/feidlambda.html",
    "href": "release/feidlambda.html",
    "title": "Source Code feidlambda",
    "section": "",
    "text": "Official GIST feidlambda (v0.3)\n\n\n\nOfficial GIST feidlambda v0.3\n\n\n/*\nfeidlambda v0.3.0 - LOGIC / UTILITIES FUNCTIONS BY FIAKO ENGINEERING\nGIST feidlambda v0.3.0: https://gist.github.com/taruma/92bd33600a3d42dc9aead87558404a12\nREPOSITORY: https://github.com/fiakoenjiniring/feidlambda\nAUTHOR: @taruma\nTESTED: Microsoft Excel v2211 (Build 16.0.15831.20098)\n*/\n\n/*\n---- FILTER ----\n*/\n\n// NONE --> FILTER_DROP_ROWS\nFILTER_DROP_ROWS = LAMBDA(array, row_index,\n    LET(\n        row_index, TOCOL(row_index),\n        row_index_clean, FILTER(row_index, NOT(ISBLANK(row_index))),\n        nrows, ROWS(array),\n        row_sequence, SEQUENCE(nrows),\n        selected_row, BYROW(row_sequence, LAMBDA(each_row, OR(each_row = row_index_clean))),\n        FILTER(array, NOT(selected_row))\n    )\n);\n\n// NONE --> FILTER_DROP_COLUMNS\nFILTER_DROP_COLUMNS = LAMBDA(array, column_index,\n    LET(\n        column_index, TOROW(column_index),\n        column_index_clean, FILTER(column_index, NOT(ISBLANK(column_index))),\n        ncols, COLUMNS(array),\n        col_sequence, SEQUENCE(1, ncols),\n        selected_col, BYCOL(col_sequence, LAMBDA(each_col, OR(each_col = column_index_clean))),\n        FILTER(array, NOT(selected_col))\n    )\n);\n\n// NONE --> FILTER_FUNC_COLUMN\nFILTER_FUNC_COLUMN = LAMBDA(array, [col], [label_col], [with_label], [function], [label_function],\n    LET(\n        col, IF(ISOMITTED(col), 1, col),\n        label_col, IF(ISOMITTED(label_col), col, label_col),\n        with_label, IF(ISOMITTED(with_label), FALSE, with_label),\n        function, IF(ISOMITTED(function), LAMBDA(x, MAX(x)), function),\n        label_function, IF(ISOMITTED(label_function), \"func\", label_function),\n        selected_vector, CHOOSECOLS(array, col),\n        func_value, function(selected_vector),\n        selected_logical, selected_vector = func_value,\n        array_max, FILTER(array, selected_logical),\n        label, MAKEARRAY(ROWS(array_max), 1, LAMBDA(x, y, CONCAT(label_col, \"_\", label_function))),\n        IF(with_label, HSTACK(label, array_max), array_max)\n    )\n);\n\n// FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\nFILTER_MINMAX_COLUMN = LAMBDA(array, [col], [label_col], [with_label],\n    LET(\n        func_1, LAMBDA(x, MIN(x)),\n        label_func_1, \"min\",\n        func_2, LAMBDA(x, MAX(x)),\n        label_func_2, \"max\",\n        func1_result, FILTER_FUNC_COLUMN(array, col, label_col, with_label, func_1, label_func_1),\n        func2_result, FILTER_FUNC_COLUMN(array, col, label_col, with_label, func_2, label_func_2),\n        VSTACK(func1_result, func2_result)\n    )\n);\n\n// FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n// _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n_RECURSIVE_FILTER_MINMAX = LAMBDA(array, ntry, [ignore_first_column], [label_vector], [with_label],\n    LET(\n        ignore_first_column, IF(ISOMITTED(ignore_first_column), FALSE, ignore_first_column),\n        stop_col, IF(ignore_first_column, 2, 1),\n        label_vector, IF(ISOMITTED(label_vector), SEQUENCE(1, COLUMNS(array)), label_vector),\n        new_label, IF(stop_col = 2, HSTACK({\" \"}, label_vector), label_vector),\n        label_col, CHOOSECOLS(new_label, ntry),\n        IF(\n            ntry = stop_col,\n            FILTER_MINMAX_COLUMN(array, ntry, label_col, with_label),\n            LET(\n                results, FILTER_MINMAX_COLUMN(array, ntry, label_col, with_label),\n                next_try, ntry - 1,\n                VSTACK(\n                    _RECURSIVE_FILTER_MINMAX(\n                        array,\n                        next_try,\n                        ignore_first_column,\n                        label_vector,\n                        with_label\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\nFILTER_MINMAX_ARRAY = LAMBDA(array, [ignore_first_column], [with_labels], [label_vector],\n    _RECURSIVE_FILTER_MINMAX(array, COLUMNS(array), ignore_first_column, label_vector, with_labels)\n);\n\n/*\n---- GET ----\n*/\n\n// NONE --> GET_INDEX_2D\nGET_INDEX_2D = LAMBDA(lookup_value, array, [return_order_only],\n    LET(\n        return_order_only, IF(ISOMITTED(return_order_only), FALSE, return_order_only),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        size, nrows * ncols,\n        array_flatten, TOCOL(array, , TRUE),\n        index_sequence, SEQUENCE(nrows, ncols, 1, 1),\n        rows_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, x)),\n        columns_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, y)),\n        rows_flatten, TOCOL(rows_sequence, , TRUE),\n        columns_flatten, TOCOL(columns_sequence, , TRUE),\n        index_flatten, TOCOL(index_sequence, , TRUE),\n        lookup_table, HSTACK(index_flatten, rows_flatten, columns_flatten),\n        lookup_result, FILTER(lookup_table, array_flatten = lookup_value),\n        IF(return_order_only, CHOOSECOLS(lookup_result, 1), lookup_result)\n    )\n);\n\n/*\n---- IS ----\n*/\n\n// NONE --> IS_ALL_IN_LOOKUP_VECTOR\nIS_ALL_IN_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOCOL(lookup_vector),\n        MAP(array, LAMBDA(element, OR(BYROW(lookup_vector, LAMBDA(lookup, element = lookup)))))\n    )\n);\n\n// NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\nIS_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOROW(lookup_vector),\n        ncols_vector, COLUMNS(lookup_vector),\n        ncols_array, COLUMNS(array),\n        nrows_array, ROWS(array),\n        IF(\n            ncols_array = ncols_vector,\n            LET(\n                repeat_array, CHOOSEROWS(lookup_vector, SEQUENCE(nrows_array, , 1, 0)),\n                MAP(array, repeat_array, LAMBDA(x, y, x = y))\n            ),\n            \"N/A\"\n        )\n    )\n);\n\n// IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\nIS_ALL_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array, [logical_function],\n    LET(\n        logical_function, IF(ISOMITTED(logical_function), LAMBDA(x, OR(x)), logical_function),\n        array_boolean, IS_COLS_EQUAL_VECTOR(lookup_vector, array),\n        BYROW(array_boolean, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_ROWS_LOGICAL\nIS_ROWS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(ISOMITTED(logical_function), LAMBDA(x, OR(x)), logical_function),\n        BYROW(logical_array, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_COLUMNS_LOGICAL\nIS_COLUMNS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(ISOMITTED(logical_function), LAMBDA(x, OR(x)), logical_function),\n        BYCOL(logical_array, LAMBDA(each_col, logical_function(each_col)))\n    )\n);\n\n/*\n---- MAKE ----\n*/\n\n// _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n_RECURSIVE_MAKE_SEQUENCE = LAMBDA(start_vector, end_vector, ntry, [stack_horizontally],\n    LET(\n        seq_start, INDEX(start_vector, ntry),\n        seq_end, INDEX(end_vector, ntry),\n        stack_horizontally, IF(ISOMITTED(stack_horizontally), FALSE, stack_horizontally),\n        IF(\n            ntry = 1,\n            SEQUENCE(seq_end - seq_start + 1, , seq_start),\n            LET(\n                next_try, ntry - 1,\n                results, SEQUENCE(seq_end - seq_start + 1, , seq_start),\n                IF(\n                    stack_horizontally,\n                    HSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    ),\n                    VSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    )\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\nMAKE_SEQUENCE_FROM_VECTOR = LAMBDA(start_vector, end_vector, [stack_horizontally],\n    _RECURSIVE_MAKE_SEQUENCE(start_vector, end_vector, ROWS(start_vector), stack_horizontally)\n);\n\n/*\n---- REPEAT ----\n*/\n\n// REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\nREPEAT_ARRAY = LAMBDA(array, [num_repeat], [by_row],\n    LET(\n        by_row, IF(ISOMITTED(by_row), TRUE, by_row),\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            by_row,\n            REPEAT_ARRAY_BY_ROW(array, num_repeat),\n            REPEAT_ARRAY_BY_COLUMN(array, num_repeat)\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\nREPEAT_ARRAY_BY_ROW = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(next_repeat, num_repeat - 1, VSTACK(REPEAT_ARRAY_BY_ROW(array, next_repeat), array))\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\nREPEAT_ARRAY_BY_COLUMN = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                HSTACK(REPEAT_ARRAY_BY_COLUMN(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n/*\n---- RESHAPE ----\n*/\n\n// NONE --> RESHAPE_BY_COLUMNS\nRESHAPE_BY_COLUMNS = LAMBDA(array, [num_split],\n    LET(\n        num_split, IF(ISOMITTED(num_split), 2, num_split),\n        ncols, COLUMNS(array),\n        nrows, ROWS(array),\n        IF(\n            MOD(ncols, num_split) = 0,\n            LET(\n                divider, ncols / num_split,\n                divider_sequence, CHOOSEROWS(SEQUENCE(1, divider), SEQUENCE(num_split, , 1, 0)),\n                divider_flatten, TOCOL(divider_sequence, , TRUE),\n                divider_repeat, CHOOSEROWS(TOROW(divider_flatten), SEQUENCE(nrows, , 1, 0)),\n                divider_repeat_col, TOCOL(divider_repeat),\n                array_flatten, TOCOL(array),\n                array_sorted, SORTBY(array_flatten, divider_repeat_col),\n                WRAPROWS(array_sorted, num_split)\n            ),\n            \"#INVALID_NUM_SPLIT\"\n        )\n    )\n);\n\n/*\n---- ROTATE ----\n*/\n\n// NONE --> ROTATE_VECTOR\nROTATE_VECTOR = LAMBDA(vector, n, [as_column_vector],\n    LET(\n        vector, TOCOL(vector),\n        rotated_array, IFS(\n            OR(n = 0, n >= ROWS(vector), n <= -ROWS(vector)),\n            vector,\n            n > 0,\n            VSTACK(DROP(vector, n), TAKE(vector, n)),\n            n < 0,\n            VSTACK(TAKE(vector, n), DROP(vector, n))\n        ),\n        as_column_vector, IF(ISOMITTED(as_column_vector), FALSE, TRUE),\n        IF(as_column_vector, TOROW(rotated_array), TOCOL(rotated_array))\n    )\n);\n\n// ROTATE_VECTOR --> ROTATE_ARRAY\nROTATE_ARRAY = LAMBDA(array, n, [rotate_columns],\n    LET(\n        rotate_columns, IF(ISOMITTED(rotate_columns), TRUE, FALSE),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        seqrows, SEQUENCE(nrows),\n        seqcols, SEQUENCE(1, ncols),\n        results, IF(\n            rotate_columns,\n            CHOOSECOLS(array, ROTATE_VECTOR(seqcols, n, TRUE)),\n            CHOOSEROWS(array, ROTATE_VECTOR(seqrows, n, FALSE))\n        ),\n        results\n    )\n);\n\n/*\n---- SWAP ----\n*/\n\n// NONE --> SWAP_COLUMNS\nSWAP_COLUMNS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), 2, to_index),\n        column_sequence, SEQUENCE(1, COLUMNS(array)),\n        from_logical, column_sequence = from_index,\n        to_logical, column_sequence = to_index,\n        replace_from, IF(from_logical, to_index, column_sequence),\n        replace_to, IF(to_logical, from_index, replace_from),\n        CHOOSECOLS(array, replace_to)\n    )\n);\n\n// NONE --> SWAP_ROWS\nSWAP_ROWS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), 2, to_index),\n        row_sequence, SEQUENCE(ROWS(array)),\n        from_logical, row_sequence = from_index,\n        to_logical, row_sequence = to_index,\n        replace_from, IF(from_logical, to_index, row_sequence),\n        replace_to, IF(to_logical, from_index, replace_from),\n        CHOOSEROWS(array, replace_to)\n    )\n);\n\n/*\n---- TEXT ----\n*/\n\n// NONE --> TEXT_SPLIT_VECTOR\nTEXT_SPLIT_VECTOR = LAMBDA(\n    text_vector,\n    [text_delimiter],\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    LET(\n        text_delimiter, IF(ISOMITTED(text_delimiter), \" \", text_delimiter),\n        row_delimiter, IF(ISOMITTED(row_delimiter), \"|<#>|\", row_delimiter),\n        pad_with, IF(ISOMITTED(pad_with), \"\", pad_with),\n        reduce_text, REDUCE(, text_vector, LAMBDA(acc, curr, CONCAT(acc, row_delimiter, curr))),\n        TEXTSPLIT(reduce_text, text_delimiter, row_delimiter, ignore_empty, match_mode, pad_with)\n    )\n);\n\n/*\nMIT License\n\nCopyright (c) 2022-2023 PT. FIAKO ENJINIRING INDONESIA\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n\n\nPenggunaan KembaliMIT LICENSE"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html",
    "href": "release/feidlambda-0-1-0.html",
    "title": "feidlambda 0.1.0",
    "section": "",
    "text": "Official GIST feid_utils (v0.2.0)\n\n\n\nhttps://gist.github.com/taruma/60610672a9bd94724cba46f68b5614fa Pre-release Page (GitHub)\nBerikut daftar fungsi yang tersedia di koleksi feidlambda versi 0.1.0:"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#repeatcols",
    "href": "release/feidlambda-0-1-0.html#repeatcols",
    "title": "feidlambda 0.1.0",
    "section": "1 REPEATCOLS",
    "text": "1 REPEATCOLS\n\n\n\n\n\n\n\nfeid_utils.REPEATCOLS\n\nMengulangi vector sebanyak num_repeat dalam bentuk kolom.\n\nreturn\n\nCOLUMN VECTOR\n\n\n\n\n\n\n\n\n\n\n\n\nJika num_repeat tidak diisi, maka secara default bernilai 2.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.REPEATCOLS(vector, [num_repeat])\n\n\n\n\n\nfeid_utils.REPEATCOLS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#sortcols",
    "href": "release/feidlambda-0-1-0.html#sortcols",
    "title": "feidlambda 0.1.0",
    "section": "2 SORTCOLS",
    "text": "2 SORTCOLS\n\n\n\n\n\n\n\nfeid_utils.SORTCOLS\n\nMenyusun ulang urutan kolom table, berdasarkan table_header yang telah diurutkan.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\n\nJika input table sebagai array, maka pastikan memisahkan antara table_header dengan isinya.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.SORTCOLS(table, table_header)\n\n\n\n\n\nfeid_utils.SORTCOLS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#repeatrows",
    "href": "release/feidlambda-0-1-0.html#repeatrows",
    "title": "feidlambda 0.1.0",
    "section": "3 REPEATROWS",
    "text": "3 REPEATROWS\n\n\n\n\n\n\n\nfeid_utils.REPEATROWS\n\nMengulangi vector sebanyak num_repeat dalam bentuk baris.\n\nreturn\n\nROW VECTOR\n\n\n\n\n\n\n\n\n\n\n\n\nJika num_repeat tidak diisi, maka secara default bernilai 2.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.REPEATROWS(vector, [num_repeat])\n\n\n\n\n\nfeid_utils.REPEATROWS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#reshapecols",
    "href": "release/feidlambda-0-1-0.html#reshapecols",
    "title": "feidlambda 0.1.0",
    "section": "4 RESHAPECOLS",
    "text": "4 RESHAPECOLS\n\n\n\n\n\n\n\nfeid_utils.RESHAPECOLS\n\nMengubah dimensi array dari dimensi \\(\\text{rows} \\times \\text{cols}\\), menjadi \\(\\text{rows} + \\text{} \\times \\textrm{nsplit}\\) tanpa mengubah susunan baris array.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\n\nJika nsplit tidak diisi, maka default bernilai 2.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.RESHAPECOLS(array, [nsplit])\n\n\n\n\n\nfeid_utils.RESHAPECOLS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#findindex2d",
    "href": "release/feidlambda-0-1-0.html#findindex2d",
    "title": "feidlambda 0.1.0",
    "section": "5 FINDINDEX2D",
    "text": "5 FINDINDEX2D\n\n\n\n\n\n\n\nfeid_utils.FINDINDEX2D\n\nMencari index suatu elemen dari array dengan keluaran berupa urutan elemennya, posisi baris dan kolom.\n\nreturn\n\nARRAY / ROW VECTOR with {number element; index row; index column}\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.FINDINDEX2D(lookup_value, array)\n\n\n\n\n\nfeid_utils.FINDINDEX2D"
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html",
    "href": "release/migration-v0-2-to-v0-3.html",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "",
    "text": "Halaman ini menjelaskan mengenai perubahan feidlambda v0.2 ke v0.3 dan panduan migrasinya."
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html#mengulangimerepetisi-data",
    "href": "release/migration-v0-2-to-v0-3.html#mengulangimerepetisi-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mengulangi/merepetisi data",
    "text": "Mengulangi/merepetisi data\n\nFungsi v0.2\n\nREPEATCOLS() | REPEATROWS()\n\nFungsi v0.3\n\nREPEAT_ARRAY_BY_COLUMN() | REPEAT_ARRAY_BY_ROW()\n\n\nDi v0.2, fungsi untuk mengulangi data dapat menggunakan fungsi REPEATCOLS() atau REPEATROWS(). Akan tetapi, terdapat batasan terkait fungsi tersebut yaitu fungsi tersebut hanya menerima input berupa vector. Fungsi tersebut juga menggunakan fungsi CHOOSE*() sebagai fungsi utama dalam merepetisi datanya. Pada versi v0.3, fungsi tersebut digantikan oleh REPEAT_ARRAY_BY_*() atau REPEAT_ARRAY().\nSintaks yang awalnya REPEAT*(vector, [num_repeat]) menjadi REPEAT_ARRAY_BY_*(array, [num_repeat]), jadi untuk fungsi ini cukup mengganti nama fungsinya saja. Perilakunya akan tetap sama dengan versi v0.2. Di versi v0.3, terdapat fungsi baru yaitu REPEAT_ARRAY() yang merupakan fungsi pembungkus untuk REPEAT_ARRAY_BY_*() dengan sintaks REPEAT_ARRAY(array, [num_repeat], [by_row]). Sehingga, bisa juga cukup mengganti fungsi versi sebelumnya dengan fungsi ini dengan tambahan opsional argumen by_row."
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html#mengurutkan-data-berdasarkan-baris",
    "href": "release/migration-v0-2-to-v0-3.html#mengurutkan-data-berdasarkan-baris",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mengurutkan data berdasarkan baris",
    "text": "Mengurutkan data berdasarkan baris\n\nFungsi v0.2\n\nSORTCOLS()\n\nFungsi v0.3\n\n-\n\n\nUntuk mengurutkan kolom berdasarkan baris tertentu bisa langsung menggunakan SORT(array, [sort_index], [sort_order], [by_cols]) yang sudah disediakan di Microsoft Excel. Jadi untuk formula SORTCOLS(table, table_header) menjadi SORT(array, [sort_index], [sort_order], [by_cols]) dengan catatan menggunakan argumen by_cols <- TRUE."
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html#mengubah-dimensi-data",
    "href": "release/migration-v0-2-to-v0-3.html#mengubah-dimensi-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mengubah dimensi data",
    "text": "Mengubah dimensi data\n\nFungsi v0.2\n\nRESHAPECOLS()\n\nFungsi v0.3\n\nRESHAPE_BY_COLUMNS()\n\n\nUntuk fungsi RESHAPECOLS(array, [nsplit]) dapat diganti menggunakan fungsi RESHAPE_BY_COLUMNS(array, [num_split]). Tidak ada perubahan dari posisi argumennya sehingga migrasinya berupa cukup mengganti nama fungsinya."
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html#mencari-posisi-nilai-dari-data",
    "href": "release/migration-v0-2-to-v0-3.html#mencari-posisi-nilai-dari-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mencari posisi nilai dari data",
    "text": "Mencari posisi nilai dari data\n\nFungsi v0.2\n\nFINDINDEX2D()\n\nFungsi v0.3\n\nGET_INDEX_2D()\n\n\nUntuk fungsi FINDINDEX2D(lookup_value, array) dapat digantikan menggunakan fungsi GET_INDEX_2D(lookup_value, array, [return_number_only]). Tidak ada perubahan dari posisi argumennya sehingga migrasinya berupa cukup mengganti nama fungsinya. Terdapat tambahan argumen return_number_only yang hasilnya hanya menyajikan urutan keberapa elemen yang ditemukannya."
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html#memeriksa-hasil-logical",
    "href": "release/migration-v0-2-to-v0-3.html#memeriksa-hasil-logical",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Memeriksa hasil logical",
    "text": "Memeriksa hasil logical\n\nFungsi v0.2\n\nCOMPAREVECTOR() | MULTICHECK()\n\nFungsi v0.3\n\nIS_ALL_IN_VECTOR() | IS_ALL_COLS_EQUAL_VECTOR()\n\n\nUntuk fungsi COMPAREVECTOR() dan MULTICHECK() sebenarnya merupakan fungsi/formula yang digunakan untuk memeriksa suatu kondisi dari data. Oleh karena itu, penamaannya di v0.3 diganti menjadi IS_*. Hal tersebut menyamakan dengan fungsi IS* lainnya, yang bertujuan untuk memeriksa bahwa dataset ini memenuhi kondisi tertentu. COMPAREVECTOR() pada dasarnya adalah proses yang serupa dengan %in% di R, yang bertugas untuk memeriksa apakah setiap nilai elemen di suatu dataset termasuk dalam kumpulan nilai. Atau kata lainnya, memeriksa apakah elemen \\(X_i\\) di \\(X\\) ada di elemen \\(Y\\). Sedangkan untuk MULTICHECK() memeriksa untuk setiap kolom mengandung nilai yang sama dengan nilai yang dicari.\nSintaks COMPAREVECTOR(left_vector, right_vector) menjadi IS_ALL_IN_VECTOR(array, lookup_vector), yang bisa dibaca “Apakah (IS) semua elemen (ALL) termasuk (IN) di lookup_vector yang dicari (VECTOR)?”. Sedangkan untuk MULTICHECK(array, search_array, [check_condition]) menjadi IS_ALL_COLS_EQUAL_VECTOR(array, lookup_vector, [logical_function]), yang bisa dibaca “Apakah (IS) semua (ALL) setiap kolom (COLS) sama dengan (EQUAL) lookup_vector?”. Jadi secara sekilas untuk migrasi cukup mengganti nama fungsinya dengan catatan IS_ALL_COLS_EQUAL_VECTOR() memiliki perubahan argumen opsional yang menjadi logical_function (berupa fungsi LAMBDA())."
  },
  {
    "objectID": "release/migration-v0-2-to-v0-3.html#menghapus-kolom-atau-baris-dari-data",
    "href": "release/migration-v0-2-to-v0-3.html#menghapus-kolom-atau-baris-dari-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Menghapus kolom atau baris dari data",
    "text": "Menghapus kolom atau baris dari data\n\nFungsi v0.2\n\nDROPROWS() | DROPCOLS()\n\nFungsi v0.3\n\nFILTER_DROP_ROWS() | FILTER_DROP_COLUMNS()\n\n\nFungsi DROP*() bertujuan untuk menghapus baris/kolom tertentu dari data. Fungsi tersebut dibuat karena saat ini belum ada fungsinya, yang telah tersedia kebalikannya yaitu mengambil kolom/baris tertentu dengan CHOOSE*(). Penggunaan di v0.3 sama saja dengan v0.2, yang berubah hanya nama fungsinya. Jadi dari DROPROWS(array, index_to_drop) menjadi FILTER_DROP_ROWS(array, row_index) dan DROPCOLS(array, index_to_drop) menjadi FILTER_DROP_COLUMNS(array, column_index)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\ntest"
  },
  {
    "objectID": "docs/penggunaan-v1.html",
    "href": "docs/penggunaan-v1.html",
    "title": "Instalasi feidlambda (outdated)",
    "section": "",
    "text": "AFE 1.1+\n\n\n\nDengan diperbaruinya versi AFE menjadi 1.1+, terdapat beberapa perubahan cara dalam melakukan import feidlambda. Perubahan berupa:\n\nHarus dilakukan instalasi ulang untuk add-ins Advanced Formula Environment.\nFitur terbaru AFE 1.1 bisa dilihat pada README AFE.\nSaat import module melalui gist, namespace modul tidak boleh memiliki karakter titik (.), sehingga yang sebelumnya feid.utils menjadi feid_utils. Perubahan ini akan dibarengi dengan pembaruan versi feidlambda 0.3.x."
  },
  {
    "objectID": "docs/penggunaan-v1.html#advanced-formula-environment",
    "href": "docs/penggunaan-v1.html#advanced-formula-environment",
    "title": "Instalasi feidlambda (outdated)",
    "section": "1 Advanced Formula Environment",
    "text": "1 Advanced Formula Environment\nInstall add-ins Advanced Formula Environment dari menu Insert > Get Add-ins > Cari Advanced Formula Environment (AFE).\n\n\n\n\nMenambahkan Advanced Formula Environment Add-ins"
  },
  {
    "objectID": "docs/penggunaan-v1.html#import-menggunakan-afe",
    "href": "docs/penggunaan-v1.html#import-menggunakan-afe",
    "title": "Instalasi feidlambda (outdated)",
    "section": "2 Import menggunakan AFE",
    "text": "2 Import menggunakan AFE\nSetelah AFE terpasang di Microsoft Excel, lakukan import dengan membuka AFE melalui Home > Advanced Formula Environment > Import.\n\n\n\n\nMelakukan import di AFE"
  },
  {
    "objectID": "docs/penggunaan-v1.html#salin-github-gist-url",
    "href": "docs/penggunaan-v1.html#salin-github-gist-url",
    "title": "Instalasi feidlambda (outdated)",
    "section": "3 Salin Github Gist URL",
    "text": "3 Salin Github Gist URL\nIsi “Github Gist URL” dengan link koleksi lambda yang tersedia. Checklist ✅ bagian “Add formulas to new namespace” dan isi namespace dengan nama koleksi (contoh: feid.utils).\n\n\n\n\n\n\nLakukan langkah import (2-3) untuk setiap koleksi yang ingin ditambahkan.\n\n\n\n\n\n\nIsi GitHub Gist URL dan Namespace"
  },
  {
    "objectID": "docs/penggunaan-v1.html#sync-formula",
    "href": "docs/penggunaan-v1.html#sync-formula",
    "title": "Instalasi feidlambda (outdated)",
    "section": "4 Sync formula",
    "text": "4 Sync formula\nSetelah import seluruh koleksi yang digunakan, lakukan synchronize yang bertujuan menyamakan nama pada Formula/Excel Name Manager.\n\n\n\n\n\n\nJika muncul peringatan mengenai hidden sheets, pilih “Allow …”.\n\n\n\n\n\n\nSynchronize AFE"
  },
  {
    "objectID": "docs/penggunaan-v1.html#gunakan-koleksi-lambda",
    "href": "docs/penggunaan-v1.html#gunakan-koleksi-lambda",
    "title": "Instalasi feidlambda (outdated)",
    "section": "5 Gunakan koleksi lambda",
    "text": "5 Gunakan koleksi lambda\nSelesai sync, fungsi lambda bisa langsung digunakan.\n\n\n\n\nGunakan koleksi lambda yang telah di-import"
  },
  {
    "objectID": "docs/glossary.html",
    "href": "docs/glossary.html",
    "title": "Daftar Istilah",
    "section": "",
    "text": "NUMERIC\nAngka / numerik. Numerik yang dimaksud adalah bilangan real: \\(\\mathbb{R} = \\{-1, 0, 1, \\pi, 2.3212, -1.2, \\frac{2}{3}, \\dots\\}\\). Bilangan complex \\(\\mathbb{C}\\) tidak termasuk.\n\n\nLOGICAL\nTRUE atau FALSE. Dapat dikenal juga sebagai boolean. Nilai logical bisa juga direpresentasikan dalam bentuk numerik dengan 0 berarti FALSE, sedangkan nilai numerik selain 0 dianggap TRUE.\n\n\nTEXT\nKarakter atau teks. Dikenal juga sebagai string.\n\n\nCELL\nSel.\n\n\n\n\n\n\n\n(a) Cell (Excel)\n\n\n\n\n\n\n\n(b) Cell (Ilustrasi)\n\n\n\n\nGambar 1: Cell\n\n\n\n\nRANGE\nRentang yang terdiri dari lebih dari satu sel.\n\n\n\n\n\n\n\n(a) Range (Excel)\n\n\n\n\n\n\n\n(b) Range (Ilustrasi)\n\n\n\n\nGambar 2: Range\n\n\n\n\nVECTOR\nRange yang memiliki 1 dimensi.\n\n\n\n\n\n\n\n(a) Vector (Excel)\n\n\n\n\n\n\n\n(b) Vector (Ilustrasi)\n\n\n\n\nGambar 3: Vector\n\n\n\n\nARRAY\nRange yang memiliki 1 dimensi atau 2 dimensi. Untuk membedakan antara 1 dimensi dan 2 dimensi, istilah array digunakan untuk range yang memiliki 2 dimensi. Meskipun array di excel bisa merepresentasikan range 1 dimensi atau range 2 dimensi.\n\n\n\n\n\n\n\n(a) Array (Excel)\n\n\n\n\n\n\n\n(b) Array (Ilustrasi)\n\n\n\n\nGambar 4: Array\n\n\n\n\nTABLE\nArray yang memiliki header dalam format tabel.\n\n\n\n\n\n\n\n(a) Table (Excel)\n\n\n\n\n\n\n\n(b) Table (Ilustrasi)\n\n\n\n\nGambar 5: Table\n\n\n\n\nLOGICAL VECTOR / LOGICAL ARRAY\nVector atau array yang berisikan nilai TRUE atau FALSE.\n\n\n\n\n\n\n\n(a) Logical Vector (Excel)\n\n\n\n\n\n\n\n(b) Logical Vector (Ilustrasi)\n\n\n\n\nGambar 6: Logical Vector\n\n\n\n\nNUMERIC VECTOR / NUMERIC ARRAY\nVector atau array yang berisikan nilai numerik.\n\n\n\n\n\n\n\n(a) Numeric Vector (Excel)\n\n\n\n\n\n\n\n(b) Numeric Vector (Ilustrasi)\n\n\n\n\nGambar 7: Numeric Vector\n\n\n\n\nTEXT VECTOR / TEXT ARRAY\nVector atau array yang berisikan nilai text atau string.\n\n\nROW VECTOR\nVector yang melebar ke samping atau berupa baris.\n\n\n\nGambar 8: Row Vector (Excel)\n\n\n\n\nCOLUMN VECTOR\nVector yang memanjang ke bawah atau berupa kolom.\n\n\n\nGambar 9: Column Vector (Excel)\n\n\n\n\nDYNAMIC ARRAY\nLarik dinamis adalah kumpulan nilai / sel yang merupakan satu kesatuan. Dapat berupa vector (1D) atau array (2D).\n\n\n\n\n\n\n\n(a) Column Vector Biasa\n\n\n\n\n\n\n\n(b) Dynamic Array pada Column Vector\n\n\n\n\n\n\n\n(c) Column Vector (Dynamic Array)\n\n\n\n\nGambar 10: Dynamic Array (Vector)\n\n\n\n\n\n\n\n\n\n(a) Array Biasa\n\n\n\n\n\n\n\n(b) Dynamic Array pada Array\n\n\n\n\n\n\n\n(c) Array (Dynamic Array)\n\n\n\n\nGambar 11: Dynamic Array (Array)\n\n\n\n\nDYNAMIC ARRAY FORMULA / FUNCTION\nFormula atau fungsi yang mengeluarkan hasil lebih dari satu sel (vector / array) dalam bentuk dynamic array.\nPersamaan yang termasuk dynamic array formula antara lain: =POWER(), =ABS(), =ROUNDUP(), dll. Yang perlu diingat bahwa formula dynamic array mampu menghasilkan nilai dalam bentuk vector atau array sesuai jenis nilai yang dimasukkan.\n\n\n\n\n\n\n\n(a) Formula Biasa\n\n\n\n\n\n\n\n(b) Dynamic Array Formula\n\n\n\n\nGambar 12: Dynamic Array Formula\n\n\n\n\nSCALAR FORMULA / FUNCTION\nFormula atau fungsi yang mengluarkan hasil satu sel atau scalar (satu nilai)."
  },
  {
    "objectID": "docs/penggunaan.html",
    "href": "docs/penggunaan.html",
    "title": "Instalasi feidlambda",
    "section": "",
    "text": "Panduan ini untuk Advanced Formula Environment v1.1. Panduan versi sebelumnya (v1.0) bisa dilihat disini."
  },
  {
    "objectID": "docs/penggunaan.html#advanced-formula-environment",
    "href": "docs/penggunaan.html#advanced-formula-environment",
    "title": "Instalasi feidlambda",
    "section": "1 Advanced Formula Environment",
    "text": "1 Advanced Formula Environment\nInstall add-ins Advanced Formula Environment dari menu Insert > Get Add-ins > Cari Advanced Formula Environment (AFE).\n\n\n\n\nMenambahkan Advanced Formula Environment Add-ins"
  },
  {
    "objectID": "docs/penggunaan.html#import-menggunakan-afe",
    "href": "docs/penggunaan.html#import-menggunakan-afe",
    "title": "Instalasi feidlambda",
    "section": "2 Import menggunakan AFE",
    "text": "2 Import menggunakan AFE\nSetelah AFE terpasang di Microsoft Excel, lakukan import dengan membuka AFE melalui Formula > Advanced Formula Environment > Import.\n\n\n\n\nMelakukan import di AFE"
  },
  {
    "objectID": "docs/penggunaan.html#salin-github-gist-url",
    "href": "docs/penggunaan.html#salin-github-gist-url",
    "title": "Instalasi feidlambda",
    "section": "3 Salin Github Gist URL",
    "text": "3 Salin Github Gist URL\nIsi “Github Gist URL” dengan link koleksi lambda yang tersedia (Link Github Gist feidlambda v0.3). Checklist ✅ bagian “Add formulas to new module” dan isi nama module dengan nama koleksi (contoh: feid).\n\n\n\nIsi GitHub Gist URL dan nama module"
  },
  {
    "objectID": "docs/penggunaan.html#save-sync-module",
    "href": "docs/penggunaan.html#save-sync-module",
    "title": "Instalasi feidlambda",
    "section": "4 Save / Sync module",
    "text": "4 Save / Sync module\nSetelah import seluruh koleksi yang digunakan dan berhasil, lakukan saving (sync) yang bertujuan untuk menerapkan module ke lembar kerja Excel. Shortcut untuk save yaitu Ctrl + S.\n\n\n\nSave / Apply module ke lembar kerja"
  },
  {
    "objectID": "docs/penggunaan.html#gunakan-koleksi-lambda",
    "href": "docs/penggunaan.html#gunakan-koleksi-lambda",
    "title": "Instalasi feidlambda",
    "section": "5 Gunakan koleksi lambda",
    "text": "5 Gunakan koleksi lambda\nSelesai save, fungsi feidlambda bisa langsung digunakan.\n\n\n\n\nGunakan koleksi lambda yang telah di-import"
  },
  {
    "objectID": "docs/penggunaan.html#baca-dokumentasi-feidlambda-v0.3",
    "href": "docs/penggunaan.html#baca-dokumentasi-feidlambda-v0.3",
    "title": "Instalasi feidlambda",
    "section": "6 Baca dokumentasi feidlambda v0.3",
    "text": "6 Baca dokumentasi feidlambda v0.3\nDokumentasi feidlambda v0.3 bisa baca di halaman feidlambda v0.3. Dan panduan migrasi bisa baca di halaman Migrasi feidlambda v0.2 ke v0.3.\nJangan lupa juga untuk membaca Daftar istilah yang digunakan dalam pada dokumentasi dan pengembangan feidlambda."
  },
  {
    "objectID": "greenhorn/index.html",
    "href": "greenhorn/index.html",
    "title": "feidlambda",
    "section": "",
    "text": "Greenhorn \\(\\text{fe}\\hat{i}\\text{d} \\textbf{l} \\lambda \\text{m} \\textsf{b} \\texttt{d} \\bigtriangleup\\) by fiakodev\n\n\n\n\n\n\n\nDalam Pengembangan dan Pelatihan\n\n\n\nPelatihan ini masih dalam tahap pengembangan dan pelaksanaan. Seluruh materi yang disinggung akan dicatat di bagian greenhorn ini.\n\n\n\nfeidlambda I (WIP)Introduction to Dynamic Array\nfeidlambda II (WIP)Exploring Dynamic Array + User Defined Lambda (UDL) with LAMBDA\nfeidlambda III (WIP)Advanced Dynamic Array + Best Practices UDF"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#section",
    "href": "greenhorn/feidlambda-2/presentation.html#section",
    "title": "Greenhorn:feidlambda II",
    "section": "",
    "text": "Kegiatan\nGreenhorn\nTopik\nExploring Dynamic Array and User Defined Lambda (UDL)Memanfaatkan Dynamic Array dan User-Defined LAMBDA (UDL)\nAuthor\nBahan presentasi dibuat oleh Taruma Sakti Megariansyah\nLisensi\nSeluruh materi presentasi menggunakan lisensi CC-BY-NC-SA 4.0\nKontak\nhi@taruma.info / team@dev.fiako.engineering"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#agenda",
    "href": "greenhorn/feidlambda-2/presentation.html#agenda",
    "title": "Greenhorn:feidlambda II",
    "section": "Agenda",
    "text": "Agenda\nAgenda untuk Greenhorn feidlambda II: Exploring Dynamic Array + User Defined Lambda (UDL)\n\nReview Daftar Istilah\nEksplorasi tentang Logical\nDynamic Array Formula (DAF)\nFungsi Baru dari Excel 2019 dan 2021\nUser Defined Lambda (UDL)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#vector-dan-array",
    "href": "greenhorn/feidlambda-2/presentation.html#vector-dan-array",
    "title": "Greenhorn:feidlambda II",
    "section": "Vector dan Array",
    "text": "Vector dan Array\n\nIstilah array dapat diartikan range yang memiliki 1 dimensi atau 2 dimensi.\nArray dapat dibangkitkan menggunakan sintaks “={...}”. Dengan “,” sebagai pemisah kolom (sepanjang baris), “;” sebagai pemisah baris (sepanjang kolom).\n\n\\[\n\\texttt{{1,2,3}}\n=\n\\begin{bmatrix}\n  1 & 2 & 3\n\\end{bmatrix}\n,\n\\texttt{{1;2;3}}\n=\n\\begin{bmatrix}\n  1\\\\\n  2\\\\\n  3\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{\\{}\n  \\underbrace{\\texttt{1,2,3}}_{\\textit{baris ke-}1}\n  \\texttt{;}\n  \\underbrace{\\texttt{4,5,6}}_{\\textit{baris ke-}2}\n  \\texttt{;}\n  \\underbrace{\\texttt{7,8,9}}_{\\textit{baris ke-}3}\n\\texttt{\\}}\n=\n\\begin{bmatrix}\n  1 & 2 & 3\\\\\n  4 & 5 & 6\\\\\n  7 & 8 & 9\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#not-1",
    "href": "greenhorn/feidlambda-2/presentation.html#not-1",
    "title": "Greenhorn:feidlambda II",
    "section": "NOT (1)",
    "text": "NOT (1)\nSyntax\n=NOT(logical)\n\nFungsi NOT membalikkan nilai argumennya. 1\nMenghasilkan nilai TRUE ketika kondisi bernilai FALSE, dan berlaku sebaliknya.\nNOT(TRUE) = FALSE\nNOT(FALSE) = TRUE\n\nNOT (Fungsi NOT), Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#not-2",
    "href": "greenhorn/feidlambda-2/presentation.html#not-2",
    "title": "Greenhorn:feidlambda II",
    "section": "NOT (2)",
    "text": "NOT (2)\n\\[\n\\texttt{NOT}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE}\\\\\n    \\texttt{FALSE}\\\\\n    \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{FALSE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{NOT}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{FALSE} & \\texttt{TRUE} & \\texttt{FALSE}\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{NOT}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE} & \\texttt{FALSE}\\\\\n    \\texttt{FALSE} & \\texttt{TRUE}\\\\\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{FALSE} & \\texttt{TRUE}\\\\\n  \\texttt{TRUE} & \\texttt{FALSE}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#and-1",
    "href": "greenhorn/feidlambda-2/presentation.html#and-1",
    "title": "Greenhorn:feidlambda II",
    "section": "AND (1)",
    "text": "AND (1)\n\nFungsi logika, untuk menentukan apakah semua kondisi dalam sebuah tes adalah TRUE. 1\n\n=AND(logical1, [logical2], ...)\n\nMenghasilkan nilai TRUE ketika seluruh kondisi bernilai TRUE. Jika terdapat satu atau lebih bernilai FALSE maka menghasilkan nilai FALSE.\nJika input berupa logical array saja (AND(logical_array)), maka akan mengevaluasi seluruh elemen pada logical array (AND(elemen_1, elemen_2, ...)).\n\nAND (Fungsi AND), Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#and-2",
    "href": "greenhorn/feidlambda-2/presentation.html#and-2",
    "title": "Greenhorn:feidlambda II",
    "section": "AND (2)",
    "text": "AND (2)\n\\[\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#and-3",
    "href": "greenhorn/feidlambda-2/presentation.html#and-3",
    "title": "Greenhorn:feidlambda II",
    "section": "AND (3)",
    "text": "AND (3)\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{TRUE} \\\\ \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} \\\\\n  \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n  ,\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#or-1",
    "href": "greenhorn/feidlambda-2/presentation.html#or-1",
    "title": "Greenhorn:feidlambda II",
    "section": "OR (1)",
    "text": "OR (1)\n\nFungsi logika, untuk menentukan apakah salah satu kondisi dalam sebuah tes adalah TRUE. 1\n\n=OR(logical1, [logical2], ...)\n\nMenghasilkan nilai TRUE ketika salah satu kondisi bernilai TRUE.\nJika input berupa logical array saja (OR(logical_array)), maka akan mengevaluasi seluruh elemen pada logical array (OR(elemen_1, elemen_2, ...)).\n\nOR function, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#or-2",
    "href": "greenhorn/feidlambda-2/presentation.html#or-2",
    "title": "Greenhorn:feidlambda II",
    "section": "OR (2)",
    "text": "OR (2)\n\\[\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#or-3",
    "href": "greenhorn/feidlambda-2/presentation.html#or-3",
    "title": "Greenhorn:feidlambda II",
    "section": "OR (3)",
    "text": "OR (3)\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{TRUE} \\\\ \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} \\\\\n  \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n  ,\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xor-1",
    "href": "greenhorn/feidlambda-2/presentation.html#xor-1",
    "title": "Greenhorn:feidlambda II",
    "section": "XOR (1)",
    "text": "XOR (1)\n\nFungsi XOR mengembalikan logika Exclusive Or dari semua argumen. 1\n\n=XOR(logical1, [logical2], ...)\n\nMenghasilkan nilai TRUE ketika hanya satu kondisi bernilai TRUE.\nJika input berupa logical array saja (XOR(logical_array)), maka akan mengevaluasi seluruh elemen pada logical array (XOR(elemen_1, elemen_2, ...)).\n\nXOR function, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xor-2",
    "href": "greenhorn/feidlambda-2/presentation.html#xor-2",
    "title": "Greenhorn:feidlambda II",
    "section": "XOR (2)",
    "text": "XOR (2)\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xor-3",
    "href": "greenhorn/feidlambda-2/presentation.html#xor-3",
    "title": "Greenhorn:feidlambda II",
    "section": "XOR (3)",
    "text": "XOR (3)\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} \\\\\n  \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n  ,\n  \\begin{bmatrix}\n  \\texttt{FALSE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#logical-rightarrow-number-1",
    "href": "greenhorn/feidlambda-2/presentation.html#logical-rightarrow-number-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Logical \\(\\Rightarrow\\) Number (1)",
    "text": "Logical \\(\\Rightarrow\\) Number (1)\n\n\\(\\texttt{FALSE} = 0\\). Bernilai FALSE jika bernilai 0. \\(\\{ x = 0 \\}\\)\n\\(\\texttt{TRUE} \\neq 0\\). Bernilai TRUE jika nilai bukan 0. \\(\\{ x \\in \\mathbb{R}\\ |\\ x \\neq 0 \\}\\)\nMengubah logical menjadi number dapat menggunakan fungsi INT(...). 1\n\\(\\texttt{INT}(\\texttt{TRUE}) = 1\\).\n\\(\\texttt{INT}(\\texttt{FALSE}) = 0\\).\n\nINT (FUNGSI INT), Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-1",
    "href": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Logical dan operator aritmatika (1)",
    "text": "Logical dan operator aritmatika (1)\n\nLogical array akan diubah menjadi numeric array ketika bertemu operator aritmatika (+, *, -, /).\nPerubahan logical menjadi number sama dengan proses penggunaan fungsi INT(...).\nOperator aritmatika perkalian (* / \\(\\times\\)) dan penambahan (+) dapat berperilaku seperti fungsi logical AND (*) dan OR (+).\nUmumnya operator perkalian setiap elemen dalam suatu vector atau matriks (array) menggunakan simbol \\(\\odot\\). Akan tetapi, pada materi ini simbol \\(\\times\\) diartikan sebagai perkalian setiap elemen (element-wise) dan bukan perkalian matriks."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-2",
    "href": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Logical dan operator aritmatika (2)",
    "text": "Logical dan operator aritmatika (2)\n\\[\n\\mathbf{X}\n\\underbrace{\\textsf{ operator }}_{\\times\\ |\\ +}\n\\mathbf{Y}\n\\Rightarrow\n\\mathbf{P}\n\\underbrace{\\textsf{ operator }}_{\\times\\ |\\ +}\n\\mathbf{Q}\n\\]\n\\[\n\\mathbf{X} \\in \\mathbb{B}_l, \\mathbf{Y} \\in \\mathbb{B}_l,\n\\mathbf{P} \\in \\mathbb{B}_i, \\mathbf{Q} \\in \\mathbb{B}_i\n\\]\n\nSimbol \\(\\mathbb{B}\\) untuk menyatakan nilai logical atau boolean. 1\n\n\\[\n\\mathbb{B}_l =\n\\{\n  \\texttt{TRUE, FALSE}\n\\}\n=\n\\{\n  \\text{T}, \\text{F}\n\\}\n,\n\\mathbb{B}_i =\n\\{\n  0, 1\n\\}\n\\]\n\\[\n\\overbrace{\n  \\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n}^{\\text{logical array}}\n\\underbrace{\\ \\times\\ |\\ +\\ }_\\text{operator}\n\\overbrace{\n  \\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n}^{\\text{logical array}}\n\\Rightarrow\n\\overbrace{\n  \\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n  \\end{bmatrix}\n}^{\\text{numeric array}}\n\\underbrace{\\ \\times\\ |\\ +\\ }_\\text{operator}\n\\overbrace{\n  \\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n  \\end{bmatrix}\n}^{\\text{numeric array}}\n\\]\nBoolean Domain"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-1",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator perkalian * sebagai AND (1)",
    "text": "Operator perkalian * sebagai AND (1)\n\nSetiap nilai yang dikalikan dengan 0 akan bernilai 0.\n\n\\[\nx \\times 0 = 0,\\ \\{x \\in \\mathbb{R}\\}\n\\]\n\nSetiap nilai yang dikalikan dengan FALSE akan bernilai FALSE."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-2",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator perkalian * sebagai AND (2)",
    "text": "Operator perkalian * sebagai AND (2)\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n=\n\\underbrace{\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n}_{\\textit{hasil akhir}}\n\\]\n\\[\n\\Rightarrow\n\\underbrace{\n  \\left(\n    \\begin{bmatrix}\n    1\\\\\n    0\\\\\n    0\n  \\end{bmatrix}\n  \\neq 0\n  \\right)\n}_{\\textit{mengubah menjadi logical}}\n=\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-1",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator penambahan + sebagai OR (1)",
    "text": "Operator penambahan + sebagai OR (1)\n\nBerlaku seperti penambahan pada umumnya.\n\n\\[\nx + 0 = x, x \\in \\mathbb{R}\n\\]\n\\[\nx + y = x + y,  x \\in \\mathbb{R}, y \\in \\mathbb{R}\n\\]\n\nSetiap nilai yang bukan 0 bernilai TRUE. \\(\\texttt{TRUE} \\neq 0\\)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-2",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator penambahan + sebagai OR (2)",
    "text": "Operator penambahan + sebagai OR (2)\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n=\n\\underbrace{\n\\begin{bmatrix}\n  2\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n}_{\\textit{hasil akhir}}\n\\]\n\\[\n\\Rightarrow\n\\underbrace{\n  \\left(\n    \\begin{bmatrix}\n      2\\\\\n      1\\\\\n      0\n    \\end{bmatrix}\n    \\neq 0\n  \\right)\n}_{\\textit{mengubah menjadi logical}}\n=\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-1",
    "href": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Number \\(\\Rightarrow\\) Logical (1)",
    "text": "Number \\(\\Rightarrow\\) Logical (1)\n\nNumeric array dapat digunakan sebagai kondisi logical.\nSetiap numeric array yang digunakan sebagai conditional secara tidak langsung berubah menjadi logical array.\nPerubahan tersebut sama saja jika membandingkan array tidak sama dengan 0. \\[\n\\left(\n\\mathbf{x}_{\\text{number}} \\neq 0\n\\right)\n=\n\\mathbf{x}_{\\text{logical}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2",
    "href": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Number \\(\\Rightarrow\\) Logical (2)",
    "text": "Number \\(\\Rightarrow\\) Logical (2)\n\\[\n\\texttt{NOT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3\\\\\n      -1\\\\\n      0\n    \\end{bmatrix}\n  }_{\\textit{numeric}}\n  \\equiv\n  0\n\\right)\n=\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3\\\\\n      -1\\\\\n      0\n    \\end{bmatrix}\n  }_{\\textit{numeric}}\n  \\neq\n  0\n\\right)\n=\n\\underbrace{\n  \\begin{bmatrix}\n    \\texttt{TRUE}\\\\\n    \\texttt{TRUE}\\\\\n    \\texttt{FALSE}\n  \\end{bmatrix}\n}_{\\textit{logical}}\n\\]\n\nSama saja dengan formula =NOT(array=0) atau =array<>0."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2-1",
    "href": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Number \\(\\Rightarrow\\) Logical (2)",
    "text": "Number \\(\\Rightarrow\\) Logical (2)\n\\[\n\\texttt{IF}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3\\\\\n      -1\\\\\n      0\n    \\end{bmatrix}\n  }_{\\textit{numeric}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{TRUE}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{FALSE}}\n\\right)\n\\Rightarrow\n\\texttt{IF}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      \\texttt{TRUE}\\\\\n      \\texttt{TRUE}\\\\\n      \\texttt{FALSE}\n    \\end{bmatrix}\n  }_{\\textit{logical}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{TRUE}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{FALSE}}\n\\right)\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#yang-perlu-diperhatikan",
    "href": "greenhorn/feidlambda-2/presentation.html#yang-perlu-diperhatikan",
    "title": "Greenhorn:feidlambda II",
    "section": "Yang perlu diperhatikan",
    "text": "Yang perlu diperhatikan\n\nHasil dari logical array bertemu dengan operator aritmatika selalu numeric array.\n\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  \\texttt{FALSE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\n\\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  0\\\\\n  1\\\\\n  1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  1\n\\end{bmatrix}\n\\]\n\nJika numeric array digunakan sebagai argumen conditional, maka akan dikonversikan menjadi logical array."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#fungsi-is...",
    "href": "greenhorn/feidlambda-2/presentation.html#fungsi-is...",
    "title": "Greenhorn:feidlambda II",
    "section": "Fungsi IS*(...)",
    "text": "Fungsi IS*(...)\nSYNTAX\n=IS*(value)\n\nMemeriksa nilai tertentu dan mengembalikan TRUE atau FALSE bergantung pada hasilnya. 1\nISBLANK(...) bernilai TRUE jika sel kosong.\nISNUMBER(...) bernilai TRUE jika sel berisikan angka.\n\nFungsi IS, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#periksa-error-kosong",
    "href": "greenhorn/feidlambda-2/presentation.html#periksa-error-kosong",
    "title": "Greenhorn:feidlambda II",
    "section": "Periksa error / kosong",
    "text": "Periksa error / kosong\n\nISNA(...): Cek nilai apakah #N/A.\nISERR(...): Cek nilai apakah error selain #N/A (#VALUE!, #REF!, #DIV/0!, #NUM!, #NAME?, atau #NULL!).\nISERROR(...): Cek nilai apakah error (seluruh jenis error).\nISBLANK(...): Cek nilai apakah kosong."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-sel",
    "href": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-sel",
    "title": "Greenhorn:feidlambda II",
    "section": "Periksa jenis sel",
    "text": "Periksa jenis sel\n\nISLOGICAL(...): Cek nilai apakah logical (TRUE atau FALSE).\nISNUMBER(...): Cek nilai apakah angka (\\(\\mathbb{R}\\)).\nISTEXT(...): Cek nilai apakah teks. Dan ISNONTEXT(...): Cek niai apakah bukan teks (number, logical, error)\nISFORMULA(...): Cek nilai apakah formula."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-bilangan",
    "href": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-bilangan",
    "title": "Greenhorn:feidlambda II",
    "section": "Periksa jenis bilangan",
    "text": "Periksa jenis bilangan\n\nISEVEN(...): Cek nilai apakah bilangan genap.\nISODD(...): Cek nilai apakah bilangan ganjil."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (1)",
    "text": "Validasi dengan ISNUMBER(...) (1)\n\\[\nf : \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x}) = \\mathbf{y} = \\mathbf{x} + 2\n\\]\n\\[\n\\mathbf{x} \\in \\mathbb{R}, \\mathbf{y} \\in \\mathbb{R}\n\\]\n\\[\n\\mathbf{x}\n\\mapsto\n\\mathbf{x} + 2\n\\]\n\nUmumnya nilai \\(\\mathbf{y}\\) dihitung dengan formula =x+2 dengan asumsi \\(\\mathbf{x}\\) bernilai angka \\(\\{ \\mathbf{x} \\in \\mathbb{R} \\}\\).\n\n\\[\n\\mathbf{x}\n=\n\\begin{bmatrix}\n  3 \\\\ 2 \\\\ 7\n\\end{bmatrix}\n\\mapsto\nf(\\mathbf{x})\n=\n\\begin{bmatrix}\n  3 \\\\ 2 \\\\ 7\n\\end{bmatrix}\n+ 2\n=\n\\begin{bmatrix}\n  5 \\\\ 4 \\\\ 9\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (2)",
    "text": "Validasi dengan ISNUMBER(...) (2)\n\nBagaimana jika \\(\\mathbf{x}\\) memiliki elemen yang bukan angka yaitu text / error / logical?\n\n\\[\n\\mathbf{x}\n=\n\\begin{bmatrix}\n  3 \\\\ \\textrm{bob} \\\\ 2\n\\end{bmatrix}\n\\mapsto\nf(\\mathbf{x})\n=\n\\begin{bmatrix}\n  3 \\\\ \\textrm{bob} \\\\ 2\n\\end{bmatrix}\n+ 2\n=\n\\begin{bmatrix}\n  5 \\\\ \\texttt{#VALUE!} \\\\ 2\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (3)",
    "text": "Validasi dengan ISNUMBER(...) (3)\n\nValidasi input menggunakan ISNUMBER(...)\n\n\\[\n\\mathbf{x}\n=\n\\begin{bmatrix}\n  3 \\\\ \\textrm{bob} \\\\ 2\n\\end{bmatrix}\n\\mapsto\n\\texttt{ISNUMBER}\n\\left(\n  \\mathbf{x}\n\\right)\n=\n\\texttt{ISNUMBER}\n\\left(\n  \\begin{bmatrix}\n    3 \\\\ \\textrm{bob} \\\\ 2\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{TRUE}\n\\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{TRUE}\n\\end{bmatrix}\n\\mapsto\n\\texttt{AND}\n\\left(\n  \\mathbf{x}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\mathbf{x}\n\\mapsto\n\\texttt{AND}(\n  \\texttt{ISNUMBER}(\n    \\mathbf{x}\n  )\n)\n=\n\\texttt{AND}(\n  \\texttt{ISNUMBER}(\n    \\begin{bmatrix}\n      3 \\\\ \\textrm{bob} \\\\ 2\n    \\end{bmatrix}\n  )\n)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (4)",
    "text": "Validasi dengan ISNUMBER(...) (4)\n\\[\n\\begin{equation}\n  \\mathbf{x}\n  \\mapsto\n  \\texttt{AND}\n  (\n    \\texttt{ISNUMBER}(\\mathbf{x})\n  )\n  =\n  \\begin{cases}\n    \\texttt{TRUE} & f : \\mathbf{x} \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n    \\texttt{FALSE} & \\textrm{return}\\ \\texttt{#VALUE!} \\\\\n    \\texttt{FALSE} & \\mathbf{x} \\mapsto g(\\mathbf{x}) = \\texttt{FILTER}(\\dots) \\mapsto \\\\\n    & f: g(\\mathbf{x}) \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n  \\end{cases}\n\\end{equation}\n\\]\n\nValidasi ini dapat diimplementasikan ketika terdapat ketidakpastian jika \\(\\mathbf{x}\\) dapat bernilai bukan angka (\\(\\mathbf{x} \\in \\mathbb{R} \\lor \\mathbf{x} \\notin \\mathbb{R}\\))\nSolusi lain dengan melakukan filter pada \\(\\mathbf{x}\\) dan hanya mengambil elemen yang angka dengan FILTER(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (1)",
    "text": "FILTER(...) (1)\n\nFILTER(...): Fungsi FILTER memungkinkan Anda memfilter rentang data berdasarkan kriteria yang ditetapkan. 1\n\n=FILTER(array, include, [if_empty])\n\nArgumen include harus berupa vector (kolom atau baris). dan jumlah kolom/baris harus sama dengan array.\nArgumen if_empty dapat diisi dengan nilai ketika argumen include kosong atau FALSE.\n\nFungsi FILTER, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (2)",
    "text": "FILTER(...) (2)\n\\[\n\\texttt{FILTER}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      10 & 8\\\\\n      \\textit{A} & -100\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        \\texttt{TRUE}\\\\\n        \\texttt{FALSE}\\\\\n        \\texttt{TRUE}\n      \\end{bmatrix}\n    }^{\\textit{logical column vector}}\n  }_{\\texttt{include}}\n\\right)\n=\n\\underbrace{\n  \\begin{bmatrix}\n      10 & 8\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n}_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{FILTER}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      10 & 8\\\\\n      \\textit{A} & -100\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        \\texttt{FALSE} & \\texttt{TRUE}\n      \\end{bmatrix}\n    }^{\\textit{logical row vector}}\n  }_{\\texttt{include}}\n\\right)\n=\n\\underbrace{\n  \\begin{bmatrix}\n      8\\\\\n      -100\\\\\n      \\textit{y}\n    \\end{bmatrix}\n}_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (3)",
    "text": "FILTER(...) (3)\n\\[\n\\texttt{FILTER}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      10 & 8\\\\\n      \\textit{A} & -100\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        \\texttt{FALSE}\\\\\n        \\texttt{FALSE}\\\\\n        \\texttt{FALSE}\n      \\end{bmatrix}\n    }^{\\textit{logical column vector}}\n  }_{\\texttt{include}}\n  ,\n  \\underbrace{\n    \\textrm{tidak ada}\n  }_{\\texttt{if_empty}}\n\\right)\n=\n\\textrm{tidak ada}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (4)",
    "text": "FILTER(...) (4)\n\\[\n\\texttt{array} = \\mathbf{A} \\rightarrow \\mathbf{A} \\in \\mathbb{U}^{m \\times n}, \\{m, n \\in \\mathbb{N}\\ |\\ m, n \\neq 0 \\}\n\\]\n\\[\n\\mathbb{U} = \\{ \\textrm{seluruh nilai } u \\textrm{ yang dapat digunakan di Excel}\\}\n\\]\n\n\\(m\\) menunjukkan jumlah baris dan \\(n\\) menunjukkan jumlah kolom.\n\n\\[\n\\texttt{include} = \\mathbf{i} \\rightarrow \\mathbf{i} \\in \\mathbb{B}^{k}, \\{k = m \\lor k = n\\}\n\\]\n\n\\(\\mathbf{i}\\) selalu berupa logical vector dengan jumlah baris/kolom \\(k\\) sama dengan \\(m \\lor n\\)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (1)",
    "text": "UNIQUE(...) (1)\n\nUNIQUE(...): Fungsi UNIQUE menghasilkan daftar nilai yang unik dalam daftar atau rentang. 1\n\n=UNIQUE(array, [by_col], [exactly_once])\n\nPenggunaan argumen by_col untuk mencari nilai unik untuk setiap baris atau kolom. Nilai default argumen by_col <- FALSE.\nArgumen exactly_once dapat digunakan untuk menyaring nilai unik yang muncul lebih dari satu kali. Jika exactly_once <- TRUE, maka jika terdapat nilai unik yang muncul dua kali akan dihapus. Nilai default argumen exactly_once <- FALSE.\n\nFungsi UNIQUE, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (2)",
    "text": "UNIQUE(...) (2)\n\\[\n\\texttt{UNIQUE}\n\\left(\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        1 & 1 & 3 & 1\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}      \n    }^{\\textit{array / vector}}\n  }_{\\texttt{array}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n    \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (3)",
    "text": "UNIQUE(...) (3)\n\\[\n\\texttt{UNIQUE}\n\\left(\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        1 & 1 & 3 & 1\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}      \n    }^{\\textit{array / vector}}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{by_col}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3\\\\\n        4 & 2 & 7\\\\\n        3 & 2 & 8\\\\\n        1 & 1 & 3\\\\\n        5 & 2 & 9\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (4)",
    "text": "UNIQUE(...) (4)\n\\[\n\\texttt{UNIQUE}\n\\left(\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        1 & 1 & 3 & 1\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}      \n    }^{\\textit{array / vector}}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\texttt{ FALSE }\n  }_{\\texttt{by_col}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{exactly_once}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sequence...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sequence...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "SEQUENCE(...) (1)",
    "text": "SEQUENCE(...) (1)\n\nSEQUENCE(...): Fungsi SEQUENCE memungkinkan Anda menghasilkan daftar angka yang berurutan dalam larik seperti \\({1, 2, 3, 4, \\dots}\\). 1\n\n=SEQUENCE(rows, [columns], [start], [step])\n\nHasil SEQUENCE(...) => numeric vector/array.\nNilai default argumen: columns <- 1, start <- 1, step <- 1.\n\nFungsi SEQUENCE, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sequence...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sequence...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "SEQUENCE(...) (2)",
    "text": "SEQUENCE(...) (2)\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    5\n  }_{\\texttt{rows}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        1\\\\\n        2\\\\\n        3\\\\\n        4\\\\\n        5\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    4\n  }_{\\texttt{columns}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        1   & 2  & 3    & 4\\\\\n        5   & 6  & 7    & 8\\\\\n        9   & 10 & 11   & 12\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sequence...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sequence...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "SEQUENCE(...) (3)",
    "text": "SEQUENCE(...) (3)\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    4\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{start}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        10 & 11 & 12 & 13\\\\\n        14 & 15 & 16 & 17\\\\\n        18 & 19 & 20 & 21\\\\\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    4\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{start}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{step}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        10 & 13 & 16 & 19\\\\\n        22 & 25 & 28 & 31\\\\\n        34 & 37 & 40 & 43\\\\\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#randarray...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#randarray...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "RANDARRAY(...) (1)",
    "text": "RANDARRAY(...) (1)\n\nRANDARRAY(...): Fungsi RANDARRAY menghasilkan larik angka acak. Anda dapat menentukan jumlah baris dan kolom yang akan diisi, nilai minimum dan maksimum, dan apakah fungsi mengembalikan bilangan bulat atau nilai desimal. 1\n\n=RANDARRAY([rows], [columns], [min], [max], [whole_number])\n\nNilai default argumen: rows <- 1, columns <- 1, min <- 0, max <- 1, whole_number <- FALSE.\nJika tidak diisi argumen maka hasil RANDARRAY() adalah bilangan real \\(\\mathbb{R}\\) acak dengan rentang \\([0, 1]\\).\n\nFungsi RANDARRAY, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#randarray...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#randarray...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "RANDARRAY(...) (2)",
    "text": "RANDARRAY(...) (2)\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        0.036290129\\\\\n        0.831941087\\\\\n        0.596526220\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{columns}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        0.950708256 & 0.044725252\\\\\n        0.111202134 & 0.34866703\\\\\n        0.119602266 & 0.792763221\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#randarray...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#randarray...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "RANDARRAY(...) (3)",
    "text": "RANDARRAY(...) (3)\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{min}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{max}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        5.033450196 & 7.903953859\\\\\n        7.918426053 & 6.750036234\\\\\n        7.926034250 & 3.596169723\\\\\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{min}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{max}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{whole_number}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        9 & 4\\\\\n        5 & 6\\\\\n        7 & 8\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sort...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sort...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "SORT(...) (1)",
    "text": "SORT(...) (1)\n\nSORT(...): Fungsi SORT mengurutkan konten rentang atau larik. 1\n\n=SORT(array, [sort_index], [sort_order], [by_col])\n\nNilai default argumen: sort_index <- 1, sort_order <- 1 (Ascending), by_col <- FALSE.\n\nFungsi SORT, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sort...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sort...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "SORT(...) (2)",
    "text": "SORT(...) (2)\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        2 & 3 & 1 & 2\\\\\n        3 & 2 & 4 & 4\\\\\n        4 & 2 & 3 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{sort_index}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        2 & 3 & 1 & 2\\\\\n        4 & 2 & 3 & 2\\\\\n        3 & 2 & 4 & 4\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sort...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sort...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "SORT(...) (3)",
    "text": "SORT(...) (3)\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{sort_index}}\n  ,\n  \\underbrace{\n    -1\n  }_{\\texttt{sort_order}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        3 & 2 & 4 & 4\\\\\n        4 & 2 & 3 & 2\\\\\n        2 & 3 & 1 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{sort_index}}\n  ,\n  \\underbrace{\n    1\n  }_{\\texttt{sort_order}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{by_col}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        4 & 3 & 4 & 2\\\\\n        1 & 2 & 2 & 3\\\\\n        3 & 4 & 2 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (1)",
    "text": "SORTBY(...) (1)\n\nSORTBY(...): Fungsi SORTBY mengurutkan konten rentang atau larik berdasarkan nilai dalam rentang atau larik yang terkait. 1\n\n=SORTBY(array, by_array1, [sort_order1], [by_array2], [sort_order2], ...)\n\nNilai default sort_order <- 1 (ascending).\nNilai by_array harus berupa vektor atau array 1 dimensi. Dan jenisnya harus sama dengan nilai by_array lainnya (tidak boleh berbeda dimensinya).\nJika diurutkan hanya berdasarkan satu array dan berdasarkan kolom/baris di dalam array tersebut, sebaiknya menggunakan SORT.\n\nFungsi SORTBY, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (2)",
    "text": "SORTBY(...) (2)\n\\[\n\\mathbf{A}\n=\n\\begin{bmatrix}\n  \\textrm{A} & \\textrm{BA} & \\textrm{CBBA}\\\\\n  \\textrm{B} & \\textrm{CB} & \\textrm{DCCB}\\\\\n  \\textrm{C} & \\textrm{DC} & \\textrm{EDDC}\\\\\n  \\textrm{D} & \\textrm{ED} & \\textrm{FEED}\\\\\n  \\textrm{E} & \\textrm{FE} & \\textrm{GFFE}\\\\\n  \\textrm{F} & \\textrm{GF} & \\textrm{IGGF}\\\\\n  \\textrm{G} & \\textrm{IG} & \\textrm{AIG}\n\\end{bmatrix},\n\\mathbf{c}_1\n=\n\\begin{bmatrix}\n  1\\\\\n  3\\\\\n  3\\\\\n  2\\\\\n  2\\\\\n  1\\\\\n  4\\\\\n\\end{bmatrix}\n,\n\\mathbf{c}_2\n=\n\\begin{bmatrix}\n  1\\\\\n  3\\\\\n  5\\\\\n  6\\\\\n  2\\\\\n  7\\\\\n  8\\\\\n\\end{bmatrix}\n\\]\n\\[\n\\mathbf{r}_1\n=\n\\begin{bmatrix}\n  3 & 1 & 1\n\\end{bmatrix}\n,\n\\mathbf{r}_2\n=\n\\begin{bmatrix}\n  7 & 1 & 3\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{SORTBY}(\n  \\mathbf{A}, \\mathbf{c}_1\n) \\lor\n\\texttt{SORTBY}(\n  \\mathbf{A},\n  \\mathbf{r}_1,\n  -1,\n)\n\\]\n\\[\n\\texttt{SORTBY}(\n  \\mathbf{A},\n  \\mathbf{c}_1,,\n  \\mathbf{c}_2,-1\n) \\lor\n\\texttt{SORTBY}(\n  \\mathbf{A},\n  \\mathbf{r}_2,-1,\n  \\mathbf{r}_1\n)\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (3)",
    "text": "SORTBY(...) (3)\n\\[\n\\mathbf{A}, \\mathbf{c}_1\n\\overbrace{\\longmapsto}^{\n  \\texttt{SORTBY}(\n    \\mathbf{A}, \\mathbf{c}_1\n  )\n}\n\\begin{bmatrix}\n  A & BA & CBBA\\\\\n  F & GF & IGGF\\\\\n  D & ED & FEED\\\\\n  E & FE & GFFE\\\\\n  B & CB & DCCB\\\\\n  C & DC & EDDC\\\\\n  G & IG & AIG\\\\\n\\end{bmatrix}\n,\n\\texttt{index} \\leftarrow\n\\begin{bmatrix}\n  1\\\\\n  6\\\\\n  4\\\\\n  5\\\\\n  2\\\\\n  3\\\\\n  7\\\\\n\\end{bmatrix}\n,\n\\texttt{SORT}(\\mathbf{c}_1) =\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  2\\\\\n  2\\\\\n  3\\\\\n  3\\\\\n  4\\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (4)",
    "text": "SORTBY(...) (4)\n\\[\n\\mathbf{A}, \\mathbf{c}_1, \\mathbf{c}_2\n\\overbrace{\\longmapsto}^{\n  \\texttt{SORTBY}(\n    \\mathbf{A}, \\mathbf{c}_1,, \\mathbf{c}_2, -1\n  )\n}\n\\begin{bmatrix}\n  F & GF & IGGF\\\\\n  A & BA & CBBA\\\\\n  D & ED & FEED\\\\\n  E & FE & GFFE\\\\\n  C & DC & EDDC\\\\\n  B & CB & DCCB\\\\\n  G & IG & AIG\\\\\n\\end{bmatrix}\n,\n\\texttt{index} \\leftarrow\n\\begin{bmatrix}\n  6\\\\\n  1\\\\\n  4\\\\\n  5\\\\\n  3\\\\\n  2\\\\\n  7\\\\\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{SORT}(\\mathbf{c}_1) =\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  2\\\\\n  2\\\\\n  3\\\\\n  3\\\\\n  4\\\\\n\\end{bmatrix}\n,\n\\texttt{SORT}(\\mathbf{c}_2, -1) =\n\\begin{bmatrix}\n  7\\\\\n  1\\\\\n  6\\\\\n  2\\\\\n  5\\\\\n  3\\\\\n  8\\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xlookup...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#xlookup...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "XLOOKUP(...) (1)",
    "text": "XLOOKUP(...) (1)\n\nXLOOKUP(...): Fungsi XLOOKUP mencari rentang atau array, lalu mengembalikan item yang terkait dengan kecocokan pertama yang ditemukannya. Jika tidak ada kecocokan, XLOOKUP dapat mengembalikan kecocokan terdekat (perkiraan). 1\n\n=XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])\nFungsi XLOOKUP, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xmatch...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#xmatch...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "XMATCH(...) (1)",
    "text": "XMATCH(...) (1)\n\nXMATCH(...): Fungsi XMATCH mengembalikan posisi relatif item dalam array atau rentang sel. 1\n\n=XMATCH(lookup_value, lookup_array, [match_mode], [search_mode])\nFungsi XMATCH, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "CONCAT(...) dan TEXTJOIN(...) (1)",
    "text": "CONCAT(...) dan TEXTJOIN(...) (1)\n\nCONCAT(...): Fungsi CONCAT menggabungkan teks dari beberapa rentang dan/atau string, tetapi tidak menyediakan argumen pemisah atau IgnoreEmpty. 1\n\n=CONCAT(text1, [text2], ...)\n\nTEXTJOIN(...): Fungsi TEXTJOIN menggabungkan teks dari beberapa rentang dan/atau string, serta menyertakan pemisah yang Anda tentukan antara tiap nilai teks yang akan digabungkan. Jika pemisah adalah string teks kosong, fungsi ini akan secara efektif menggabungkan rentang. 2\n\n=TEXTJOIN(delimiter, ignore_empty, text1, [text2], ...)\nFungsi CONCAT, Microsoft Support.Fungsi TEXTJOIN, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "CONCAT(...) dan TEXTJOIN(...) (2)",
    "text": "CONCAT(...) dan TEXTJOIN(...) (2)\n\nHal yang membedakan TEXTJOIN(...) dengan CONCAT(...) adalah argumen karakter diantara teks gabungan dengan kondisi ketika sel kosong. Nilai TEXTJOIN(...) === CONCAT(...) ketika argumen delimeter <- \"\" dan ignore_empty <- TRUE.\n\n\\[\n\\mathbf{T} =\n\\begin{bmatrix}\n  \\textrm{nama} &\n  \\textrm{saya} &\n  \\textrm{taruma}\\\\\n  1 &\n  \\textrm{pergi} &\n  3 \\\\\n  \\texttt{TRUE} &\n  100 &\n  \\texttt{FALSE}\\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "CONCAT(...) dan TEXTJOIN(...) (3)",
    "text": "CONCAT(...) dan TEXTJOIN(...) (3)\n\\[\n\\mathbf{T} =\n\\begin{bmatrix}\n  \\textrm{nama} &\n  \\textrm{saya} &\n  \\textrm{taruma}\\\\\n  1 &\n  \\textrm{pergi} &\n  3 \\\\\n  \\texttt{TRUE} &\n  100 &\n  \\texttt{FALSE}\\\\\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{CONCAT}(\\mathbf{T}) =\n\\textrm{namasayataruma1pergi3TRUE100FALSE}\n\\]\n\\[\n\\texttt{TEXTJOIN}(\\texttt{\"\"}, \\texttt{TRUE}, \\mathbf{T}) =\n\\textrm{namasayataruma1pergi3TRUE100FALSE}\n\\]\n\\[\n\\texttt{TEXTJOIN}(\\texttt{\" \"}, \\texttt{TRUE}, \\mathbf{T}) =\n\\textrm{nama saya taruma 1 pergi 3 TRUE 100 FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#ifs...-dan-minifs...",
    "href": "greenhorn/feidlambda-2/presentation.html#ifs...-dan-minifs...",
    "title": "Greenhorn:feidlambda II",
    "section": "IFS(...) dan MINIFS(...)",
    "text": "IFS(...) dan MINIFS(...)\n\nIFS(...): Fungsi IFS memeriksa apakah satu atau beberapa kondisi terpenuhi dan mengembalikan nilai yang sesuai dengan kondisi TRUE pertama. IFS dapat menggantikan beberapa pernyataan IF yang bertumpuk, dan jauh lebih mudah dibaca dengan beberapa kondisi. 1\n\n=IFS(logical_test1, value_if_true1, [logical_test2, value_if_true2], [logical_test3, value_if_true3], ..., value_if_false)\n\nMINIFS(...) / MAXIFS(...): Fungsi MINIFS mengembalikan nilai minimal di antara sel yang ditentukan oleh kumpulan persyaratan atau kriteria tertentu / Fungsi MAXIFS mengembalikan nilai maksimal di antara sel yang ditentukan oleh kumpulan persyaratan atau kriteria tertentu. 2 3\n\n=[MIN/MAX]IFS([min/max]_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)\nFungsi IFS, Microsoft Support.Fungsi MINIFS, Microsoft Support.Fungsi MAXIFS, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-if...",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-if...",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH IFS (IF(...))",
    "text": "CONTOH IFS (IF(...))\n\\[\n[-\\infty,70) \\Rightarrow \\text{C}\\\\\n[70,85) \\Rightarrow \\text{B}\\\\\n[85,\\infty) \\Rightarrow \\text{A}\n\\]\n=IF(\n  x < 70, \"C\", \n  IF(\n    x < 85, \"B\",\n    \"A\"\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-ifs...",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-ifs...",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH IFS (IFS(...))",
    "text": "CONTOH IFS (IFS(...))\n\\[\n[-\\infty,70) \\Rightarrow \\text{C}\\\\\n[70,85) \\Rightarrow \\text{B}\\\\\n[85,\\infty) \\Rightarrow \\text{A}\n\\]\n=IFS(\n  x < 70, \"C\", \n  x < 85, \"B\",\n  TRUE, \"A\"\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#switch...",
    "href": "greenhorn/feidlambda-2/presentation.html#switch...",
    "title": "Greenhorn:feidlambda II",
    "section": "SWITCH(...)",
    "text": "SWITCH(...)\n\nSWITCH(...): Fungsi SWITCH mengevaluasi satu nilai (disebut ekspresi) terhadap daftar nilai, dan mengembalikan hasil yang terkait dengan nilai cocok pertama. Jika tidak terdapat kecocokan, nilai default opsional mungkin akan dikembalikan. 1\n\n=SWITCH(expression, value1, result1, [default or value2, result2], ..., [default or value3, result3])\nFungsi SWITCH, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#let...",
    "href": "greenhorn/feidlambda-2/presentation.html#let...",
    "title": "Greenhorn:feidlambda II",
    "section": "LET(...)",
    "text": "LET(...)\n\nLET(...): Fungsi LET menetapkan nama ke hasil perhitungan. Ini memungkinkan menyimpan perhitungan menengah, nilai, atau menetapkan nama di dalam rumus. Nama ini hanya berlaku di dalam lingkup LET fungsi. Mirip dengan variabel dalam pemrograman, LET dilakukan melalui Excel rumus asli Anda. 1\n\n=LET(name1, name_value1, calculation_or_name2, [name_value2, calculation_or_name2], ..., calculation)\nFungsi LET, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH LET(...) dan SWITCH(...)",
    "text": "CONTOH LET(...) dan SWITCH(...)\n\\[\n\\text{A} \\Rightarrow 90,\n\\text{B} \\Rightarrow 80,\n\\text{C} \\Rightarrow 70,\n\\text{D} \\Rightarrow 60,\\\\\n\\notin \\{\\text{A}, \\text{B}, \\text{C}, \\text{D}\\} \\Rightarrow 20\n\\]\n=IFS(\n  C$2 = \"A\", 90,\n  C$2 = \"B\", 80,\n  C$2 = \"C\", 70,\n  C$2 = \"D\", 60,\n  TRUE, 20\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH LET(...) dan SWITCH(...)",
    "text": "CONTOH LET(...) dan SWITCH(...)\n\\[\n\\text{A} \\Rightarrow 90,\n\\text{B} \\Rightarrow 80,\n\\text{C} \\Rightarrow 70,\n\\text{D} \\Rightarrow 60,\\\\\n\\notin \\{\\text{A}, \\text{B}, \\text{C}, \\text{D}\\} \\Rightarrow 20\n\\]\n=LET(\n  data, C$2,\n  IFS(\n    data = \"A\", 90,\n    data = \"B\", 80,\n    data = \"C\", 70,\n    data = \"D\", 60,\n    TRUE, 20\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH LET(...) dan SWITCH(...)",
    "text": "CONTOH LET(...) dan SWITCH(...)\n\\[\n\\text{A} \\Rightarrow 90,\n\\text{B} \\Rightarrow 80,\n\\text{C} \\Rightarrow 70,\n\\text{D} \\Rightarrow 60,\\\\\n\\notin \\{\\text{A}, \\text{B}, \\text{C}, \\text{D}\\} \\Rightarrow 20\n\\]\n=LET(\n  data, C$2,\n  SWITCH(\n    data,\n    \"A\", 90,\n    \"B\", 80,\n    \"C\", 70,\n    \"D\", 60,\n    20\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#kasus-validasi",
    "href": "greenhorn/feidlambda-2/presentation.html#kasus-validasi",
    "title": "Greenhorn:feidlambda II",
    "section": "Kasus validasi",
    "text": "Kasus validasi\n\\[\nf : \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x}) = \\mathbf{y} = \\mathbf{x} + 2\n\\]\n\\[\n\\mathbf{x} \\in \\mathbb{R}, \\mathbf{y} \\in \\mathbb{R}\n\\]\n\\[\n\\mathbf{x}\n\\mapsto\n\\mathbf{x} + 2\n\\]\n\\[\n\\begin{equation}\n  \\mathbf{x}\n  \\mapsto\n  \\texttt{AND}\n  (\n    \\texttt{ISNUMBER}(\\mathbf{x})\n  )\n  =\n  \\begin{cases}\n    \\texttt{TRUE} & f : \\mathbf{x} \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n    \\texttt{FALSE} & \\textrm{return}\\ \\texttt{#VALUE!} \\\\\n    \\texttt{FALSE} & \\mathbf{x} \\mapsto g(\\mathbf{x}) = \\texttt{FILTER}(\\dots) \\mapsto \\\\\n    & f: g(\\mathbf{x}) \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n  \\end{cases}\n\\end{equation}\n\\]\n\n\\(\\mathbf{x}\\) akan dievaluasi terlebih dahulu dan di filter dengan memilih elemen yang berupa angka saja.\n\\(\\mathbf{x} \\mapsto \\mathbf{y}\\) dengan \\(y \\in \\mathbb{R}\\) dan \\(x \\in \\mathbb{?}\\)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula",
    "href": "greenhorn/feidlambda-2/presentation.html#formula",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng : \\mathbf{x} \\in \\mathbb{?} \\to \\mathbb{R}\n\\]\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-1",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-2",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-3",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  logical_isnumber, ISNUMBER(x),\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-4",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-4",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  logical_isnumber, ISNUMBER(x),\n  y, FILTER(x, logical_isnumber),\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-5",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-5",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  y, FILTER(x, ISNUMBER(x)),\n  y + 2\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-6",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-6",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  y, FILTER(x, ISNUMBER(x)),\n  y + 2\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#lambda-dan-udl",
    "href": "greenhorn/feidlambda-2/presentation.html#lambda-dan-udl",
    "title": "Greenhorn:feidlambda II",
    "section": "LAMBDA dan UDL",
    "text": "LAMBDA dan UDL\n\nLAMBDA(...): Gunakan fungsi LAMBDA untuk membuat fungsi kustom yang dapat digunakan kembali dan memanggilnya dengan nama yang mudah dikenali. Fungsi baru tersedia di seluruh buku kerja dan disebut seperti fungsi asli Excel. 1\n\n=LAMBDA(parameter1, [parameter2, parameter3, ...], calculation)\n\nUser Defined Lambda (UDL) sama halnya dengan User Defined Function (UDF) hanya spesifik pada penggunaan LAMBDA. UDF sendiri adalah fungsi yang dibuat oleh pengguna.\n\nFungsi LAMBDA, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#lambda-dan-let",
    "href": "greenhorn/feidlambda-2/presentation.html#lambda-dan-let",
    "title": "Greenhorn:feidlambda II",
    "section": "LAMBDA dan LET",
    "text": "LAMBDA dan LET\n\nLAMBDA dan LET biasanya digunakan bersamaan untuk memudahkan pembuatan UDL ataupun membaca/troubleshooting.\nLAMBDA berfungsi menerima input dan membungkusnya sebagai fungsi baru di Excel sebagai UDL.\nLET digunakan untuk melakukan perhitungan/kalkulasi setelah menerima input dari LAMBDA.\nJika UDL cukup sederhana, LET tidak perlu digunakan."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(parameter1, [parameter2, parameter3, ...], calculation)\n\nUntuk memudahkan membaca kode, buat baris baru diantara (...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(\n  parameter1, \n  [parameter2, parameter3, ...],\n  calculation\n)\n\nUbah calculation dengan LET(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(\n  parameter1, \n  [parameter2, parameter3, ...],\n  LET(\n    name1, value1,\n    [name2, value2, name3, value3, ...],\n    calculation\n  )\n)\n\nArgumen parameter yang berasal dari LAMBDA, dapat langsung digunakan di LET tanpa melakukan pendefinisian ulang."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(\n  parameter1, \n  parameter2,\n  parameter3,\n  LET(\n    name1, parameter1 + parameter2,\n    name2, parameter3 - name1\n    name1 / parameter2\n  )\n)\n\n\nparameter2 bisa langsung digunakan pada LET tanpa pendefinisian ulang."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#deskripsi-kasus",
    "href": "greenhorn/feidlambda-2/presentation.html#deskripsi-kasus",
    "title": "Greenhorn:feidlambda II",
    "section": "Deskripsi Kasus",
    "text": "Deskripsi Kasus\n\nMengurangi setiap elemen dari numeric vector (\\(\\mathbf{x}\\)) dengan setengah dari rata-ratanya (\\(\\frac{\\texttt{mean}(\\mathbf{x})}{2}\\)).\n\n\\[\nf : \\mathbf{x} \\in \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x}) =\n\\mathbf{x} - \\frac{\\overline{\\mathbf{x}}}{2}\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#fungsi-lambda",
    "href": "greenhorn/feidlambda-2/presentation.html#fungsi-lambda",
    "title": "Greenhorn:feidlambda II",
    "section": "Fungsi LAMBDA",
    "text": "Fungsi LAMBDA\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  parameter1, \n  [parameter2, parameter3, ...],\n  calculation\n)\n\nmenentukan input variabel untuk fungsi LAMBDA.\n\\(f(\\mathbf{x})\\) menunjukkan input fungsi \\(f\\) hanya vektor \\(\\mathbf{x}\\)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#input-lambda",
    "href": "greenhorn/feidlambda-2/presentation.html#input-lambda",
    "title": "Greenhorn:feidlambda II",
    "section": "input LAMBDA",
    "text": "input LAMBDA\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  calculation\n)\n\nKarena fungsi \\(f\\) memiliki perhitungan AVERAGE(...), yang sebaiknya disimpan di variabel sementara, maka diperlukan kalkulasi menggunakan LET(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menggunakan-let",
    "href": "greenhorn/feidlambda-2/presentation.html#menggunakan-let",
    "title": "Greenhorn:feidlambda II",
    "section": "Menggunakan LET",
    "text": "Menggunakan LET\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    name1, value1,\n    [name2, value2, name3, value3, ...],\n    calculation\n  )\n)\n\nKarena pada persamaan asli \\(f\\) menggunakan simbol \\(\\mathbf{x}\\), bisa dilakukan assignment / pendefinisian berupa x <- vector."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#argumen-redundant-berulang",
    "href": "greenhorn/feidlambda-2/presentation.html#argumen-redundant-berulang",
    "title": "Greenhorn:feidlambda II",
    "section": "Argumen redundant / berulang",
    "text": "Argumen redundant / berulang\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    x, vector,\n    ..., ...,\n    calculation\n  )\n)\n\nx <- vector merupakan argumen yang tidak perlu (redundant / berulang) dikarenakan tidak ada modifikasi pada input vector.\nSelain itu, pada proses pengembangan LAMBDA lebih baik menggunakan nama variabel yang mudah diingat atau dipahami."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#perhitungan-dalam-fungsi-let",
    "href": "greenhorn/feidlambda-2/presentation.html#perhitungan-dalam-fungsi-let",
    "title": "Greenhorn:feidlambda II",
    "section": "Perhitungan dalam fungsi LET",
    "text": "Perhitungan dalam fungsi LET\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    ..., ...,\n    calculation\n  )\n)\n\nNilai rata-rata bisa disimpan sebagai variabel avg.\n\navg <- AVERAGE(vector)\n\nVariabel halfavg menyatakan nilai setengah dari rata-rata vektor.\n\nhalfavg <- avg / 2\n\nHasil akhir dapat disimpan sebagai variabel result.\n\nresult <- vector - halfavg"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#mengisi-hasil-dari-lambda",
    "href": "greenhorn/feidlambda-2/presentation.html#mengisi-hasil-dari-lambda",
    "title": "Greenhorn:feidlambda II",
    "section": "Mengisi hasil dari LAMBDA",
    "text": "Mengisi hasil dari LAMBDA\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    result, vector - halfavg,\n    ...\n  )\n)\n\nFungsi LAMBDA ini masih belum mengeluarkan hasil atau return dari fungsinya.\nPada argumen terakhir LET disampaikan kembali hasil yang diperoleh dari seluruh perhitungan. Yaitu result."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menghindari-pendefinisian-berulang",
    "href": "greenhorn/feidlambda-2/presentation.html#menghindari-pendefinisian-berulang",
    "title": "Greenhorn:feidlambda II",
    "section": "Menghindari pendefinisian berulang",
    "text": "Menghindari pendefinisian berulang\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    result, vector - halfavg,\n    result\n  )\n)\n\nPada baris ke-6 dan ke-7 bisa dibuat lebih sederhana menjadi satu baris dan langsung memberikan return atau hasil dari fungsi LAMBDA."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-akhir",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-akhir",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula akhir",
    "text": "Formula akhir\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)\n\nFungsi LAMBDA sudah lengkap dan bisa langsung digunakan."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#rekap",
    "href": "greenhorn/feidlambda-2/presentation.html#rekap",
    "title": "Greenhorn:feidlambda II",
    "section": "Rekap",
    "text": "Rekap\n\\[\nf : \\mathbf{x} \\in \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-1",
    "href": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Menggunakan formula di Excel (1)",
    "text": "Menggunakan formula di Excel (1)\n\\[\nf : \\mathbf{x} \\in \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)\n\nSalin formula diatas dan simpan sebagai fungsi bernama HALFAVG(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-2",
    "href": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Menggunakan formula di Excel (2)",
    "text": "Menggunakan formula di Excel (2)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-input-1",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-input-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi input (1)",
    "text": "Validasi input (1)\n\\[\ng : \\mathbf{y} \\in \\mathbb{?} \\to \\mathbb{R}\n\\]\n\\[\n\\mathbb{y}_{\\textit{filtered}} \\leftarrow \\text{VALIDASI}(\\mathbf{y})\n\\]\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    ...,...,\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-input-2",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-input-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi input (2)",
    "text": "Validasi input (2)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    avg, AVERAGE(vector_filtered),\n    halfavg, avg / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#refactoring-1",
    "href": "greenhorn/feidlambda-2/presentation.html#refactoring-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Refactoring (1)",
    "text": "Refactoring (1)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    avg, AVERAGE(vector_filtered),\n    halfavg, avg / 2,\n    vector_filtered - halfavg\n  )\n)\n\nRefactoring merupakan perubahan dari kode program yang sudah ada tanpa mengubah hasil dari program tersebut.\nvariabel avg bisa langsung diterapkan pada variabel halfavg."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#refactoring-2",
    "href": "greenhorn/feidlambda-2/presentation.html#refactoring-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Refactoring (2)",
    "text": "Refactoring (2)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-1",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (1)",
    "text": "Optional argument (1)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n\\[\n\\begin{equation}\n  n =\n  \\begin{cases}\n    \\dots & \\mathbf{y}, n = 2 \\mapsto g(\\mathbf{y}, 2) = f(\\mathbf{y}_{\\textit{filtered}})\\\\\n    n & \\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n  \\end{cases}\n\\end{equation}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-2",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (2)",
    "text": "Optional argument (2)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-3",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (3)",
    "text": "Optional argument (3)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  ...,\n  LET(\n    ...,...,\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-4",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-4",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (4)",
    "text": "Optional argument (4)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  [n],\n  LET(\n    ...,...,\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / n,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-5",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-5",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (5)",
    "text": "Optional argument (5)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  [n],\n  LET(\n    n, IF(ISOMITTED(n), 2, n),\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / n,\n    vector_filtered - halfavg\n  )\n)\n\\[\n\\begin{equation}\n  n \\mapsto \\texttt{ISOMITTED}(n) =\n  \\begin{cases}\n    \\texttt{TRUE} & n \\leftarrow 2 \\\\\n    \\texttt{FALSE} & n \\leftarrow n\n  \\end{cases}\n\\end{equation}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-akhir-1",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-akhir-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula Akhir",
    "text": "Formula Akhir\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  [n],\n  LET(\n    n, IF(ISOMITTED(n), 2, n),\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / n,\n    vector_filtered - halfavg\n  )\n)\n\nFormula tersebut disimpan sebagai HALFAVGN di Formulas Name Manager.\nSintaksnya =HALFAVGN(vector, [n]).\n=HALFAVGN(D5:D10) (maka \\(n=2\\)).\n=HALFAVGN(D5#, 4) (maka \\(n=4\\))."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#pengenalan-advanced-formula-environment-afe",
    "href": "greenhorn/feidlambda-2/presentation.html#pengenalan-advanced-formula-environment-afe",
    "title": "Greenhorn:feidlambda II",
    "section": "Pengenalan Advanced Formula Environment (AFE)",
    "text": "Pengenalan Advanced Formula Environment (AFE)\n\nExcel add-ins yang memudahkan mengatur kumpulan formula pada lembar kerja.\nAlternatif Formulas Name Manager.\nMemiliki fitur syntax highlighting dan shortcut umum untuk coding.\nDapat import UDL hasil dari orang lain menggunakan GitHub Gist."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1",
    "href": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Demonstrasi menggunakan AFE (1)",
    "text": "Demonstrasi menggunakan AFE (1)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1-1",
    "href": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Demonstrasi menggunakan AFE (1)",
    "text": "Demonstrasi menggunakan AFE (1)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#daftar-fungsi-yang-dibahas-di-feidlambda-iii",
    "href": "greenhorn/feidlambda-2/presentation.html#daftar-fungsi-yang-dibahas-di-feidlambda-iii",
    "title": "Greenhorn:feidlambda II",
    "section": "Daftar fungsi yang dibahas di feidlambda III",
    "text": "Daftar fungsi yang dibahas di feidlambda III\n\n\nFungsi vektorisasi SCAN, MAP, REDUCE.\nTransformasi kolom dengan TOCOL, TOROW, WRAPCOLS, WRAPROWS.\nMenggabungkan array dengan VSTACK dan HSTACK\nManipulasi array dengan DROP, EXPAND.\nMemilih kolom/baris dengan CHOOSECOLS dan CHOOSEROWS, TAKE\nFungsi teks TEXTAFTER, TEXTBEFORE, TEXTSPLIT, VALUETOTEXT, ARRAYTOTEXT.\nIterasi dengan BYCOL dan BYROW,"
  },
  {
    "objectID": "greenhorn/feidlambda-2/index.html",
    "href": "greenhorn/feidlambda-2/index.html",
    "title": "feidlambda II",
    "section": "",
    "text": "Topik Pembahasan:\n\nReview Daftar Istilah\nEksplorasi tentang Logical\nDynamic Array Formula\nFungsi Baru dari Excel 2019 dan 2021\nUser Defined LAMBDA (UDL)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "feidlambda",
    "section": "",
    "text": "\\(\\text{fe}\\hat{i}\\text{d} \\textbf{l} \\lambda \\text{m} \\textsf{b} \\texttt{d} \\bigtriangleup\\)\n\n\n\n\n\n\n\nDalam Pengembangan\n\n\n\nSaat ini feidlambda (koleksi LAMBDA) masih dalam tahap pengembangan. Untuk lebih jelasnya bisa membaca Public Roadmap fiakodev Q4 2022.\n\n\n\n\n\n\n\n\nOfficial GIST feidlambda\n\n\n\nGIST feidlambda v0.3\n\nv0.3 | v0.2 | v0.1 | panduan | source code"
  }
]