[
  {
    "objectID": "index.html#official-gist",
    "href": "index.html#official-gist",
    "title": "feidlambda",
    "section": "OFFICIAL GIST",
    "text": "OFFICIAL GIST\n\nfeidlambda v0.4.x\nhttps://gist.github.com/taruma/b4df638ecb7af48ab63691951481d6b2\n\n\nfeidmath v0.1.x\nhttps://gist.github.com/taruma/8b0978227dffbee50c3a9d56e31d34f3"
  },
  {
    "objectID": "docs/penggunaan-v1.html",
    "href": "docs/penggunaan-v1.html",
    "title": "Instalasi feidlambda (outdated)",
    "section": "",
    "text": "AFE 1.1+\n\n\n\nDengan diperbaruinya versi AFE menjadi 1.1+, terdapat beberapa perubahan cara dalam melakukan import feidlambda. Perubahan berupa:\n\nHarus dilakukan instalasi ulang untuk add-ins Advanced Formula Environment.\nFitur terbaru AFE 1.1 bisa dilihat pada README AFE.\nSaat import module melalui gist, namespace modul tidak boleh memiliki karakter titik (.), sehingga yang sebelumnya feid.utils menjadi feid_utils. Perubahan ini akan dibarengi dengan pembaruan versi feidlambda 0.3.x."
  },
  {
    "objectID": "docs/penggunaan-v1.html#advanced-formula-environment",
    "href": "docs/penggunaan-v1.html#advanced-formula-environment",
    "title": "Instalasi feidlambda (outdated)",
    "section": "1 Advanced Formula Environment",
    "text": "1 Advanced Formula Environment\nInstall add-ins Advanced Formula Environment dari menu Insert > Get Add-ins > Cari Advanced Formula Environment (AFE).\n\n\n\n\nMenambahkan Advanced Formula Environment Add-ins"
  },
  {
    "objectID": "docs/penggunaan-v1.html#import-menggunakan-afe",
    "href": "docs/penggunaan-v1.html#import-menggunakan-afe",
    "title": "Instalasi feidlambda (outdated)",
    "section": "2 Import menggunakan AFE",
    "text": "2 Import menggunakan AFE\nSetelah AFE terpasang di Microsoft Excel, lakukan import dengan membuka AFE melalui Home > Advanced Formula Environment > Import.\n\n\n\n\nMelakukan import di AFE"
  },
  {
    "objectID": "docs/penggunaan-v1.html#salin-github-gist-url",
    "href": "docs/penggunaan-v1.html#salin-github-gist-url",
    "title": "Instalasi feidlambda (outdated)",
    "section": "3 Salin Github Gist URL",
    "text": "3 Salin Github Gist URL\nIsi “Github Gist URL” dengan link koleksi lambda yang tersedia. Checklist ✅ bagian “Add formulas to new namespace” dan isi namespace dengan nama koleksi (contoh: feid.utils).\n\n\n\n\n\n\nLakukan langkah import (2-3) untuk setiap koleksi yang ingin ditambahkan.\n\n\n\n\n\n\nIsi GitHub Gist URL dan Namespace"
  },
  {
    "objectID": "docs/penggunaan-v1.html#sync-formula",
    "href": "docs/penggunaan-v1.html#sync-formula",
    "title": "Instalasi feidlambda (outdated)",
    "section": "4 Sync formula",
    "text": "4 Sync formula\nSetelah import seluruh koleksi yang digunakan, lakukan synchronize yang bertujuan menyamakan nama pada Formula/Excel Name Manager.\n\n\n\n\n\n\nJika muncul peringatan mengenai hidden sheets, pilih “Allow …”.\n\n\n\n\n\n\nSynchronize AFE"
  },
  {
    "objectID": "docs/penggunaan-v1.html#gunakan-koleksi-lambda",
    "href": "docs/penggunaan-v1.html#gunakan-koleksi-lambda",
    "title": "Instalasi feidlambda (outdated)",
    "section": "5 Gunakan koleksi lambda",
    "text": "5 Gunakan koleksi lambda\nSelesai sync, fungsi lambda bisa langsung digunakan.\n\n\n\n\nGunakan koleksi lambda yang telah di-import"
  },
  {
    "objectID": "docs/install-afe.html",
    "href": "docs/install-afe.html",
    "title": "Instalasi feidlambda",
    "section": "",
    "text": "Panduan ini untuk Advanced Formula Environment v1.1."
  },
  {
    "objectID": "docs/install-afe.html#advanced-formula-environment",
    "href": "docs/install-afe.html#advanced-formula-environment",
    "title": "Instalasi feidlambda",
    "section": "1 Advanced Formula Environment",
    "text": "1 Advanced Formula Environment\nInstall add-ins Advanced Formula Environment dari menu Insert > Get Add-ins > Cari Advanced Formula Environment (AFE).\n\n\n\n\nMenambahkan Advanced Formula Environment Add-ins"
  },
  {
    "objectID": "docs/install-afe.html#import-menggunakan-afe",
    "href": "docs/install-afe.html#import-menggunakan-afe",
    "title": "Instalasi feidlambda",
    "section": "2 Import menggunakan AFE",
    "text": "2 Import menggunakan AFE\nSetelah AFE terpasang di Microsoft Excel, lakukan import dengan membuka AFE melalui Formula > Advanced Formula Environment > Import.\n\n\n\n\nMelakukan import di AFE"
  },
  {
    "objectID": "docs/install-afe.html#salin-github-gist-url",
    "href": "docs/install-afe.html#salin-github-gist-url",
    "title": "Instalasi feidlambda",
    "section": "3 Salin Github Gist URL",
    "text": "3 Salin Github Gist URL\nIsi “Github Gist URL” dengan link koleksi lambda yang tersedia. Checklist ✅ bagian “Add formulas to new module” dan isi nama module dengan nama koleksi (contoh: feid).\n\n\n\nIsi GitHub Gist URL dan nama module"
  },
  {
    "objectID": "docs/install-afe.html#save-sync-module",
    "href": "docs/install-afe.html#save-sync-module",
    "title": "Instalasi feidlambda",
    "section": "4 Save / Sync module",
    "text": "4 Save / Sync module\nSetelah import seluruh koleksi yang digunakan dan berhasil, lakukan saving (sync) yang bertujuan untuk menerapkan module ke lembar kerja Excel. Shortcut untuk save yaitu Ctrl + S.\n\n\n\nSave / Apply module ke lembar kerja"
  },
  {
    "objectID": "docs/install-afe.html#gunakan-koleksi-lambda",
    "href": "docs/install-afe.html#gunakan-koleksi-lambda",
    "title": "Instalasi feidlambda",
    "section": "5 Gunakan koleksi lambda",
    "text": "5 Gunakan koleksi lambda\nSelesai save, fungsi feidlambda bisa langsung digunakan.\n\n\n\n\nGunakan koleksi lambda yang telah di-import"
  },
  {
    "objectID": "docs/install-afe.html#baca-dokumentasi-feidlambda",
    "href": "docs/install-afe.html#baca-dokumentasi-feidlambda",
    "title": "Instalasi feidlambda",
    "section": "6 Baca dokumentasi feidlambda",
    "text": "6 Baca dokumentasi feidlambda\nDokumentasi feidlambda versi terbaru (v0.4) bisa baca di halaman feidlambda (latest). API atau struktur LAMBDA sudah dibuat konsisten sejak versi v0.3+. Panduan migrasi dari v0.2 ke v0.3 bisa baca di halaman Migrasi feidlambda v0.2 ke v0.3.\nJangan lupa juga untuk membaca Daftar istilah yang digunakan dalam pada dokumentasi dan pengembangan feidlambda."
  },
  {
    "objectID": "docs/glossary.html",
    "href": "docs/glossary.html",
    "title": "Daftar Istilah",
    "section": "",
    "text": "NUMERIC\nAngka / numerik. Numerik yang dimaksud adalah bilangan real: \\(\\mathbb{R} = \\{-1, 0, 1, \\pi, 2.3212, -1.2, \\frac{2}{3}, \\dots\\}\\). Bilangan complex \\(\\mathbb{C}\\) tidak termasuk.\n\n\nLOGICAL\nTRUE atau FALSE. Dapat dikenal juga sebagai boolean. Nilai logical bisa juga direpresentasikan dalam bentuk numerik dengan 0 berarti FALSE, sedangkan nilai numerik selain 0 dianggap TRUE.\n\n\nTEXT\nKarakter atau teks. Dikenal juga sebagai string.\n\n\nCELL\nSel.\n\n\n\n\n\n\n\n(a) Cell (Excel)\n\n\n\n\n\n\n\n(b) Cell (Ilustrasi)\n\n\n\n\nGambar 1: Cell\n\n\n\n\nRANGE\nRentang yang terdiri dari lebih dari satu sel.\n\n\n\n\n\n\n\n(a) Range (Excel)\n\n\n\n\n\n\n\n(b) Range (Ilustrasi)\n\n\n\n\nGambar 2: Range\n\n\n\n\nVECTOR\nRange yang memiliki 1 dimensi.\n\n\n\n\n\n\n\n(a) Vector (Excel)\n\n\n\n\n\n\n\n(b) Vector (Ilustrasi)\n\n\n\n\nGambar 3: Vector\n\n\n\n\nARRAY\nRange yang memiliki 1 dimensi atau 2 dimensi. Untuk membedakan antara 1 dimensi dan 2 dimensi, istilah array digunakan untuk range yang memiliki 2 dimensi. Meskipun array di excel bisa merepresentasikan range 1 dimensi atau range 2 dimensi.\n\n\n\n\n\n\n\n(a) Array (Excel)\n\n\n\n\n\n\n\n(b) Array (Ilustrasi)\n\n\n\n\nGambar 4: Array\n\n\n\n\nTABLE\nArray yang memiliki header dalam format tabel.\n\n\n\n\n\n\n\n(a) Table (Excel)\n\n\n\n\n\n\n\n(b) Table (Ilustrasi)\n\n\n\n\nGambar 5: Table\n\n\n\n\nLOGICAL VECTOR / LOGICAL ARRAY\nVector atau array yang berisikan nilai TRUE atau FALSE.\n\n\n\n\n\n\n\n(a) Logical Vector (Excel)\n\n\n\n\n\n\n\n(b) Logical Vector (Ilustrasi)\n\n\n\n\nGambar 6: Logical Vector\n\n\n\n\nNUMERIC VECTOR / NUMERIC ARRAY\nVector atau array yang berisikan nilai numerik.\n\n\n\n\n\n\n\n(a) Numeric Vector (Excel)\n\n\n\n\n\n\n\n(b) Numeric Vector (Ilustrasi)\n\n\n\n\nGambar 7: Numeric Vector\n\n\n\n\nTEXT VECTOR / TEXT ARRAY\nVector atau array yang berisikan nilai text atau string.\n\n\nROW VECTOR\nVector yang melebar ke samping atau berupa baris.\n\n\n\nGambar 8: Row Vector (Excel)\n\n\n\n\nCOLUMN VECTOR\nVector yang memanjang ke bawah atau berupa kolom.\n\n\n\nGambar 9: Column Vector (Excel)\n\n\n\n\nDYNAMIC ARRAY\nLarik dinamis adalah kumpulan nilai / sel yang merupakan satu kesatuan. Dapat berupa vector (1D) atau array (2D).\n\n\n\n\n\n\n\n(a) Column Vector Biasa\n\n\n\n\n\n\n\n(b) Dynamic Array pada Column Vector\n\n\n\n\n\n\n\n(c) Column Vector (Dynamic Array)\n\n\n\n\nGambar 10: Dynamic Array (Vector)\n\n\n\n\n\n\n\n\n\n(a) Array Biasa\n\n\n\n\n\n\n\n(b) Dynamic Array pada Array\n\n\n\n\n\n\n\n(c) Array (Dynamic Array)\n\n\n\n\nGambar 11: Dynamic Array (Array)\n\n\n\n\nDYNAMIC ARRAY FORMULA / FUNCTION\nFormula atau fungsi yang mengeluarkan hasil lebih dari satu sel (vector / array) dalam bentuk dynamic array.\nPersamaan yang termasuk dynamic array formula antara lain: =POWER(), =ABS(), =ROUNDUP(), dll. Yang perlu diingat bahwa formula dynamic array mampu menghasilkan nilai dalam bentuk vector atau array sesuai jenis nilai yang dimasukkan.\n\n\n\n\n\n\n\n(a) Formula Biasa\n\n\n\n\n\n\n\n(b) Dynamic Array Formula\n\n\n\n\nGambar 12: Dynamic Array Formula\n\n\n\n\nSCALAR FORMULA / FUNCTION\nFormula atau fungsi yang mengluarkan hasil satu sel atau scalar (satu nilai)."
  },
  {
    "objectID": "docs/install.html",
    "href": "docs/install.html",
    "title": "Instalasi koleksi feidlambda",
    "section": "",
    "text": "Penting\n\n\n\nSejak April 2023, add-ins Advanced Formula Environment menjadi bagian fitur dari add-ins Excel Labs. Excel Labs sendiri adalah add-ins yang menyediakan fitur eksperimental oleh tim Microsoft Excel.\nPanduan ini untuk instalasi dan penggunaan Excel Labs: Advanced Formula Environment."
  },
  {
    "objectID": "docs/install.html#sec-excel-labs",
    "href": "docs/install.html#sec-excel-labs",
    "title": "Instalasi koleksi feidlambda",
    "section": "1 Excel Labs",
    "text": "1 Excel Labs\nExcel Labs merupakan add-ins berisikan fitur eksperimental oleh tim Microsoft Excel. Pada add-ins ini tersedia Advanced Formula Environment untuk memudahkan pengembangan dan penggunaan fungsi LAMBDA atau manipulasi formula di dalam Microsoft Excel. Add-ins tersebut wajib dipasang untuk dapat menggunakan koleksi feidlambda. Fitur LABS.GENERATIVEAI, saat ini tidak digunakan dalam penggunaan feidlambda.\n\nInstall add-ins Excel Labs dari menu Insert > Get Add-ins > Cari Excel Labs (AFE).\n\n\n\n\n\nMenambahkan Excel Labs Add-ins"
  },
  {
    "objectID": "docs/install.html#sec-afe",
    "href": "docs/install.html#sec-afe",
    "title": "Instalasi koleksi feidlambda",
    "section": "2 Advanced Formula Environment",
    "text": "2 Advanced Formula Environment\nAdvanced Formula Environment (AFE) adalah add-in untuk Excel yang memungkinkan Anda melihat, memformat dan mengedit rumus atau fungsi Excel. Sejak April 2023, add-in Advanced Formula Environment tergabung dalam satu add-ins bernama Excel Labs.\n\nUntuk memulai penggunaan AFE, buka Excel Labs melalui menu ribbon Home > Excel Labs.\nPada feature gallery, terdapat ada dua fitur yaitu Advanced Formula Environment dan LABS.GENERATIVEAI function.\nCentang “Remember this choice” kemudian buka AFE dengan mengklik “Open” disamping tulisan AFE.\n\n\n\n\n\nMembuka Advanced Formula Environment (AFE)\n\n\n\nFeature gallery bisa dibuka melalui menu burger dan memilih feature gallery."
  },
  {
    "objectID": "docs/install.html#sec-import-afe",
    "href": "docs/install.html#sec-import-afe",
    "title": "Instalasi koleksi feidlambda",
    "section": "3 Import menggunakan AFE",
    "text": "3 Import menggunakan AFE\nSetelah AFE terpasang di Microsoft Excel, lakukan import dengan membuka AFE melalui Home > Excel Labs > (AFE) > Modules > Import.\n\n\n\n\nMelakukan import di AFE"
  },
  {
    "objectID": "docs/install.html#sec-copy-to-gist",
    "href": "docs/install.html#sec-copy-to-gist",
    "title": "Instalasi koleksi feidlambda",
    "section": "4 Salin Github Gist URL",
    "text": "4 Salin Github Gist URL\nIsi “Github Gist URL” dengan link koleksi lambda yang tersedia. Checklist ✅ bagian “Add formulas to new module” dan isi nama module dengan nama koleksi (contoh: feid).\n\n\n\nIsi GitHub Gist URL dan nama module"
  },
  {
    "objectID": "docs/install.html#sec-sync",
    "href": "docs/install.html#sec-sync",
    "title": "Instalasi koleksi feidlambda",
    "section": "5 Save / Sync module",
    "text": "5 Save / Sync module\nSetelah import seluruh koleksi yang digunakan dan berhasil, lakukan saving (sync) yang bertujuan untuk menerapkan module ke lembar kerja Excel. Shortcut untuk save yaitu Ctrl + S.\n\n\n\nSave / Apply module ke lembar kerja"
  },
  {
    "objectID": "docs/install.html#sec-using",
    "href": "docs/install.html#sec-using",
    "title": "Instalasi koleksi feidlambda",
    "section": "6 Gunakan koleksi lambda",
    "text": "6 Gunakan koleksi lambda\nSelesai save, fungsi feidlambda bisa langsung digunakan.\n\n\n\n\nGunakan koleksi lambda yang telah di-import"
  },
  {
    "objectID": "docs/install.html#baca-dokumentasi-feidlambda",
    "href": "docs/install.html#baca-dokumentasi-feidlambda",
    "title": "Instalasi koleksi feidlambda",
    "section": "7 Baca dokumentasi feidlambda",
    "text": "7 Baca dokumentasi feidlambda\nDokumentasi feidlambda versi terbaru (v0.4) bisa baca di halaman feidlambda (latest). API atau struktur LAMBDA sudah dibuat konsisten sejak versi v0.3+. Panduan migrasi dari v0.2 ke v0.3 bisa baca di halaman Migrasi feidlambda v0.2 ke v0.3.\nJangan lupa juga untuk membaca daftar istilah yang digunakan dalam pada dokumentasi dan pengembangan feidlambda."
  },
  {
    "objectID": "docs/lambda-style-guide.html",
    "href": "docs/lambda-style-guide.html",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "",
    "text": "Catatan\n\n\n\nPanduan ini dibuat dengan bantuan chatGPT (GPT-4) dengan penyesuaian oleh penulis."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-rec-device",
    "href": "docs/lambda-style-guide.html#sec-rec-device",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "💻 Perangkat",
    "text": "💻 Perangkat\nDalam mengembangkan fungsi LAMBDA dan mengikuti panduan ini berikut daftar perangkat dan add-ins yang digunakan dalam pengembangan LAMBDA:\n\nMicrosoft Excel 365: Pastikan menggunakan Microsoft Excel 365, karena saat ini, fungsi LAMBDA hanya tersedia di Microsoft Excel 365.\nExcel Labs add-ins: Fitur Advanced Formula Environment yang tersedia di add-ins ini direkomendasikan sebagai standar editor untuk pengembangan fungsi LAMBDA. Untuk panduan instalasi, silakan lihat panduan instalasi.\n\nFungsi LAMBDA dan beberapa fungsi dynamic array terbaru lainnya juga tersedia di Microsoft Excel for Web. Oleh karena itu, jika Anda belum berlangganan, Anda dapat bereksperimen dengan fungsi LAMBDA melalui Microsoft Excel for Web."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-rec-knowledge",
    "href": "docs/lambda-style-guide.html#sec-rec-knowledge",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🧠 Pengetahuan",
    "text": "🧠 Pengetahuan\nFungsi LAMBDA dapat diterapkan oleh pengguna Microsoft Excel dengan berbagai tingkat keahlian, mulai dari pemula hingga mahir. Tingkat pengetahuan yang dibutuhkan dalam pengembangan fungsi LAMBDA di Microsoft Excel tergantung pada kompleksitas fungsi yang akan dikembangkan. Berikut ini adalah pengetahuan atau pemahaman yang diperlukan untuk memahami fungsi LAMBDA dan menerapkan FIAKO LAMBDA Style Guide:\n\nPemahaman dasar tentang Microsoft Excel: Pastikan memahami cara menggunakan sel, baris, kolom, serta mengedit rumus. Anda bisa belajar lebih lanjut di Excel untuk Pemula.\nDasar-dasar bahasa pemrograman: Kuasai konsep dasar pemrograman seperti variabel, fungsi, dan logika bersyarat. Pelajari lebih lanjut di Pemrograman Dasar.\nFungsi Excel yang umum: Kembangkan kemampuan untuk menggunakan dan memahami fungsi Excel seperti SUM, AVERAGE, VLOOKUP, IF, AND, OR, INDEX, dan MATCH. Lihat Fungsi Excel yang Harus Diketahui.\nDasar-dasar penanganan kesalahan dalam Excel: Pahami cara menggunakan fungsi IFERROR dan IFNA untuk mengatasi kesalahan. Pelajari lebih lanjut di Penanganan Kesalahan di Excel.\nFungsi LAMBDA: Mengerti tujuan dan cara kerja fungsi LAMBDA dalam menciptakan fungsi kustom di Microsoft Excel. Baca lebih lanjut di Pengantar Fungsi LAMBDA.\nPengetahuan tentang Dynamic Array di Microsoft Excel: Kuasai konsep dan cara kerja fitur Dynamic Array dalam mengolah data berbentuk array. Informasi lebih lanjut dapat ditemukan di Perilaku Dynamic Arrays dan spilled array.\n\nDengan memenuhi prasyarat di atas, diharapkan untuk lebih siap untuk menggunakan fungsi LAMBDA dan memahami panduan ini secara efisien dan efektif. Pastikan untuk menggunakan alat yang sesuai dan menguasai pengetahuan yang dibutuhkan guna mengoptimalkan proses pengembangan fungsi LAMBDA dan penerapan panduan ini."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-rec-adv-formula-env",
    "href": "docs/lambda-style-guide.html#sec-rec-adv-formula-env",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🧩 Advanced Formula Environment (Add-ins Excel Lab)",
    "text": "🧩 Advanced Formula Environment (Add-ins Excel Lab)\nDalam panduan ini, disarankan untuk menggunakan Advanced Formula Environment (AFE) dari Excel Labs sebagai editor saat mengembangkan fungsi LAMBDA. AFE sangat membantu pengguna dalam mengembangkan dan mengelola fungsi LAMBDA. Berikut beberapa fitur unggulan AFE1:\n\nMelihat, memformat, dan mengedit rumus yang telah didefinisikan dalam kisi dengan bilah rumus yang lebih canggih.\nMendefinisikan dan mengedit fungsi yang diberi nama, rentang, dan rumus yang dapat disinkronkan dengan Manajer Nama.\nMembuat koleksi fungsi yang diberi nama, disebut modul, yang didefinisikan sebagai kode dan disimpan sebagai bagian dari Buku Kerja.\nMengimpor modul LAMBDA secara cepat langsung dari GitHub Gist.\n\nAFE juga mendukung fitur-fitur tambahan seperti autocomplete, refactoring, formatting, dan lainnya, yang akan memudahkan Anda dalam proses pengembangan fungsi LAMBDA. Pastikan Anda menggunakan AFE untuk meningkatkan efisiensi dan kenyamanan saat mengikuti panduan ini.\nDalam menggunakan fungsi LAMBDA, langkah yang umum digunakan adalah menuliskan fungsi LAMBDA pada Formula Name Manager. Akan tetapi, untuk panduan ini pengembangan fungsi LAMBDA akan menggunakan AFE. Semenjak AFE v1.1+, fungsi LAMBDA disimpan dalam dokumen excel dan muncul di Formula Name Manager ketika dilakukan sinkronisasi. Hanya saja, sifatnya satu arah, yaitu fungsi LAMBDA yang ditulis di AFE akan tersimpan juga pada Formula Name Manager, tapi tidak sebaliknya. Jadi fungsi LAMBDA yang dikembangkan secara manual di Formula Name Manager tidak akan muncul di AFE.\nPada umumnya pada tutorial formula lambda ditulis sebagai berikut:\n=LAMBDA(x, y, z, x+y+z)\nkemudian formula tersebut disimpan dalam Formula Name Manager dengan namanya, misalkan fungsi JUMLAH. Akan tetapi, dengan menggunakan AFE sebagai editor, dalam panduan ini penulisannya sebagai berikut:\nJUMLAH = =LAMBDA(x, y, z, x+y+z);\nSehingga, kode yang terlampir dalam panduan ini adalah potongan kode yang cocok disalin ke editor AFE (Excel Labs)."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-format-indentation",
    "href": "docs/lambda-style-guide.html#sec-format-indentation",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "➡️ Indentasi",
    "text": "➡️ Indentasi\nMenggunakan indentasi yang konsisten akan membantu meningkatkan keterbacaan kode. Gunakan 4 spasi untuk indentasi. Indentasi otomatis dengan AFE akan menyesuaikan dengan lebar layar editor (disarankan maksimal 77 karakter). Gunakan potongan komentar kode dibawah ini sebagai indikator lebar layar editor maksimum.\n// BATAS MAKSMIMUM LAYAR EDITOR -------------------------------------------#"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-format-line-break",
    "href": "docs/lambda-style-guide.html#sec-format-line-break",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "↩︎️ Pemisahan Baris",
    "text": "↩︎️ Pemisahan Baris\nMenggunakan pemisahan baris yang konsisten akan membantu memisahkan bagian kode yang berbeda dan memudahkan pemahaman.\nContoh indentasi dan pemisahan baris yang baik:\nMY_FUNCTION = LAMBDA(x, y, // variabel input\n    IF( /* operasi dimulai di baris baru */\n        x > y,\n        \"X lebih besar\",\n        IF(x < y, \"Y lebih besar\", \"X dan Y sama\")\n    )\n);"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-format-spacing",
    "href": "docs/lambda-style-guide.html#sec-format-spacing",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📏 Spasi untuk Kejelasan",
    "text": "📏 Spasi untuk Kejelasan\nMenggunakan spasi secara konsisten dalam kode LAMBDA akan membantu meningkatkan keterbacaan dan memudahkan pemahaman struktur kode. Pertimbangkan untuk menambahkan spasi di sekitar operator, seperti tanda kurung, koma, dan operator matematika:\nContoh penggunaan spasi yang baik:\nMY_FUNCTION = LAMBDA(a, b, c, IF(a > b, a, IF(b > c, b, c)));"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-format-comments",
    "href": "docs/lambda-style-guide.html#sec-format-comments",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "💬 Komentar dan Catatan",
    "text": "💬 Komentar dan Catatan\nMenambahkan komentar atau catatan di sekitar kode LAMBDA dapat membantu menjelaskan logika atau maksud di balik kode tersebut. Meskipun Excel tidak mendukung komentar langsung dalam rumus, Anda dapat menggunakan komentar pada editor AFE dengan // komentar (satu baris) atau /* komentar */ (lebih dari satu baris)."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-format-operation-order",
    "href": "docs/lambda-style-guide.html#sec-format-operation-order",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "⏭️ Urutan Operasi",
    "text": "⏭️ Urutan Operasi\nUrutan operasi sangat penting untuk memastikan hasil yang benar dari kode LAMBDA. Oleh karena itu, selalu pastikan urutan operasi dalam kode Anda jelas dan mudah dipahami. Jika perlu, gunakan tanda kurung untuk mengklarifikasi prioritas operasi.\nContoh urutan operasi yang baik:\nMY_FUNCTION = LAMBDA(x, y, (x + y) * (x - y));\nDengan memperhatikan aspek-aspek ini dalam bagian Format dan Organisasi, panduan gaya fungsi LAMBDA akan membantu pengguna menciptakan kode yang lebih rapi, konsisten, dan mudah dipahami. Selalu pastikan untuk mengikuti panduan ini dengan konsisten sepanjang kode Anda agar hasilnya optimal."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-naming-variables",
    "href": "docs/lambda-style-guide.html#sec-naming-variables",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🆔 Penamaan Variabel",
    "text": "🆔 Penamaan Variabel\n\nGunakan huruf kecil: Saat menamai variabel dalam fungsi LAMBDA, gunakan huruf kecil untuk mengindikasikan bahwa itu adalah variabel. Terlepas sifat case-insenstive, disarankan untuk membedakan antara nama variabel (huruf kecil) dan nama fungsi (huruf besar) Contoh:\nMY_FUNCTION = LAMBDA(x, y, x+y)\nDi sini, x dan y adalah nama variabel yang ditulis dalam huruf kecil.\nGunakan penamaan yang deskriptif: Pilih nama variabel yang mendeskripsikan data yang diwakili oleh variabel tersebut. Ini membantu meningkatkan pemahaman kode. Contoh:\nMY_FUNCTION = LAMBDA(item_count, unit_price, item_count * unit_price)\nDalam contoh ini, item_count dan unit_price adalah nama variabel yang menjelaskan data yang digunakan dalam perhitungan.\nHindari menggunakan nama variabel yang diakhiri angka: Hal tersebut untuk menghindari keserupaan dengan nama sel (Tiga karakter yang diikuti angka seperti C1, XY35, UDS3213). Untuk menghindari gunakan nama deskriptif atau menambahkan garis bawah (underscore _) sebelum angka. Contoh:\nMY_FUNCTION = LAMBDA(x_1, vec_23, x_1 * vec_23)\nx_1 dan vec_23 adalah nama variabel yang tidak bentrok dengan nama sel (X1, VEC23) karena diberi tambahan garis bawah (x_1, vec_23)."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-naming-functions",
    "href": "docs/lambda-style-guide.html#sec-naming-functions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📋 Penamaan Fungsi",
    "text": "📋 Penamaan Fungsi\n\nGunakan huruf besar: Saat menamai fungsi LAMBDA, gunakan huruf besar untuk memberikan indikator yang berbeda antara fungsi dan variabel. Contoh:\nMY_FUNCTION = LAMBDA(x, y, MAX(x, y))\nDi sini, MY_FUNCTION, LAMBDA, MAX adalah nama fungsi, sedangkan x dan y adalah parameter yang diterima oleh fungsi LAMBDA yang kita definisikan atau dapat disebut variabel.\nGunakan penamaan fungsi yang deskriptif: Pilih nama yang mencerminkan tujuan atau operasi yang dilakukan oleh fungsi tersebut. Nama yang jelas dan deskriptif membantu memahami fungsi saat dilihat atau digunakan di tempat lain. Contoh:\nTOTAL_PRICE = LAMBDA(item_count, unit_price, item_count * unit_price)\nDalam contoh ini, fungsi TOTAL_PRICE menggambarkan total harga dari perhitungan perkalian item_count dengan unit_price.\nGunakan pemisahan kata dengan garis bawah: Jika nama fungsi terdiri dari beberapa kata, gunakan garis bawah sebagai pemisah di awal setiap kata untuk memisahkannya. Contoh:\nCALCULATE_TOTAL_PRICE = LAMBDA(item_count, unit_price, item_count * unit_price)\nDi sini, CALCULATE_TOTAL_PRICE adalah nama fungsi yang terdiri dari beberapa kata, dan mengikuti panduan sebelumnya, semuanya menggunakan huruf besar."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-function-chaining",
    "href": "docs/lambda-style-guide.html#sec-function-chaining",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🔗 Rantai Fungsi",
    "text": "🔗 Rantai Fungsi\nRantai fungsi dalam LAMBDA memungkinkan penulisan kode yang singkat dan ringkas. Namun, perlu diingat bahwa terlalu banyak fungsi yang dirantai dapat membingungkan. Sebaiknya batasi jumlah fungsi yang dirantai dan pisahkan dengan baris baru jika perlu.\nContoh berikut menggambarkan rantai fungsi dalam LAMBDA:\nMY_FUNCTION = LAMBDA(x, y, z, SUM(PRODUCT(x, y), z));\nNamun, untuk meningkatkan keterbacaan, bisa dipisahkan menjadi:\nMY_FUNCTION = LAMBDA(x, y, z,\n    LET(\n        calcProduct, PRODUCT(x, y),\n        SUM(calcProduct, z)\n    )\n)"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-helper-functions",
    "href": "docs/lambda-style-guide.html#sec-helper-functions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🛠️ Fungsi Pembantu",
    "text": "🛠️ Fungsi Pembantu\nFungsi pembantu adalah cara yang baik untuk memisahkan logika dan membuat kode lebih mudah dibaca. Fungsi pembantu ini bisa melakukan tugas-tugas kecil yang membuat kode utama menjadi lebih bersih dan mudah dipahami.\nBerikut adalah contoh fungsi pembantu dalam LAMBDA:\nMY_FUNCTION = LAMBDA(x, y, z,\n    LET(\n        calcProduct, PRODUCT(x, y),\n        SUM(calcProduct, z)\n    )\n)"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-parentheses-for-clarity",
    "href": "docs/lambda-style-guide.html#sec-parentheses-for-clarity",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🟢 Tanda Kurung untuk Kejelasan",
    "text": "🟢 Tanda Kurung untuk Kejelasan\nTanda kurung dapat meningkatkan keterbacaan dengan memisahkan bagian-bagian fungsi. Namun, hindari penggunaan tanda kurung yang berlebihan karena dapat membuat kode lebih sulit dipahami.\nContoh berikut menggambarkan penggunaan tanda kurung yang efektif dalam LAMBDA:\nMY_FUNCTION = LAMBDA(x, y, z, SUM((PRODUCT(x, y)), z));"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-keeping-functions-simple",
    "href": "docs/lambda-style-guide.html#sec-keeping-functions-simple",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🧮 Menjaga fungsi tetap sederhana",
    "text": "🧮 Menjaga fungsi tetap sederhana\nMenggunakan fungsi LAMBDA yang sederhana dan mudah dipahami adalah kunci untuk keterbacaan dan efisiensi. Sebaiknya batasi jumlah fungsi dalam satu baris dan pisahkan tugas-tugas kecil ke dalam fungsi pembantu jika memungkinkan.\nBerikut adalah contoh bagaimana fungsi LAMBDA dapat disederhanakan:\nMY_FUNCTION = LAMBDA(x, y, z,\n    LET(\n        calcProduct, PRODUCT(x, y),\n        result, SUM(calcProduct, z),\n        result\n    )\n);"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-variable-naming",
    "href": "docs/lambda-style-guide.html#sec-variable-naming",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "✏️ Penamaan Variabel",
    "text": "✏️ Penamaan Variabel\nPenamaan variabel yang jelas dan deskriptif dapat membantu meningkatkan keterbacaan kode. Variabel harus diberi nama yang mencerminkan tujuan atau nilai yang mereka simpan. Menggunakan singkatan atau kode yang tidak jelas dapat membuat kode lebih sulit dipahami.\nContoh berikut menunjukkan penggunaan penamaan variabel yang baik dalam LAMBDA:\nMY_FUNCTION = LAMBDA(length, width, height,\n    LET(\n        volume, PRODUCT(length, width, height),\n        volume\n    )\n);\nDalam contoh ini, variabel volume jelas menunjukkan bahwa ia menyimpan nilai volume dari suatu objek."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-comment-usage",
    "href": "docs/lambda-style-guide.html#sec-comment-usage",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "💭 Penggunaan Komentar",
    "text": "💭 Penggunaan Komentar\nPenggunaan komentar dalam kode dapat membantu meningkatkan keterbacaan, terutama jika kode tersebut kompleks atau membingungkan. Namun, perlu diingat bahwa komentar harus digunakan dengan bijaksana. Komentar yang berlebihan atau tidak jelas bisa justru membuat kode lebih sulit dipahami.\nPenggunaan komentar dapat menggunakan // (untuk satu baris) atau /* KOMENTAR */ (untuk satu blok). Disarankan untuk menghindari komentar di dalam fungsi untuk membuat mudah dibaca. Deskripsi cara kerja atau instruksi lebih lanjut mengenai fungsi bisa ditulis dibagian dokumentasinya.\nContoh penggunaan komentar:\nMY_FUNCTION = LAMBDA(length, width, height,\n    LET( // Digunakan LET untuk memudahkan pembacaan\n        volume, PRODUCT(length, width, height), \n        volume\n    )\n);"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-argument-order",
    "href": "docs/lambda-style-guide.html#sec-argument-order",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🔀 Urutan argumen yang konsisten",
    "text": "🔀 Urutan argumen yang konsisten\nArgumen fungsi LAMBDA di Microsoft Excel harus disusun dengan hati-hati. Urutan argumen berperan penting dalam menentukan hasil fungsi. Setiap argumen dalam fungsi LAMBDA ditulis secara berurutan, dipisahkan oleh tanda koma.\nSebagai contoh, jika fungsi LAMBDA memiliki tiga argumen: A, B, dan C, maka urutan penulisannya dalam fungsi adalah sebagai berikut:\nMY_FUNCTION = LAMBDA(A, B, C, ...)\nUrutan argumen ini nantinya akan mempengaruhi cara fungsi tersebut dipanggil. Jika fungsi MY_FUNCTION dipanggil dengan tiga nilai, misalnya 1, 2, dan 3, maka nilai-nilai tersebut akan diberikan kepada argumen sesuai dengan urutannya. Dalam hal ini, A akan mendapatkan nilai 1, B mendapatkan nilai 2, dan C mendapatkan nilai 3.\nFungsi yang bersifat memanipulasi input maka argumen pertamanya merupakan input tersebut. Contoh, fungsi APPLY_COLUMN menerapkan fungsi LAMBDA pada kolom tertentu, maka urutan argumen dimulai dari inputnya yaitu array, indeks kolom, dan fungsi LAMBDA. Sehingga penulisan argumen fungsi sebagai berikut:\nAPPLY_COLUMN = LAMBDA(array, column_index, LAMBDA_FUNCTION, ...)\nJika fungsi LAMBDA yang dibuat menyerupai fungsi yang tersedia di Excel, gunakan urutan yang menyerupai fungsi tersebut agar bisa merujuk fungsi utama. Contoh: fungsi XLOOKUP memiliki urutan yang dimulai dari lookup_value, lookup_vector, return_array, dst. Maka fungsi buatan XLOOKUP_EXTENDER memiliki urutan yang serupa juga dengan fungsi XLOOKUP.\nXLOOKUP_EXTENDER = LAMBDA(lookup_value, lookup_vector, return_array, ...)"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-optional-arguments",
    "href": "docs/lambda-style-guide.html#sec-optional-arguments",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "➕ Argumen Opsional",
    "text": "➕ Argumen Opsional\nArgumen opsional adalah argumen yang tidak harus disertakan saat memanggil fungsi. Argumen ini biasanya ditandai dengan tanda kurung siku ([]). Contoh penulisan argumen opsional dalam fungsi LAMBDA adalah sebagai berikut:\nMY_FUNCTION = LAMBDA(A, [B],\n    LET(\n        B, IF(ISOMITTED(B), 2, B), \n        A * B\n    )\n);\nDalam contoh ini, MY_FUNCTION adalah fungsi yang menerima dua argumen: A dan B. Namun, B adalah argumen opsional. Jika B tidak diberikan saat memanggil fungsi, maka B akan dianggap sebagai 2 (lihat fungsi IF(ISOMITTED(B), 2, B)). Gunakan fungsi ISOMITTED() untuk pengaturan nilai argumen opsional.\nBerikut adalah contoh pemanggilan fungsi MY_FUNCTION dengan dan tanpa argumen opsional:\nMY_FUNCTION(2, 3) // Hasilnya adalah 6, karena 2 * 3 = 6\nMY_FUNCTION(2) // Hasilnya adalah 4, karena B dianggap sebagai 2, sehingga 2 * 2 = 2\nDalam contoh ini, perhatikan bahwa pemanggilan fungsi tanpa menyertakan argumen opsional tidak menyebabkan kesalahan. Argumen opsional memberikan fleksibilitas saat memanggil fungsi, tetapi harus digunakan dengan hati-hati untuk menghindari kebingungan."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-documenting-lambda-functions",
    "href": "docs/lambda-style-guide.html#sec-documenting-lambda-functions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📑 Membuat dokumen atau lembar khusus untuk deskripsi fungsi LAMBDA",
    "text": "📑 Membuat dokumen atau lembar khusus untuk deskripsi fungsi LAMBDA\nSetiap fungsi LAMBDA yang dibuat harus memiliki dokumentasi yang rinci dan mudah dipahami. Dokumentasi tersebut sebaiknya ditempatkan dalam dokumen atau lembar khusus yang mudah diakses dan ditemukan. Dokumentasi tersebut harus mencakup detail tentang fungsi tersebut, termasuk:\n\nNama fungsi dan versinya (jika ada)\nDeskripsi singkat tentang apa yang dilakukan oleh fungsi tersebut\nDaftar argumen yang diperlukan oleh fungsi dan deskripsi singkat tentang apa yang dilakukan oleh setiap argumen\nJenis input/argumen yang digunakan dalam fungsi\nContoh penggunaan fungsi dan hasil yang dihasilkan\nSetiap perubahan yang telah dibuat pada fungsi dari versi sebelumnya"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-tips-for-clear-descriptions",
    "href": "docs/lambda-style-guide.html#sec-tips-for-clear-descriptions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📄 Kiat untuk membuat deskripsi yang jelas, singkat, dan informatif",
    "text": "📄 Kiat untuk membuat deskripsi yang jelas, singkat, dan informatif\nBerikut adalah beberapa kiat untuk membuat deskripsi fungsi LAMBDA yang jelas, singkat, dan informatif:\n\nGunakan bahasa yang mudah dipahami: Hindari jargon dan istilah teknis yang rumit kecuali jika perlu. Tujuannya adalah untuk membuat dokumentasi yang dapat dipahami oleh semua orang, termasuk mereka yang tidak memiliki pengetahuan teknis yang mendalam.\nJelaskan apa yang dilakukan oleh fungsi: Ini adalah bagian yang paling penting dari dokumentasi. Pengguna harus dapat memahami apa yang dilakukan oleh fungsi hanya dengan membaca deskripsi singkatnya.\nJelaskan argumen fungsi: Deskripsikan setiap argumen dan jelaskan perannya dalam fungsi. Jika argumen memiliki nilai default, sebutkan juga nilai tersebut.\nBerikan contoh penggunaan: Contoh penggunaan yang konkret dapat membantu pengguna memahami cara kerja fungsi dan bagaimana cara menggunakannya.\nJaga dokumentasi tetap up-to-date: Setiap kali Anda membuat perubahan pada fungsi, pastikan untuk juga memperbarui dokumentasi.\n\nBerikut adalah contoh dokumentasi kode fungsi SWAP_COLUMNS di feidlambda v0.3 yang dapat digunakan untuk menukar posisi kolom ke-from_index dengan kolom ke-to_index:\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [row vector | array]\n\nData dapat berupa array atau row vector.\n\n[from_index] := 1 :: [integer]\n\n(Change in v0.3.1). Nilai default yaitu 1. Posisi index kolom yang ingin dipindahkan. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n[to_index] := -1 :: [integer]\n\n(Change in v0.3.1). Nilai default yaitu -1. Posisi index tujuan kolom. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n\n\nContoh penggunaannya dapat berbentuk dalam gambar atau gif. Disarankan untuk menyediakan lembar kerja yang menguji fungsi tersebut. Ingatlah bahwa dokumentasi yang baik adalah investasi. Waktu yang dihabiskan untuk membuat dan merawat dokumentasi akan terbayar ketika orang lain (atau Anda sendiri di masa depan) perlu memahami atau menggunakan fungsi yang telah Anda buat."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-optimizing-performance",
    "href": "docs/lambda-style-guide.html#sec-optimizing-performance",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "⏱️ Mengoptimalkan kinerja",
    "text": "⏱️ Mengoptimalkan kinerja\nOptimalisasi kinerja dapat dilakukan dengan menghindari pengulangan yang tidak perlu dan menggunakan fungsi bawaan Excel kapan pun mungkin. Misalnya, fungsi SEQUENCE dan LET bisa digunakan untuk mengurangi pengulangan dan meningkatkan kinerja.\n// Menggunakan SEQUENCE dan LET untuk mengurangi pengulangan\nSUM_ODD_NUMBERS = LAMBDA(n,\n    LET(\n        sequence, SEQUENCE(n),\n        odd_sequence, IF(MOD(sequence, 2) = 1, sequence, 0),\n        SUM(odd_sequence)\n    )\n);"
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-consistent-case-usage",
    "href": "docs/lambda-style-guide.html#sec-consistent-case-usage",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🔠 Menggunakan huruf besar dan huruf kecil yang konsisten",
    "text": "🔠 Menggunakan huruf besar dan huruf kecil yang konsisten\nKonsistensi penamaan variabel penting untuk memudahkan pembacaan kode. Ini tidak mempengaruhi kinerja, tetapi penting untuk pemeliharaan dan kolaborasi kode. Rekomendasi penulisan terkait ini antara lain:\n\nHuruf besar digunakan untuk fungsi seperti SEQUENCE(), LAMBDA().\nHuruf kecil digunakan untuk variabel/nama argumen/parameter seperti input_number, odd_sequence."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-thorough-function-testing",
    "href": "docs/lambda-style-guide.html#sec-thorough-function-testing",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🧪 Menguji fungsi secara menyeluruh",
    "text": "🧪 Menguji fungsi secara menyeluruh\nPengujian fungsi secara menyeluruh penting untuk memastikan kinerja optimal dan menghindari kesalahan. Anda dapat melakukan ini dengan menguji fungsi Anda di berbagai skenario dan ukuran data.\nMisalnya, jika Anda memiliki fungsi SUM_ODD_NUMBERS, Anda dapat mengujinya dengan berbagai input, mulai dari 1 sampai 1.000.000, dan memeriksa apakah outputnya sesuai dengan yang diharapkan."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-considering-scalability",
    "href": "docs/lambda-style-guide.html#sec-considering-scalability",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📈 Pertimbangkan skalabilitas",
    "text": "📈 Pertimbangkan skalabilitas\nFungsi harus dirancang dengan pertimbangan bahwa ukuran data mungkin akan meningkat di masa mendatang. Misalnya, jika fungsi mengambil array sebagai argumen, pastikan bahwa ia dapat menangani array dengan jumlah elemen yang besar.\n// Fungsi yang dirancang untuk menangani array dengan jumlah elemen yang besar\nIS_ALL_IN_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOCOL(lookup_vector),\n        MAP(array, LAMBDA(element, OR(BYROW(lookup_vector, LAMBDA(lookup, element = lookup)))))\n    )\n);\nOleh karena itu gunakan konsep pengembangan fungsi dengan vektorisasi. Vektorisasi mengacu pada teknik di mana operasi diterapkan pada seluruh array, bukan hanya pada elemen individual, yang dapat secara signifikan meningkatkan kinerja dan efisiensi. Excel mendukung vektorisasi melalui banyak fungsi bawaannya dan kemampuan untuk menerapkan operasi pada seluruh array dalam satu operasi.\nSebagai contoh, berikut ini adalah perbandingan antara fungsi yang dirancang dengan vektorisasi dan tanpa vektorisasi. Kedua fungsi memiliki tujuan yang sama, yaitu menghitung kuadrat dari setiap angka dalam array.\n// Tanpa vektorisasi\nSQUARE_EACH_NUMBER = LAMBDA(array,\n    LET(\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        row_sequence, SEQUENCE(nrows),\n        col_sequence, SEQUENCE(, ncols),\n        result, IFERROR(INDEX(array, row_sequence, col_sequence)^2, \"\"),\n        result\n    )\n);\n\n// Dengan vektorisasi\nSQUARE_EACH_NUMBER_VECTORIZED = LAMBDA(array,\n    array^2\n);\nDalam contoh ini, fungsi SQUARE_EACH_NUMBER_VECTORIZED akan jauh lebih cepat dan efisien dibandingkan dengan SQUARE_EACH_NUMBER, terutama saat bekerja dengan array yang berukuran besar."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-utilizing-built-in-functions",
    "href": "docs/lambda-style-guide.html#sec-utilizing-built-in-functions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🎁 Memanfaatkan fungsi bawaan",
    "text": "🎁 Memanfaatkan fungsi bawaan\nFungsi bawaan Excel biasanya lebih optimal dan efisien daripada fungsi yang dibuat secara kustom. Oleh karena itu, sebisa mungkin gunakan fungsi bawaan dalam implementasi fungsi LAMBDA Anda. Berikut adalah contoh fungsi untuk interpolasi linear antara dua titik. Satu fungsi tidak menggunakan fungsi bawaan dan satu lagi menggunakan fungsi FORECAST.LINEAR() di Excel.\nTanpa menggunakan fungsi bawaan:\n// Custom function for linear interpolation\nLINEAR_INTERPOLATION_CUSTOM = LAMBDA(x, x1, y1, x2, y2,\n    y1 + ((x - x1) * (y2 - y1)) / (x2 - x1)\n);\nDi sini, x adalah nilai yang ingin kita interpolasi, (x1, y1) dan (x2, y2) adalah dua titik yang diketahui. Fungsi ini menghitung nilai y yang sesuai dengan x berdasarkan garis yang ditarik antara dua titik yang diberikan.\nSekarang, mari kita buat fungsi yang sama menggunakan fungsi bawaan FORECAST.LINEAR():\n// Using built-in Excel function for linear interpolation\nLINEAR_INTERPOLATION_FORECAST = LAMBDA(x, known_y's, known_x's,\n    FORECAST.LINEAR(x, known_y's, known_x's)\n);\nDi sini, x adalah nilai yang ingin kita interpolasi, known_y's dan known_x's adalah array y dan x yang diketahui. Fungsi FORECAST.LINEAR() menghitung, atau meramalkan, nilai y yang sesuai dengan x berdasarkan data x dan y yang diberikan."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-utilizing-dynamic-arrays",
    "href": "docs/lambda-style-guide.html#sec-utilizing-dynamic-arrays",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "💹 Memanfaatkan dynamic array dan fungsinya",
    "text": "💹 Memanfaatkan dynamic array dan fungsinya\nRumus array memungkinkan Anda untuk melakukan operasi pada seluruh array atau rentang data sekaligus, bukan pada setiap nilai secara individual. Ini sangat penting dalam mempercepat pengolahan dan analisis data, terutama jika Anda bekerja dengan dataset yang besar.\nKonsep ini sering kali terkait dengan vektorisasi, sebuah teknik di mana operasi diterapkan pada seluruh array, bukan hanya pada elemen individual. Ini dapat secara signifikan meningkatkan kinerja dan efisiensi.\nAda dua jenis fungsi utama dalam Excel: fungsi scalar dan fungsi dynamic array. Fungsi scalar hanya mengembalikan satu nilai pada waktu tertentu. Di sisi lain, fungsi dynamic array mampu menghasilkan serangkaian nilai (atau array) sebagai output, dan jika ditempatkan di sel top-left, outputnya akan “mengisi” area yang sesuai di sekitar sel tersebut.\nSebagai contoh, misalkan kita ingin menghitung kuadrat dari setiap angka dalam tabel. Biasanya, kita membuat kolom baru dimana formulanya sebagai berikut =baris_kolom_angka^2 yang mengisi setiap baris di kolom kuadratnya. Formulasi tersebut dianggap sebagai fungsi scalar karena hanya menghasilkan satu nilai pada setiap baris. Solusinya adalah memanfaatkan dynamic array dimana input fungsi merupakan array.\n// Fungsi dynamic array\nSQUARE_DYNAMIC_ARRAY = LAMBDA(array,\n    array^2\n);\nBerbeda dengan fungsi scalar, fungsi dynamic array di atas dapat menghitung kuadrat dari setiap angka dalam array sekaligus, karena operasi kuadrat diterapkan pada seluruh array, bukan hanya pada elemen individual. Ini adalah contoh penggunaan vektorisasi dalam rumus array. Secara umum, menggunakan fungsi dynamic array dan memanfaatkan vektorisasi dalam rumus array dapat meningkatkan kinerja dan efisiensi pengolahan data Anda di Excel."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-avoiding-recursive-references",
    "href": "docs/lambda-style-guide.html#sec-avoiding-recursive-references",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🚫 Menghindari fungsi rekursif atau dependensi yang tidak perlu",
    "text": "🚫 Menghindari fungsi rekursif atau dependensi yang tidak perlu\nFungsi rekursif atau dependensi yang tidak perlu dapat menyebabkan fungsi berjalan lebih lambat dan mengakibatkan kesalahan. Pastikan untuk menghindari ini ketika merancang fungsi Anda. Akan tetapi, jika ingin melakukan looping setiap elemen/baris/kolom di suatu array, bisa memanfaatkan fungsi recursive. Hanya saja, fungsi rekursif ini akan sulit dibaca dibandingkan fungsi LAMBDA yang kompleks. Beberapa kasus dapat memanfaatkan fungsi rekursif, akan tetapi lebih baik untuk menjauhi fungsi yang bersifat rekursif."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-sharing-lambda-functions",
    "href": "docs/lambda-style-guide.html#sec-sharing-lambda-functions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🔄 Berbagi fungsi LAMBDA dengan rekan kerja",
    "text": "🔄 Berbagi fungsi LAMBDA dengan rekan kerja\nUntuk berbagi fungsi LAMBDA dengan rekan kerja, Anda dapat menggunakan fasilitas dalam Microsoft Excel seperti sharing dan co-authoring. Anda juga dapat menyimpan fungsi dalam workbook yang dapat diakses oleh semua pengguna yang berkolaborasi. Workbook ini kemudian dapat disimpan di tempat yang aman dan mudah diakses seperti SharePoint atau OneDrive.\nRekomendasi untuk membagikan fungsi LAMBDA yaitu dengan menggunakan GitHub Gist dan AFE. GitHub Gist adalah layanan berbagi potongan kode dan catatan yang disediakan oleh GitHub. Ini memungkinkan pengguna untuk menyimpan, berbagi, dan berkolaborasi pada potongan kode secara mudah. Import fungsi LAMBDA dari GitHub Gist juga sudah di dukung dengan AFE. Paket feidlambda menggunakan GitHub Gist untuk mendistribusikan dan menyebarkan fungsi LAMBDA-nya.\nJika fungsi LAMBDA berupa formula sederhana dapat langsung menyalinkan formula LAMBDA-nya sebagai nama fungsinya di Formula Name Manager. Dengan format seperti berikut:\n=LAMBDA(x, y, z, x + y + z)\nJika rekannya menggunakan AFE, bisa juga langsung mengambil dari editor AFE. Sehingga formatnya sebagai berikut:\nMY_FUNCTION = LAMBDA(x, y, z, x + y + z);\nSalah satu tantangan dalam menciptakan rangkaian fungsi LAMBDA tanpa memanfaatkan Advanced Formula Environment (AFE) adalah ketiadaan kemampuan untuk memberi tahu nama fungsi tersebut secara eksplisit. Sebagai contoh, penulisan fungsi LAMBDA tanpa AFE akan muncul seperti ini: =LAMBDA(x, y, z, x + y + z). Untuk menggunakan fungsi tersebut, kita harus menyampaikan nama fungsi ini kepada rekan kerja kita secara terpisah. Namun, dengan AFE, kita dapat mendefinisikan nama fungsi secara langsung dalam formula, seperti ini: MY_FUNCTION = LAMBDA(x, y, z, x + y +z);. Oleh karena itu, kami sangat menyarankan untuk mulai berkolaborasi dan berbagi fungsi LAMBDA melalui add-ins Excel Labs dengan AFE, demi peningkatan keterbacaan dan produktivitas."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-implementing-version-control",
    "href": "docs/lambda-style-guide.html#sec-implementing-version-control",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📜 Mengimplementasikan kontrol versi",
    "text": "📜 Mengimplementasikan kontrol versi\nAlat kontrol versi seperti Git bisa digunakan untuk melacak perubahan, memudahkan pemulihan kode saat terjadi kesalahan, dan memantau kontribusi dari anggota tim yang berbeda. Ini juga memfasilitasi peninjauan kode. Oleh karena itu, disarankan dalam pengembangan ataupun penyebaran menggunakan GitHub Gist atau GitHub Repository sehingga dapat melacak setiap perubahan yang terjadi.\nMendistribusikan koleksi fungsi LAMBDA melalui GitHub Gist/Repository memudahkan pengguna dan pengembang lain dalam meninjau penggunaan kumpulan fungsi LAMBDA tersebut dalam lembar kerja mereka. Penerapan kontrol versi sangat dianjurkan ketika kumpulan fungsi LAMBDA tersebut diharapkan untuk dikembangkan atau ditingkatkan lebih lanjut.\nSebagai contoh, lihat github feidlambda. Repository ini digunakan sebagai tempat utama untuk pengembangan dan pelacakan saat ada penambahan atau perbaikan pada kumpulan fungsi LAMBDA di feidlambda. Setelah versi terbaru dirilis, isi GitHub GIST diperbarui untuk versi minor pada setiap rilis (x.1, x.2, x.3)."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-grouping-related-functions",
    "href": "docs/lambda-style-guide.html#sec-grouping-related-functions",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "📚 Mengelompokkan fungsi yang terkait",
    "text": "📚 Mengelompokkan fungsi yang terkait\nPengelompokan fungsi yang terkait dapat membantu dalam keterbacaan dan pemeliharaan kode. Misalnya, fungsi yang berhubungan dengan manipulasi data dapat dikelompokkan bersama. Contoh pengelompokkan ini dapat dilihat proyek feidlambda sejak versi v0.3+. Pengelompokkan ini akan memudahkan dan mengisolasi interaksi/hubungan antar fungsi LAMBDA dalam koleksinya.\nDalam pengelompokkan disarankan untuk menghilangkan ketergantungan/dependency pada fungsi diluar kelompok tersebut. Hal ini untuk memudahkan saat mengevaluasi fungsi dan memudahkan distribusi jika ingin menggunakan koleksi fungsi LAMBDA pada kelompok tertentu saja. Pengelompokkan ini disaranakn mengubah penamaan nama fungsi yang diawali dengan kelompok fungsi LAMBDA-nya seperti SWAP_*(...) untuk kelompok fungsi SWAP."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-code-modularization",
    "href": "docs/lambda-style-guide.html#sec-code-modularization",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "🧩 Modularisasi kode",
    "text": "🧩 Modularisasi kode\nModularisasi kode melibatkan pemisahan fungsi atau operasi ke dalam modul-modul yang lebih kecil dan dapat dipertukarkan. Ini membantu dalam keterbacaan, pemeliharaan, dan pengujian kode."
  },
  {
    "objectID": "docs/lambda-style-guide.html#sec-balancing-performance-readability",
    "href": "docs/lambda-style-guide.html#sec-balancing-performance-readability",
    "title": "FIAKO LAMBDA Style Guide v1.0",
    "section": "⚖️ Menyeimbangkan kinerja dan keterbacaan",
    "text": "⚖️ Menyeimbangkan kinerja dan keterbacaan\nKetika mengoptimalkan kode, penting untuk menemukan keseimbangan antara kinerja dan keterbacaan. Kode yang sangat dioptimalkan tetapi sulit dibaca dapat mengakibatkan kesulitan dalam pemeliharaan dan penyebaran kode."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html",
    "href": "article/migration-v0-2-to-v0-3.html",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "",
    "text": "Halaman ini menjelaskan mengenai perubahan feidlambda v0.2 ke v0.3 dan panduan migrasinya."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html#mengulangimerepetisi-data",
    "href": "article/migration-v0-2-to-v0-3.html#mengulangimerepetisi-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mengulangi/merepetisi data",
    "text": "Mengulangi/merepetisi data\n\nFungsi v0.2\n\nREPEATCOLS() | REPEATROWS()\n\nFungsi v0.3\n\nREPEAT_ARRAY_BY_COLUMN() | REPEAT_ARRAY_BY_ROW()\n\n\nDi v0.2, fungsi untuk mengulangi data dapat menggunakan fungsi REPEATCOLS() atau REPEATROWS(). Akan tetapi, terdapat batasan terkait fungsi tersebut yaitu fungsi tersebut hanya menerima input berupa vector. Fungsi tersebut juga menggunakan fungsi CHOOSE*() sebagai fungsi utama dalam merepetisi datanya. Pada versi v0.3, fungsi tersebut digantikan oleh REPEAT_ARRAY_BY_*() atau REPEAT_ARRAY().\nSintaks yang awalnya REPEAT*(vector, [num_repeat]) menjadi REPEAT_ARRAY_BY_*(array, [num_repeat]), jadi untuk fungsi ini cukup mengganti nama fungsinya saja. Perilakunya akan tetap sama dengan versi v0.2. Di versi v0.3, terdapat fungsi baru yaitu REPEAT_ARRAY() yang merupakan fungsi pembungkus untuk REPEAT_ARRAY_BY_*() dengan sintaks REPEAT_ARRAY(array, [num_repeat], [by_row]). Sehingga, bisa juga cukup mengganti fungsi versi sebelumnya dengan fungsi ini dengan tambahan opsional argumen by_row."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html#mengurutkan-data-berdasarkan-baris",
    "href": "article/migration-v0-2-to-v0-3.html#mengurutkan-data-berdasarkan-baris",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mengurutkan data berdasarkan baris",
    "text": "Mengurutkan data berdasarkan baris\n\nFungsi v0.2\n\nSORTCOLS()\n\nFungsi v0.3\n\n-\n\n\nUntuk mengurutkan kolom berdasarkan baris tertentu bisa langsung menggunakan SORT(array, [sort_index], [sort_order], [by_cols]) yang sudah disediakan di Microsoft Excel. Jadi untuk formula SORTCOLS(table, table_header) menjadi SORT(array, [sort_index], [sort_order], [by_cols]) dengan catatan menggunakan argumen by_cols <- TRUE."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html#mengubah-dimensi-data",
    "href": "article/migration-v0-2-to-v0-3.html#mengubah-dimensi-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mengubah dimensi data",
    "text": "Mengubah dimensi data\n\nFungsi v0.2\n\nRESHAPECOLS()\n\nFungsi v0.3\n\nRESHAPE_BY_COLUMNS()\n\n\nUntuk fungsi RESHAPECOLS(array, [nsplit]) dapat diganti menggunakan fungsi RESHAPE_BY_COLUMNS(array, [num_split]). Tidak ada perubahan dari posisi argumennya sehingga migrasinya berupa cukup mengganti nama fungsinya."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html#mencari-posisi-nilai-dari-data",
    "href": "article/migration-v0-2-to-v0-3.html#mencari-posisi-nilai-dari-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Mencari posisi nilai dari data",
    "text": "Mencari posisi nilai dari data\n\nFungsi v0.2\n\nFINDINDEX2D()\n\nFungsi v0.3\n\nGET_INDEX_2D()\n\n\nUntuk fungsi FINDINDEX2D(lookup_value, array) dapat digantikan menggunakan fungsi GET_INDEX_2D(lookup_value, array, [return_number_only]). Tidak ada perubahan dari posisi argumennya sehingga migrasinya berupa cukup mengganti nama fungsinya. Terdapat tambahan argumen return_number_only yang hasilnya hanya menyajikan urutan keberapa elemen yang ditemukannya."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html#memeriksa-hasil-logical",
    "href": "article/migration-v0-2-to-v0-3.html#memeriksa-hasil-logical",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Memeriksa hasil logical",
    "text": "Memeriksa hasil logical\n\nFungsi v0.2\n\nCOMPAREVECTOR() | MULTICHECK()\n\nFungsi v0.3\n\nIS_ALL_IN_VECTOR() | IS_ALL_COLS_EQUAL_VECTOR()\n\n\nUntuk fungsi COMPAREVECTOR() dan MULTICHECK() sebenarnya merupakan fungsi/formula yang digunakan untuk memeriksa suatu kondisi dari data. Oleh karena itu, penamaannya di v0.3 diganti menjadi IS_*. Hal tersebut menyamakan dengan fungsi IS* lainnya, yang bertujuan untuk memeriksa bahwa dataset ini memenuhi kondisi tertentu. COMPAREVECTOR() pada dasarnya adalah proses yang serupa dengan %in% di R, yang bertugas untuk memeriksa apakah setiap nilai elemen di suatu dataset termasuk dalam kumpulan nilai. Atau kata lainnya, memeriksa apakah elemen \\(X_i\\) di \\(X\\) ada di elemen \\(Y\\). Sedangkan untuk MULTICHECK() memeriksa untuk setiap kolom mengandung nilai yang sama dengan nilai yang dicari.\nSintaks COMPAREVECTOR(left_vector, right_vector) menjadi IS_ALL_IN_VECTOR(array, lookup_vector), yang bisa dibaca “Apakah (IS) semua elemen (ALL) termasuk (IN) di lookup_vector yang dicari (VECTOR)?”. Sedangkan untuk MULTICHECK(array, search_array, [check_condition]) menjadi IS_ALL_COLS_EQUAL_VECTOR(array, lookup_vector, [logical_function]), yang bisa dibaca “Apakah (IS) semua (ALL) setiap kolom (COLS) sama dengan (EQUAL) lookup_vector?”. Jadi secara sekilas untuk migrasi cukup mengganti nama fungsinya dengan catatan IS_ALL_COLS_EQUAL_VECTOR() memiliki perubahan argumen opsional yang menjadi logical_function (berupa fungsi LAMBDA())."
  },
  {
    "objectID": "article/migration-v0-2-to-v0-3.html#menghapus-kolom-atau-baris-dari-data",
    "href": "article/migration-v0-2-to-v0-3.html#menghapus-kolom-atau-baris-dari-data",
    "title": "Migrasi feidlambda v0.2 ke v0.3",
    "section": "Menghapus kolom atau baris dari data",
    "text": "Menghapus kolom atau baris dari data\n\nFungsi v0.2\n\nDROPROWS() | DROPCOLS()\n\nFungsi v0.3\n\nFILTER_DROP_ROWS() | FILTER_DROP_COLUMNS()\n\n\nFungsi DROP*() bertujuan untuk menghapus baris/kolom tertentu dari data. Fungsi tersebut dibuat karena saat ini belum ada fungsinya, yang telah tersedia kebalikannya yaitu mengambil kolom/baris tertentu dengan CHOOSE*(). Penggunaan di v0.3 sama saja dengan v0.2, yang berubah hanya nama fungsinya. Jadi dari DROPROWS(array, index_to_drop) menjadi FILTER_DROP_ROWS(array, row_index) dan DROPCOLS(array, index_to_drop) menjadi FILTER_DROP_COLUMNS(array, column_index)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\ntest"
  },
  {
    "objectID": "greenhorn/index.html",
    "href": "greenhorn/index.html",
    "title": "feidlambda",
    "section": "",
    "text": "Greenhorn \\(\\text{fe}\\hat{i}\\text{d} \\textbf{l} \\lambda \\text{m} \\textsf{b} \\texttt{d} \\bigtriangleup\\) by fiakodev\n\n\n\n\n\n\n\nDalam Pengembangan dan Pelatihan\n\n\n\nPelatihan ini masih dalam tahap pengembangan dan pelaksanaan. Seluruh materi yang disinggung akan dicatat di bagian greenhorn ini.\n\n\n\nfeidlambda I (WIP)Introduction to Dynamic Array\nfeidlambda II (WIP)Exploring Dynamic Array + User Defined Lambda (UDL) with LAMBDA\nfeidlambda III (WIP)Advanced Dynamic Array + Best Practices UDF"
  },
  {
    "objectID": "greenhorn/feidlambda-2/index.html",
    "href": "greenhorn/feidlambda-2/index.html",
    "title": "feidlambda II",
    "section": "",
    "text": "Topik Pembahasan:\n\nReview Daftar Istilah\nEksplorasi tentang Logical\nDynamic Array Formula\nFungsi Baru dari Excel 2019 dan 2021\nUser Defined LAMBDA (UDL)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#section",
    "href": "greenhorn/feidlambda-2/presentation.html#section",
    "title": "Greenhorn:feidlambda II",
    "section": "",
    "text": "Kegiatan\nGreenhorn\nTopik\nExploring Dynamic Array and User Defined Lambda (UDL)Memanfaatkan Dynamic Array dan User-Defined LAMBDA (UDL)\nAuthor\nBahan presentasi dibuat oleh Taruma Sakti Megariansyah\nLisensi\nSeluruh materi presentasi menggunakan lisensi CC-BY-NC-SA 4.0\nKontak\nhi@taruma.info / team@dev.fiako.engineering"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#agenda",
    "href": "greenhorn/feidlambda-2/presentation.html#agenda",
    "title": "Greenhorn:feidlambda II",
    "section": "Agenda",
    "text": "Agenda\nAgenda untuk Greenhorn feidlambda II: Exploring Dynamic Array + User Defined Lambda (UDL)\n\nReview Daftar Istilah\nEksplorasi tentang Logical\nDynamic Array Formula (DAF)\nFungsi Baru dari Excel 2019 dan 2021\nUser Defined Lambda (UDL)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#vector-dan-array",
    "href": "greenhorn/feidlambda-2/presentation.html#vector-dan-array",
    "title": "Greenhorn:feidlambda II",
    "section": "Vector dan Array",
    "text": "Vector dan Array\n\nIstilah array dapat diartikan range yang memiliki 1 dimensi atau 2 dimensi.\nArray dapat dibangkitkan menggunakan sintaks “={...}”. Dengan “,” sebagai pemisah kolom (sepanjang baris), “;” sebagai pemisah baris (sepanjang kolom).\n\n\\[\n\\texttt{{1,2,3}}\n=\n\\begin{bmatrix}\n  1 & 2 & 3\n\\end{bmatrix}\n,\n\\texttt{{1;2;3}}\n=\n\\begin{bmatrix}\n  1\\\\\n  2\\\\\n  3\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{\\{}\n  \\underbrace{\\texttt{1,2,3}}_{\\textit{baris ke-}1}\n  \\texttt{;}\n  \\underbrace{\\texttt{4,5,6}}_{\\textit{baris ke-}2}\n  \\texttt{;}\n  \\underbrace{\\texttt{7,8,9}}_{\\textit{baris ke-}3}\n\\texttt{\\}}\n=\n\\begin{bmatrix}\n  1 & 2 & 3\\\\\n  4 & 5 & 6\\\\\n  7 & 8 & 9\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#not-1",
    "href": "greenhorn/feidlambda-2/presentation.html#not-1",
    "title": "Greenhorn:feidlambda II",
    "section": "NOT (1)",
    "text": "NOT (1)\nSyntax\n=NOT(logical)\n\nFungsi NOT membalikkan nilai argumennya. 1\nMenghasilkan nilai TRUE ketika kondisi bernilai FALSE, dan berlaku sebaliknya.\nNOT(TRUE) = FALSE\nNOT(FALSE) = TRUE\n\nNOT (Fungsi NOT), Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#not-2",
    "href": "greenhorn/feidlambda-2/presentation.html#not-2",
    "title": "Greenhorn:feidlambda II",
    "section": "NOT (2)",
    "text": "NOT (2)\n\\[\n\\texttt{NOT}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE}\\\\\n    \\texttt{FALSE}\\\\\n    \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{FALSE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{NOT}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{FALSE} & \\texttt{TRUE} & \\texttt{FALSE}\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{NOT}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE} & \\texttt{FALSE}\\\\\n    \\texttt{FALSE} & \\texttt{TRUE}\\\\\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{FALSE} & \\texttt{TRUE}\\\\\n  \\texttt{TRUE} & \\texttt{FALSE}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#and-1",
    "href": "greenhorn/feidlambda-2/presentation.html#and-1",
    "title": "Greenhorn:feidlambda II",
    "section": "AND (1)",
    "text": "AND (1)\n\nFungsi logika, untuk menentukan apakah semua kondisi dalam sebuah tes adalah TRUE. 1\n\n=AND(logical1, [logical2], ...)\n\nMenghasilkan nilai TRUE ketika seluruh kondisi bernilai TRUE. Jika terdapat satu atau lebih bernilai FALSE maka menghasilkan nilai FALSE.\nJika input berupa logical array saja (AND(logical_array)), maka akan mengevaluasi seluruh elemen pada logical array (AND(elemen_1, elemen_2, ...)).\n\nAND (Fungsi AND), Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#and-2",
    "href": "greenhorn/feidlambda-2/presentation.html#and-2",
    "title": "Greenhorn:feidlambda II",
    "section": "AND (2)",
    "text": "AND (2)\n\\[\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#and-3",
    "href": "greenhorn/feidlambda-2/presentation.html#and-3",
    "title": "Greenhorn:feidlambda II",
    "section": "AND (3)",
    "text": "AND (3)\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{TRUE} \\\\ \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} \\\\\n  \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n  ,\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#or-1",
    "href": "greenhorn/feidlambda-2/presentation.html#or-1",
    "title": "Greenhorn:feidlambda II",
    "section": "OR (1)",
    "text": "OR (1)\n\nFungsi logika, untuk menentukan apakah salah satu kondisi dalam sebuah tes adalah TRUE. 1\n\n=OR(logical1, [logical2], ...)\n\nMenghasilkan nilai TRUE ketika salah satu kondisi bernilai TRUE.\nJika input berupa logical array saja (OR(logical_array)), maka akan mengevaluasi seluruh elemen pada logical array (OR(elemen_1, elemen_2, ...)).\n\nOR function, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#or-2",
    "href": "greenhorn/feidlambda-2/presentation.html#or-2",
    "title": "Greenhorn:feidlambda II",
    "section": "OR (2)",
    "text": "OR (2)\n\\[\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#or-3",
    "href": "greenhorn/feidlambda-2/presentation.html#or-3",
    "title": "Greenhorn:feidlambda II",
    "section": "OR (3)",
    "text": "OR (3)\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{TRUE} \\\\ \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} \\\\\n  \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{OR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n  ,\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{OR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xor-1",
    "href": "greenhorn/feidlambda-2/presentation.html#xor-1",
    "title": "Greenhorn:feidlambda II",
    "section": "XOR (1)",
    "text": "XOR (1)\n\nFungsi XOR mengembalikan logika Exclusive Or dari semua argumen. 1\n\n=XOR(logical1, [logical2], ...)\n\nMenghasilkan nilai TRUE ketika hanya satu kondisi bernilai TRUE.\nJika input berupa logical array saja (XOR(logical_array)), maka akan mengevaluasi seluruh elemen pada logical array (XOR(elemen_1, elemen_2, ...)).\n\nXOR function, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xor-2",
    "href": "greenhorn/feidlambda-2/presentation.html#xor-2",
    "title": "Greenhorn:feidlambda II",
    "section": "XOR (2)",
    "text": "XOR (2)\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{TRUE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{FALSE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xor-3",
    "href": "greenhorn/feidlambda-2/presentation.html#xor-3",
    "title": "Greenhorn:feidlambda II",
    "section": "XOR (3)",
    "text": "XOR (3)\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} & \\texttt{FALSE} \\\\\n  \\texttt{FALSE} & \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{TRUE}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\texttt{XOR}\n\\left(\n  \\begin{bmatrix}\n  \\texttt{TRUE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n  ,\n  \\begin{bmatrix}\n  \\texttt{FALSE} \\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{XOR}\n\\left(\n  \\texttt{TRUE}, \\texttt{FALSE},\n  \\texttt{FALSE}, \\texttt{FALSE}\n\\right)\n=\n\\texttt{TRUE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#logical-rightarrow-number-1",
    "href": "greenhorn/feidlambda-2/presentation.html#logical-rightarrow-number-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Logical \\(\\Rightarrow\\) Number (1)",
    "text": "Logical \\(\\Rightarrow\\) Number (1)\n\n\\(\\texttt{FALSE} = 0\\). Bernilai FALSE jika bernilai 0. \\(\\{ x = 0 \\}\\)\n\\(\\texttt{TRUE} \\neq 0\\). Bernilai TRUE jika nilai bukan 0. \\(\\{ x \\in \\mathbb{R}\\ |\\ x \\neq 0 \\}\\)\nMengubah logical menjadi number dapat menggunakan fungsi INT(...). 1\n\\(\\texttt{INT}(\\texttt{TRUE}) = 1\\).\n\\(\\texttt{INT}(\\texttt{FALSE}) = 0\\).\n\nINT (FUNGSI INT), Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-1",
    "href": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Logical dan operator aritmatika (1)",
    "text": "Logical dan operator aritmatika (1)\n\nLogical array akan diubah menjadi numeric array ketika bertemu operator aritmatika (+, *, -, /).\nPerubahan logical menjadi number sama dengan proses penggunaan fungsi INT(...).\nOperator aritmatika perkalian (* / \\(\\times\\)) dan penambahan (+) dapat berperilaku seperti fungsi logical AND (*) dan OR (+).\nUmumnya operator perkalian setiap elemen dalam suatu vector atau matriks (array) menggunakan simbol \\(\\odot\\). Akan tetapi, pada materi ini simbol \\(\\times\\) diartikan sebagai perkalian setiap elemen (element-wise) dan bukan perkalian matriks."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-2",
    "href": "greenhorn/feidlambda-2/presentation.html#logical-dan-operator-aritmatika-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Logical dan operator aritmatika (2)",
    "text": "Logical dan operator aritmatika (2)\n\\[\n\\mathbf{X}\n\\underbrace{\\textsf{ operator }}_{\\times\\ |\\ +}\n\\mathbf{Y}\n\\Rightarrow\n\\mathbf{P}\n\\underbrace{\\textsf{ operator }}_{\\times\\ |\\ +}\n\\mathbf{Q}\n\\]\n\\[\n\\mathbf{X} \\in \\mathbb{B}_l, \\mathbf{Y} \\in \\mathbb{B}_l,\n\\mathbf{P} \\in \\mathbb{B}_i, \\mathbf{Q} \\in \\mathbb{B}_i\n\\]\n\nSimbol \\(\\mathbb{B}\\) untuk menyatakan nilai logical atau boolean. 1\n\n\\[\n\\mathbb{B}_l =\n\\{\n  \\texttt{TRUE, FALSE}\n\\}\n=\n\\{\n  \\text{T}, \\text{F}\n\\}\n,\n\\mathbb{B}_i =\n\\{\n  0, 1\n\\}\n\\]\n\\[\n\\overbrace{\n  \\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n}^{\\text{logical array}}\n\\underbrace{\\ \\times\\ |\\ +\\ }_\\text{operator}\n\\overbrace{\n  \\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n  \\end{bmatrix}\n}^{\\text{logical array}}\n\\Rightarrow\n\\overbrace{\n  \\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n  \\end{bmatrix}\n}^{\\text{numeric array}}\n\\underbrace{\\ \\times\\ |\\ +\\ }_\\text{operator}\n\\overbrace{\n  \\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n  \\end{bmatrix}\n}^{\\text{numeric array}}\n\\]\nBoolean Domain"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-1",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator perkalian * sebagai AND (1)",
    "text": "Operator perkalian * sebagai AND (1)\n\nSetiap nilai yang dikalikan dengan 0 akan bernilai 0.\n\n\\[\nx \\times 0 = 0,\\ \\{x \\in \\mathbb{R}\\}\n\\]\n\nSetiap nilai yang dikalikan dengan FALSE akan bernilai FALSE."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-2",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-perkalian-sebagai-and-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator perkalian * sebagai AND (2)",
    "text": "Operator perkalian * sebagai AND (2)\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n=\n\\underbrace{\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n}_{\\textit{hasil akhir}}\n\\]\n\\[\n\\Rightarrow\n\\underbrace{\n  \\left(\n    \\begin{bmatrix}\n    1\\\\\n    0\\\\\n    0\n  \\end{bmatrix}\n  \\neq 0\n  \\right)\n}_{\\textit{mengubah menjadi logical}}\n=\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-1",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator penambahan + sebagai OR (1)",
    "text": "Operator penambahan + sebagai OR (1)\n\nBerlaku seperti penambahan pada umumnya.\n\n\\[\nx + 0 = x, x \\in \\mathbb{R}\n\\]\n\\[\nx + y = x + y,  x \\in \\mathbb{R}, y \\in \\mathbb{R}\n\\]\n\nSetiap nilai yang bukan 0 bernilai TRUE. \\(\\texttt{TRUE} \\neq 0\\)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-2",
    "href": "greenhorn/feidlambda-2/presentation.html#operator-penambahan-sebagai-or-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Operator penambahan + sebagai OR (2)",
    "text": "Operator penambahan + sebagai OR (2)\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n=\n\\underbrace{\n\\begin{bmatrix}\n  2\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n}_{\\textit{hasil akhir}}\n\\]\n\\[\n\\Rightarrow\n\\underbrace{\n  \\left(\n    \\begin{bmatrix}\n      2\\\\\n      1\\\\\n      0\n    \\end{bmatrix}\n    \\neq 0\n  \\right)\n}_{\\textit{mengubah menjadi logical}}\n=\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-1",
    "href": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Number \\(\\Rightarrow\\) Logical (1)",
    "text": "Number \\(\\Rightarrow\\) Logical (1)\n\nNumeric array dapat digunakan sebagai kondisi logical.\nSetiap numeric array yang digunakan sebagai conditional secara tidak langsung berubah menjadi logical array.\nPerubahan tersebut sama saja jika membandingkan array tidak sama dengan 0. \\[\n\\left(\n\\mathbf{x}_{\\text{number}} \\neq 0\n\\right)\n=\n\\mathbf{x}_{\\text{logical}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2",
    "href": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Number \\(\\Rightarrow\\) Logical (2)",
    "text": "Number \\(\\Rightarrow\\) Logical (2)\n\\[\n\\texttt{NOT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3\\\\\n      -1\\\\\n      0\n    \\end{bmatrix}\n  }_{\\textit{numeric}}\n  \\equiv\n  0\n\\right)\n=\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3\\\\\n      -1\\\\\n      0\n    \\end{bmatrix}\n  }_{\\textit{numeric}}\n  \\neq\n  0\n\\right)\n=\n\\underbrace{\n  \\begin{bmatrix}\n    \\texttt{TRUE}\\\\\n    \\texttt{TRUE}\\\\\n    \\texttt{FALSE}\n  \\end{bmatrix}\n}_{\\textit{logical}}\n\\]\n\nSama saja dengan formula =NOT(array=0) atau =array<>0."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2-1",
    "href": "greenhorn/feidlambda-2/presentation.html#number-rightarrow-logical-2-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Number \\(\\Rightarrow\\) Logical (2)",
    "text": "Number \\(\\Rightarrow\\) Logical (2)\n\\[\n\\texttt{IF}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3\\\\\n      -1\\\\\n      0\n    \\end{bmatrix}\n  }_{\\textit{numeric}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{TRUE}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{FALSE}}\n\\right)\n\\Rightarrow\n\\texttt{IF}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      \\texttt{TRUE}\\\\\n      \\texttt{TRUE}\\\\\n      \\texttt{FALSE}\n    \\end{bmatrix}\n  }_{\\textit{logical}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{TRUE}}\n  ,\n  \\underbrace{\\dots}_{\\texttt{FALSE}}\n\\right)\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#yang-perlu-diperhatikan",
    "href": "greenhorn/feidlambda-2/presentation.html#yang-perlu-diperhatikan",
    "title": "Greenhorn:feidlambda II",
    "section": "Yang perlu diperhatikan",
    "text": "Yang perlu diperhatikan\n\nHasil dari logical array bertemu dengan operator aritmatika selalu numeric array.\n\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{FALSE}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  \\texttt{FALSE}\\\\\n  \\texttt{TRUE}\\\\\n  \\texttt{TRUE}\n\\end{bmatrix}\n\\Rightarrow\n\\begin{bmatrix}\n  1\\\\\n  0\\\\\n  0\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  0\n\\end{bmatrix}\n+\n\\begin{bmatrix}\n  0\\\\\n  1\\\\\n  1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  1\n\\end{bmatrix}\n\\]\n\nJika numeric array digunakan sebagai argumen conditional, maka akan dikonversikan menjadi logical array."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#fungsi-is...",
    "href": "greenhorn/feidlambda-2/presentation.html#fungsi-is...",
    "title": "Greenhorn:feidlambda II",
    "section": "Fungsi IS*(...)",
    "text": "Fungsi IS*(...)\nSYNTAX\n=IS*(value)\n\nMemeriksa nilai tertentu dan mengembalikan TRUE atau FALSE bergantung pada hasilnya. 1\nISBLANK(...) bernilai TRUE jika sel kosong.\nISNUMBER(...) bernilai TRUE jika sel berisikan angka.\n\nFungsi IS, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#periksa-error-kosong",
    "href": "greenhorn/feidlambda-2/presentation.html#periksa-error-kosong",
    "title": "Greenhorn:feidlambda II",
    "section": "Periksa error / kosong",
    "text": "Periksa error / kosong\n\nISNA(...): Cek nilai apakah #N/A.\nISERR(...): Cek nilai apakah error selain #N/A (#VALUE!, #REF!, #DIV/0!, #NUM!, #NAME?, atau #NULL!).\nISERROR(...): Cek nilai apakah error (seluruh jenis error).\nISBLANK(...): Cek nilai apakah kosong."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-sel",
    "href": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-sel",
    "title": "Greenhorn:feidlambda II",
    "section": "Periksa jenis sel",
    "text": "Periksa jenis sel\n\nISLOGICAL(...): Cek nilai apakah logical (TRUE atau FALSE).\nISNUMBER(...): Cek nilai apakah angka (\\(\\mathbb{R}\\)).\nISTEXT(...): Cek nilai apakah teks. Dan ISNONTEXT(...): Cek niai apakah bukan teks (number, logical, error)\nISFORMULA(...): Cek nilai apakah formula."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-bilangan",
    "href": "greenhorn/feidlambda-2/presentation.html#periksa-jenis-bilangan",
    "title": "Greenhorn:feidlambda II",
    "section": "Periksa jenis bilangan",
    "text": "Periksa jenis bilangan\n\nISEVEN(...): Cek nilai apakah bilangan genap.\nISODD(...): Cek nilai apakah bilangan ganjil."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (1)",
    "text": "Validasi dengan ISNUMBER(...) (1)\n\\[\nf : \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x}) = \\mathbf{y} = \\mathbf{x} + 2\n\\]\n\\[\n\\mathbf{x} \\in \\mathbb{R}, \\mathbf{y} \\in \\mathbb{R}\n\\]\n\\[\n\\mathbf{x}\n\\mapsto\n\\mathbf{x} + 2\n\\]\n\nUmumnya nilai \\(\\mathbf{y}\\) dihitung dengan formula =x+2 dengan asumsi \\(\\mathbf{x}\\) bernilai angka \\(\\{ \\mathbf{x} \\in \\mathbb{R} \\}\\).\n\n\\[\n\\mathbf{x}\n=\n\\begin{bmatrix}\n  3 \\\\ 2 \\\\ 7\n\\end{bmatrix}\n\\mapsto\nf(\\mathbf{x})\n=\n\\begin{bmatrix}\n  3 \\\\ 2 \\\\ 7\n\\end{bmatrix}\n+ 2\n=\n\\begin{bmatrix}\n  5 \\\\ 4 \\\\ 9\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (2)",
    "text": "Validasi dengan ISNUMBER(...) (2)\n\nBagaimana jika \\(\\mathbf{x}\\) memiliki elemen yang bukan angka yaitu text / error / logical?\n\n\\[\n\\mathbf{x}\n=\n\\begin{bmatrix}\n  3 \\\\ \\textrm{bob} \\\\ 2\n\\end{bmatrix}\n\\mapsto\nf(\\mathbf{x})\n=\n\\begin{bmatrix}\n  3 \\\\ \\textrm{bob} \\\\ 2\n\\end{bmatrix}\n+ 2\n=\n\\begin{bmatrix}\n  5 \\\\ \\texttt{#VALUE!} \\\\ 2\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (3)",
    "text": "Validasi dengan ISNUMBER(...) (3)\n\nValidasi input menggunakan ISNUMBER(...)\n\n\\[\n\\mathbf{x}\n=\n\\begin{bmatrix}\n  3 \\\\ \\textrm{bob} \\\\ 2\n\\end{bmatrix}\n\\mapsto\n\\texttt{ISNUMBER}\n\\left(\n  \\mathbf{x}\n\\right)\n=\n\\texttt{ISNUMBER}\n\\left(\n  \\begin{bmatrix}\n    3 \\\\ \\textrm{bob} \\\\ 2\n  \\end{bmatrix}\n\\right)\n=\n\\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{TRUE}\n\\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix}\n  \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{TRUE}\n\\end{bmatrix}\n\\mapsto\n\\texttt{AND}\n\\left(\n  \\mathbf{x}\n\\right)\n=\n\\texttt{AND}\n\\left(\n  \\begin{bmatrix}\n    \\texttt{TRUE} \\\\ \\texttt{FALSE} \\\\ \\texttt{TRUE}\n  \\end{bmatrix}\n\\right)\n=\n\\texttt{FALSE}\n\\]\n\\[\n\\mathbf{x}\n\\mapsto\n\\texttt{AND}(\n  \\texttt{ISNUMBER}(\n    \\mathbf{x}\n  )\n)\n=\n\\texttt{AND}(\n  \\texttt{ISNUMBER}(\n    \\begin{bmatrix}\n      3 \\\\ \\textrm{bob} \\\\ 2\n    \\end{bmatrix}\n  )\n)\n=\n\\texttt{FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-dengan-isnumber...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi dengan ISNUMBER(...) (4)",
    "text": "Validasi dengan ISNUMBER(...) (4)\n\\[\n\\begin{equation}\n  \\mathbf{x}\n  \\mapsto\n  \\texttt{AND}\n  (\n    \\texttt{ISNUMBER}(\\mathbf{x})\n  )\n  =\n  \\begin{cases}\n    \\texttt{TRUE} & f : \\mathbf{x} \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n    \\texttt{FALSE} & \\textrm{return}\\ \\texttt{#VALUE!} \\\\\n    \\texttt{FALSE} & \\mathbf{x} \\mapsto g(\\mathbf{x}) = \\texttt{FILTER}(\\dots) \\mapsto \\\\\n    & f: g(\\mathbf{x}) \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n  \\end{cases}\n\\end{equation}\n\\]\n\nValidasi ini dapat diimplementasikan ketika terdapat ketidakpastian jika \\(\\mathbf{x}\\) dapat bernilai bukan angka (\\(\\mathbf{x} \\in \\mathbb{R} \\lor \\mathbf{x} \\notin \\mathbb{R}\\))\nSolusi lain dengan melakukan filter pada \\(\\mathbf{x}\\) dan hanya mengambil elemen yang angka dengan FILTER(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (1)",
    "text": "FILTER(...) (1)\n\nFILTER(...): Fungsi FILTER memungkinkan Anda memfilter rentang data berdasarkan kriteria yang ditetapkan. 1\n\n=FILTER(array, include, [if_empty])\n\nArgumen include harus berupa vector (kolom atau baris). dan jumlah kolom/baris harus sama dengan array.\nArgumen if_empty dapat diisi dengan nilai ketika argumen include kosong atau FALSE.\n\nFungsi FILTER, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (2)",
    "text": "FILTER(...) (2)\n\\[\n\\texttt{FILTER}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      10 & 8\\\\\n      \\textit{A} & -100\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        \\texttt{TRUE}\\\\\n        \\texttt{FALSE}\\\\\n        \\texttt{TRUE}\n      \\end{bmatrix}\n    }^{\\textit{logical column vector}}\n  }_{\\texttt{include}}\n\\right)\n=\n\\underbrace{\n  \\begin{bmatrix}\n      10 & 8\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n}_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{FILTER}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      10 & 8\\\\\n      \\textit{A} & -100\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        \\texttt{FALSE} & \\texttt{TRUE}\n      \\end{bmatrix}\n    }^{\\textit{logical row vector}}\n  }_{\\texttt{include}}\n\\right)\n=\n\\underbrace{\n  \\begin{bmatrix}\n      8\\\\\n      -100\\\\\n      \\textit{y}\n    \\end{bmatrix}\n}_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (3)",
    "text": "FILTER(...) (3)\n\\[\n\\texttt{FILTER}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      10 & 8\\\\\n      \\textit{A} & -100\\\\\n      -3 & \\textit{y}\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        \\texttt{FALSE}\\\\\n        \\texttt{FALSE}\\\\\n        \\texttt{FALSE}\n      \\end{bmatrix}\n    }^{\\textit{logical column vector}}\n  }_{\\texttt{include}}\n  ,\n  \\underbrace{\n    \\textrm{tidak ada}\n  }_{\\texttt{if_empty}}\n\\right)\n=\n\\textrm{tidak ada}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#filter...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#filter...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "FILTER(...) (4)",
    "text": "FILTER(...) (4)\n\\[\n\\texttt{array} = \\mathbf{A} \\rightarrow \\mathbf{A} \\in \\mathbb{U}^{m \\times n}, \\{m, n \\in \\mathbb{N}\\ |\\ m, n \\neq 0 \\}\n\\]\n\\[\n\\mathbb{U} = \\{ \\textrm{seluruh nilai } u \\textrm{ yang dapat digunakan di Excel}\\}\n\\]\n\n\\(m\\) menunjukkan jumlah baris dan \\(n\\) menunjukkan jumlah kolom.\n\n\\[\n\\texttt{include} = \\mathbf{i} \\rightarrow \\mathbf{i} \\in \\mathbb{B}^{k}, \\{k = m \\lor k = n\\}\n\\]\n\n\\(\\mathbf{i}\\) selalu berupa logical vector dengan jumlah baris/kolom \\(k\\) sama dengan \\(m \\lor n\\)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (1)",
    "text": "UNIQUE(...) (1)\n\nUNIQUE(...): Fungsi UNIQUE menghasilkan daftar nilai yang unik dalam daftar atau rentang. 1\n\n=UNIQUE(array, [by_col], [exactly_once])\n\nPenggunaan argumen by_col untuk mencari nilai unik untuk setiap baris atau kolom. Nilai default argumen by_col <- FALSE.\nArgumen exactly_once dapat digunakan untuk menyaring nilai unik yang muncul lebih dari satu kali. Jika exactly_once <- TRUE, maka jika terdapat nilai unik yang muncul dua kali akan dihapus. Nilai default argumen exactly_once <- FALSE.\n\nFungsi UNIQUE, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (2)",
    "text": "UNIQUE(...) (2)\n\\[\n\\texttt{UNIQUE}\n\\left(\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        1 & 1 & 3 & 1\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}      \n    }^{\\textit{array / vector}}\n  }_{\\texttt{array}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n    \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (3)",
    "text": "UNIQUE(...) (3)\n\\[\n\\texttt{UNIQUE}\n\\left(\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        1 & 1 & 3 & 1\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}      \n    }^{\\textit{array / vector}}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{by_col}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3\\\\\n        4 & 2 & 7\\\\\n        3 & 2 & 8\\\\\n        1 & 1 & 3\\\\\n        5 & 2 & 9\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#unique...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#unique...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "UNIQUE(...) (4)",
    "text": "UNIQUE(...) (4)\n\\[\n\\texttt{UNIQUE}\n\\left(\n  \\underbrace{\n    \\overbrace{\n      \\begin{bmatrix}\n        1 & 1 & 3 & 1\\\\\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        1 & 1 & 3 & 1\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}      \n    }^{\\textit{array / vector}}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    \\texttt{ FALSE }\n  }_{\\texttt{by_col}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{exactly_once}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        4 & 2 & 7 & 2\\\\\n        3 & 2 & 8 & 2\\\\\n        5 & 2 & 9 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sequence...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sequence...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "SEQUENCE(...) (1)",
    "text": "SEQUENCE(...) (1)\n\nSEQUENCE(...): Fungsi SEQUENCE memungkinkan Anda menghasilkan daftar angka yang berurutan dalam larik seperti \\({1, 2, 3, 4, \\dots}\\). 1\n\n=SEQUENCE(rows, [columns], [start], [step])\n\nHasil SEQUENCE(...) => numeric vector/array.\nNilai default argumen: columns <- 1, start <- 1, step <- 1.\n\nFungsi SEQUENCE, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sequence...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sequence...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "SEQUENCE(...) (2)",
    "text": "SEQUENCE(...) (2)\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    5\n  }_{\\texttt{rows}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        1\\\\\n        2\\\\\n        3\\\\\n        4\\\\\n        5\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    4\n  }_{\\texttt{columns}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        1   & 2  & 3    & 4\\\\\n        5   & 6  & 7    & 8\\\\\n        9   & 10 & 11   & 12\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sequence...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sequence...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "SEQUENCE(...) (3)",
    "text": "SEQUENCE(...) (3)\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    4\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{start}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        10 & 11 & 12 & 13\\\\\n        14 & 15 & 16 & 17\\\\\n        18 & 19 & 20 & 21\\\\\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SEQUENCE}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    4\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{start}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{step}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        10 & 13 & 16 & 19\\\\\n        22 & 25 & 28 & 31\\\\\n        34 & 37 & 40 & 43\\\\\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#randarray...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#randarray...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "RANDARRAY(...) (1)",
    "text": "RANDARRAY(...) (1)\n\nRANDARRAY(...): Fungsi RANDARRAY menghasilkan larik angka acak. Anda dapat menentukan jumlah baris dan kolom yang akan diisi, nilai minimum dan maksimum, dan apakah fungsi mengembalikan bilangan bulat atau nilai desimal. 1\n\n=RANDARRAY([rows], [columns], [min], [max], [whole_number])\n\nNilai default argumen: rows <- 1, columns <- 1, min <- 0, max <- 1, whole_number <- FALSE.\nJika tidak diisi argumen maka hasil RANDARRAY() adalah bilangan real \\(\\mathbb{R}\\) acak dengan rentang \\([0, 1]\\).\n\nFungsi RANDARRAY, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#randarray...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#randarray...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "RANDARRAY(...) (2)",
    "text": "RANDARRAY(...) (2)\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        0.036290129\\\\\n        0.831941087\\\\\n        0.596526220\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{columns}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        0.950708256 & 0.044725252\\\\\n        0.111202134 & 0.34866703\\\\\n        0.119602266 & 0.792763221\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#randarray...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#randarray...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "RANDARRAY(...) (3)",
    "text": "RANDARRAY(...) (3)\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{min}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{max}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        5.033450196 & 7.903953859\\\\\n        7.918426053 & 6.750036234\\\\\n        7.926034250 & 3.596169723\\\\\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{RANDARRAY}\n\\left(\n  \\underbrace{\n    3\n  }_{\\texttt{rows}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{columns}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{min}}\n  ,\n  \\underbrace{\n    10\n  }_{\\texttt{max}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{whole_number}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        9 & 4\\\\\n        5 & 6\\\\\n        7 & 8\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sort...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sort...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "SORT(...) (1)",
    "text": "SORT(...) (1)\n\nSORT(...): Fungsi SORT mengurutkan konten rentang atau larik. 1\n\n=SORT(array, [sort_index], [sort_order], [by_col])\n\nNilai default argumen: sort_index <- 1, sort_order <- 1 (Ascending), by_col <- FALSE.\n\nFungsi SORT, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sort...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sort...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "SORT(...) (2)",
    "text": "SORT(...) (2)\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        2 & 3 & 1 & 2\\\\\n        3 & 2 & 4 & 4\\\\\n        4 & 2 & 3 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{sort_index}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        2 & 3 & 1 & 2\\\\\n        4 & 2 & 3 & 2\\\\\n        3 & 2 & 4 & 4\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sort...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sort...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "SORT(...) (3)",
    "text": "SORT(...) (3)\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    3\n  }_{\\texttt{sort_index}}\n  ,\n  \\underbrace{\n    -1\n  }_{\\texttt{sort_order}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        3 & 2 & 4 & 4\\\\\n        4 & 2 & 3 & 2\\\\\n        2 & 3 & 1 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]\n\\[\n\\texttt{SORT}\n\\left(\n  \\underbrace{\n    \\begin{bmatrix}\n      3 & 2 & 4 & 4\\\\\n      2 & 3 & 1 & 2\\\\\n      4 & 2 & 3 & 2\n    \\end{bmatrix}\n  }_{\\texttt{array}}\n  ,\n  \\underbrace{\n    2\n  }_{\\texttt{sort_index}}\n  ,\n  \\underbrace{\n    1\n  }_{\\texttt{sort_order}}\n  ,\n  \\underbrace{\n    \\texttt{ TRUE }\n  }_{\\texttt{by_col}}\n\\right)\n\\Rightarrow\n  \\underbrace{\n      \\begin{bmatrix}\n        4 & 3 & 4 & 2\\\\\n        1 & 2 & 2 & 3\\\\\n        3 & 4 & 2 & 2\n      \\end{bmatrix}\n  }_{\\textit{hasil}}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (1)",
    "text": "SORTBY(...) (1)\n\nSORTBY(...): Fungsi SORTBY mengurutkan konten rentang atau larik berdasarkan nilai dalam rentang atau larik yang terkait. 1\n\n=SORTBY(array, by_array1, [sort_order1], [by_array2], [sort_order2], ...)\n\nNilai default sort_order <- 1 (ascending).\nNilai by_array harus berupa vektor atau array 1 dimensi. Dan jenisnya harus sama dengan nilai by_array lainnya (tidak boleh berbeda dimensinya).\nJika diurutkan hanya berdasarkan satu array dan berdasarkan kolom/baris di dalam array tersebut, sebaiknya menggunakan SORT.\n\nFungsi SORTBY, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (2)",
    "text": "SORTBY(...) (2)\n\\[\n\\mathbf{A}\n=\n\\begin{bmatrix}\n  \\textrm{A} & \\textrm{BA} & \\textrm{CBBA}\\\\\n  \\textrm{B} & \\textrm{CB} & \\textrm{DCCB}\\\\\n  \\textrm{C} & \\textrm{DC} & \\textrm{EDDC}\\\\\n  \\textrm{D} & \\textrm{ED} & \\textrm{FEED}\\\\\n  \\textrm{E} & \\textrm{FE} & \\textrm{GFFE}\\\\\n  \\textrm{F} & \\textrm{GF} & \\textrm{IGGF}\\\\\n  \\textrm{G} & \\textrm{IG} & \\textrm{AIG}\n\\end{bmatrix},\n\\mathbf{c}_1\n=\n\\begin{bmatrix}\n  1\\\\\n  3\\\\\n  3\\\\\n  2\\\\\n  2\\\\\n  1\\\\\n  4\\\\\n\\end{bmatrix}\n,\n\\mathbf{c}_2\n=\n\\begin{bmatrix}\n  1\\\\\n  3\\\\\n  5\\\\\n  6\\\\\n  2\\\\\n  7\\\\\n  8\\\\\n\\end{bmatrix}\n\\]\n\\[\n\\mathbf{r}_1\n=\n\\begin{bmatrix}\n  3 & 1 & 1\n\\end{bmatrix}\n,\n\\mathbf{r}_2\n=\n\\begin{bmatrix}\n  7 & 1 & 3\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{SORTBY}(\n  \\mathbf{A}, \\mathbf{c}_1\n) \\lor\n\\texttt{SORTBY}(\n  \\mathbf{A},\n  \\mathbf{r}_1,\n  -1,\n)\n\\]\n\\[\n\\texttt{SORTBY}(\n  \\mathbf{A},\n  \\mathbf{c}_1,,\n  \\mathbf{c}_2,-1\n) \\lor\n\\texttt{SORTBY}(\n  \\mathbf{A},\n  \\mathbf{r}_2,-1,\n  \\mathbf{r}_1\n)\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (3)",
    "text": "SORTBY(...) (3)\n\\[\n\\mathbf{A}, \\mathbf{c}_1\n\\overbrace{\\longmapsto}^{\n  \\texttt{SORTBY}(\n    \\mathbf{A}, \\mathbf{c}_1\n  )\n}\n\\begin{bmatrix}\n  A & BA & CBBA\\\\\n  F & GF & IGGF\\\\\n  D & ED & FEED\\\\\n  E & FE & GFFE\\\\\n  B & CB & DCCB\\\\\n  C & DC & EDDC\\\\\n  G & IG & AIG\\\\\n\\end{bmatrix}\n,\n\\texttt{index} \\leftarrow\n\\begin{bmatrix}\n  1\\\\\n  6\\\\\n  4\\\\\n  5\\\\\n  2\\\\\n  3\\\\\n  7\\\\\n\\end{bmatrix}\n,\n\\texttt{SORT}(\\mathbf{c}_1) =\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  2\\\\\n  2\\\\\n  3\\\\\n  3\\\\\n  4\\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sortby...-4",
    "href": "greenhorn/feidlambda-2/presentation.html#sortby...-4",
    "title": "Greenhorn:feidlambda II",
    "section": "SORTBY(...) (4)",
    "text": "SORTBY(...) (4)\n\\[\n\\mathbf{A}, \\mathbf{c}_1, \\mathbf{c}_2\n\\overbrace{\\longmapsto}^{\n  \\texttt{SORTBY}(\n    \\mathbf{A}, \\mathbf{c}_1,, \\mathbf{c}_2, -1\n  )\n}\n\\begin{bmatrix}\n  F & GF & IGGF\\\\\n  A & BA & CBBA\\\\\n  D & ED & FEED\\\\\n  E & FE & GFFE\\\\\n  C & DC & EDDC\\\\\n  B & CB & DCCB\\\\\n  G & IG & AIG\\\\\n\\end{bmatrix}\n,\n\\texttt{index} \\leftarrow\n\\begin{bmatrix}\n  6\\\\\n  1\\\\\n  4\\\\\n  5\\\\\n  3\\\\\n  2\\\\\n  7\\\\\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{SORT}(\\mathbf{c}_1) =\n\\begin{bmatrix}\n  1\\\\\n  1\\\\\n  2\\\\\n  2\\\\\n  3\\\\\n  3\\\\\n  4\\\\\n\\end{bmatrix}\n,\n\\texttt{SORT}(\\mathbf{c}_2, -1) =\n\\begin{bmatrix}\n  7\\\\\n  1\\\\\n  6\\\\\n  2\\\\\n  5\\\\\n  3\\\\\n  8\\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xlookup...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#xlookup...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "XLOOKUP(...) (1)",
    "text": "XLOOKUP(...) (1)\n\nXLOOKUP(...): Fungsi XLOOKUP mencari rentang atau array, lalu mengembalikan item yang terkait dengan kecocokan pertama yang ditemukannya. Jika tidak ada kecocokan, XLOOKUP dapat mengembalikan kecocokan terdekat (perkiraan). 1\n\n=XLOOKUP(lookup_value, lookup_array, return_array, [if_not_found], [match_mode], [search_mode])\nFungsi XLOOKUP, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#xmatch...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#xmatch...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "XMATCH(...) (1)",
    "text": "XMATCH(...) (1)\n\nXMATCH(...): Fungsi XMATCH mengembalikan posisi relatif item dalam array atau rentang sel. 1\n\n=XMATCH(lookup_value, lookup_array, [match_mode], [search_mode])\nFungsi XMATCH, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "CONCAT(...) dan TEXTJOIN(...) (1)",
    "text": "CONCAT(...) dan TEXTJOIN(...) (1)\n\nCONCAT(...): Fungsi CONCAT menggabungkan teks dari beberapa rentang dan/atau string, tetapi tidak menyediakan argumen pemisah atau IgnoreEmpty. 1\n\n=CONCAT(text1, [text2], ...)\n\nTEXTJOIN(...): Fungsi TEXTJOIN menggabungkan teks dari beberapa rentang dan/atau string, serta menyertakan pemisah yang Anda tentukan antara tiap nilai teks yang akan digabungkan. Jika pemisah adalah string teks kosong, fungsi ini akan secara efektif menggabungkan rentang. 2\n\n=TEXTJOIN(delimiter, ignore_empty, text1, [text2], ...)\nFungsi CONCAT, Microsoft Support.Fungsi TEXTJOIN, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "CONCAT(...) dan TEXTJOIN(...) (2)",
    "text": "CONCAT(...) dan TEXTJOIN(...) (2)\n\nHal yang membedakan TEXTJOIN(...) dengan CONCAT(...) adalah argumen karakter diantara teks gabungan dengan kondisi ketika sel kosong. Nilai TEXTJOIN(...) === CONCAT(...) ketika argumen delimeter <- \"\" dan ignore_empty <- TRUE.\n\n\\[\n\\mathbf{T} =\n\\begin{bmatrix}\n  \\textrm{nama} &\n  \\textrm{saya} &\n  \\textrm{taruma}\\\\\n  1 &\n  \\textrm{pergi} &\n  3 \\\\\n  \\texttt{TRUE} &\n  100 &\n  \\texttt{FALSE}\\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-3",
    "href": "greenhorn/feidlambda-2/presentation.html#concat...-dan-textjoin...-3",
    "title": "Greenhorn:feidlambda II",
    "section": "CONCAT(...) dan TEXTJOIN(...) (3)",
    "text": "CONCAT(...) dan TEXTJOIN(...) (3)\n\\[\n\\mathbf{T} =\n\\begin{bmatrix}\n  \\textrm{nama} &\n  \\textrm{saya} &\n  \\textrm{taruma}\\\\\n  1 &\n  \\textrm{pergi} &\n  3 \\\\\n  \\texttt{TRUE} &\n  100 &\n  \\texttt{FALSE}\\\\\n\\end{bmatrix}\n\\]\n\\[\n\\texttt{CONCAT}(\\mathbf{T}) =\n\\textrm{namasayataruma1pergi3TRUE100FALSE}\n\\]\n\\[\n\\texttt{TEXTJOIN}(\\texttt{\"\"}, \\texttt{TRUE}, \\mathbf{T}) =\n\\textrm{namasayataruma1pergi3TRUE100FALSE}\n\\]\n\\[\n\\texttt{TEXTJOIN}(\\texttt{\" \"}, \\texttt{TRUE}, \\mathbf{T}) =\n\\textrm{nama saya taruma 1 pergi 3 TRUE 100 FALSE}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#ifs...-dan-minifs...",
    "href": "greenhorn/feidlambda-2/presentation.html#ifs...-dan-minifs...",
    "title": "Greenhorn:feidlambda II",
    "section": "IFS(...) dan MINIFS(...)",
    "text": "IFS(...) dan MINIFS(...)\n\nIFS(...): Fungsi IFS memeriksa apakah satu atau beberapa kondisi terpenuhi dan mengembalikan nilai yang sesuai dengan kondisi TRUE pertama. IFS dapat menggantikan beberapa pernyataan IF yang bertumpuk, dan jauh lebih mudah dibaca dengan beberapa kondisi. 1\n\n=IFS(logical_test1, value_if_true1, [logical_test2, value_if_true2], [logical_test3, value_if_true3], ..., value_if_false)\n\nMINIFS(...) / MAXIFS(...): Fungsi MINIFS mengembalikan nilai minimal di antara sel yang ditentukan oleh kumpulan persyaratan atau kriteria tertentu / Fungsi MAXIFS mengembalikan nilai maksimal di antara sel yang ditentukan oleh kumpulan persyaratan atau kriteria tertentu. 2 3\n\n=[MIN/MAX]IFS([min/max]_range, criteria_range1, criteria1, [criteria_range2, criteria2], ...)\nFungsi IFS, Microsoft Support.Fungsi MINIFS, Microsoft Support.Fungsi MAXIFS, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-if...",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-if...",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH IFS (IF(...))",
    "text": "CONTOH IFS (IF(...))\n\\[\n[-\\infty,70) \\Rightarrow \\text{C}\\\\\n[70,85) \\Rightarrow \\text{B}\\\\\n[85,\\infty) \\Rightarrow \\text{A}\n\\]\n=IF(\n  x < 70, \"C\", \n  IF(\n    x < 85, \"B\",\n    \"A\"\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-ifs...",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-ifs-ifs...",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH IFS (IFS(...))",
    "text": "CONTOH IFS (IFS(...))\n\\[\n[-\\infty,70) \\Rightarrow \\text{C}\\\\\n[70,85) \\Rightarrow \\text{B}\\\\\n[85,\\infty) \\Rightarrow \\text{A}\n\\]\n=IFS(\n  x < 70, \"C\", \n  x < 85, \"B\",\n  TRUE, \"A\"\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#switch...",
    "href": "greenhorn/feidlambda-2/presentation.html#switch...",
    "title": "Greenhorn:feidlambda II",
    "section": "SWITCH(...)",
    "text": "SWITCH(...)\n\nSWITCH(...): Fungsi SWITCH mengevaluasi satu nilai (disebut ekspresi) terhadap daftar nilai, dan mengembalikan hasil yang terkait dengan nilai cocok pertama. Jika tidak terdapat kecocokan, nilai default opsional mungkin akan dikembalikan. 1\n\n=SWITCH(expression, value1, result1, [default or value2, result2], ..., [default or value3, result3])\nFungsi SWITCH, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#let...",
    "href": "greenhorn/feidlambda-2/presentation.html#let...",
    "title": "Greenhorn:feidlambda II",
    "section": "LET(...)",
    "text": "LET(...)\n\nLET(...): Fungsi LET menetapkan nama ke hasil perhitungan. Ini memungkinkan menyimpan perhitungan menengah, nilai, atau menetapkan nama di dalam rumus. Nama ini hanya berlaku di dalam lingkup LET fungsi. Mirip dengan variabel dalam pemrograman, LET dilakukan melalui Excel rumus asli Anda. 1\n\n=LET(name1, name_value1, calculation_or_name2, [name_value2, calculation_or_name2], ..., calculation)\nFungsi LET, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH LET(...) dan SWITCH(...)",
    "text": "CONTOH LET(...) dan SWITCH(...)\n\\[\n\\text{A} \\Rightarrow 90,\n\\text{B} \\Rightarrow 80,\n\\text{C} \\Rightarrow 70,\n\\text{D} \\Rightarrow 60,\\\\\n\\notin \\{\\text{A}, \\text{B}, \\text{C}, \\text{D}\\} \\Rightarrow 20\n\\]\n=IFS(\n  C$2 = \"A\", 90,\n  C$2 = \"B\", 80,\n  C$2 = \"C\", 70,\n  C$2 = \"D\", 60,\n  TRUE, 20\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-1",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-1",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH LET(...) dan SWITCH(...)",
    "text": "CONTOH LET(...) dan SWITCH(...)\n\\[\n\\text{A} \\Rightarrow 90,\n\\text{B} \\Rightarrow 80,\n\\text{C} \\Rightarrow 70,\n\\text{D} \\Rightarrow 60,\\\\\n\\notin \\{\\text{A}, \\text{B}, \\text{C}, \\text{D}\\} \\Rightarrow 20\n\\]\n=LET(\n  data, C$2,\n  IFS(\n    data = \"A\", 90,\n    data = \"B\", 80,\n    data = \"C\", 70,\n    data = \"D\", 60,\n    TRUE, 20\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-2",
    "href": "greenhorn/feidlambda-2/presentation.html#contoh-let...-dan-switch...-2",
    "title": "Greenhorn:feidlambda II",
    "section": "CONTOH LET(...) dan SWITCH(...)",
    "text": "CONTOH LET(...) dan SWITCH(...)\n\\[\n\\text{A} \\Rightarrow 90,\n\\text{B} \\Rightarrow 80,\n\\text{C} \\Rightarrow 70,\n\\text{D} \\Rightarrow 60,\\\\\n\\notin \\{\\text{A}, \\text{B}, \\text{C}, \\text{D}\\} \\Rightarrow 20\n\\]\n=LET(\n  data, C$2,\n  SWITCH(\n    data,\n    \"A\", 90,\n    \"B\", 80,\n    \"C\", 70,\n    \"D\", 60,\n    20\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#kasus-validasi",
    "href": "greenhorn/feidlambda-2/presentation.html#kasus-validasi",
    "title": "Greenhorn:feidlambda II",
    "section": "Kasus validasi",
    "text": "Kasus validasi\n\\[\nf : \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x}) = \\mathbf{y} = \\mathbf{x} + 2\n\\]\n\\[\n\\mathbf{x} \\in \\mathbb{R}, \\mathbf{y} \\in \\mathbb{R}\n\\]\n\\[\n\\mathbf{x}\n\\mapsto\n\\mathbf{x} + 2\n\\]\n\\[\n\\begin{equation}\n  \\mathbf{x}\n  \\mapsto\n  \\texttt{AND}\n  (\n    \\texttt{ISNUMBER}(\\mathbf{x})\n  )\n  =\n  \\begin{cases}\n    \\texttt{TRUE} & f : \\mathbf{x} \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n    \\texttt{FALSE} & \\textrm{return}\\ \\texttt{#VALUE!} \\\\\n    \\texttt{FALSE} & \\mathbf{x} \\mapsto g(\\mathbf{x}) = \\texttt{FILTER}(\\dots) \\mapsto \\\\\n    & f: g(\\mathbf{x}) \\in \\mathbb{R} \\rightarrow \\mathbb{R}\\\\\n  \\end{cases}\n\\end{equation}\n\\]\n\n\\(\\mathbf{x}\\) akan dievaluasi terlebih dahulu dan di filter dengan memilih elemen yang berupa angka saja.\n\\(\\mathbf{x} \\mapsto \\mathbf{y}\\) dengan \\(y \\in \\mathbb{R}\\) dan \\(x \\in \\mathbb{?}\\)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula",
    "href": "greenhorn/feidlambda-2/presentation.html#formula",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng : \\mathbf{x} \\in \\mathbb{?} \\to \\mathbb{R}\n\\]\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-1",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-2",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-3",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  logical_isnumber, ISNUMBER(x),\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-4",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-4",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  logical_isnumber, ISNUMBER(x),\n  y, FILTER(x, logical_isnumber),\n  ...\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-5",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-5",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  y, FILTER(x, ISNUMBER(x)),\n  y + 2\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-6",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-6",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula",
    "text": "Formula\n\\[\ng(\\mathbf{x}) = f(\n  \\underbrace{\n    \\texttt{FILTER}(\\mathbf{x}, \\texttt{ISNUMBER}(\\mathbf{x}))\n  }_{\\mathbf{y\\ \\in\\ \\mathbb{R}}}\n)\n=\n\\underbrace{\n  f(\\mathbf{y})\n}_{\\in\\ \\mathbb{R}}\n=\n\\mathbf{y} + 2\n\\]\n=LET(\n  x, H8:H15,\n  y, FILTER(x, ISNUMBER(x)),\n  y + 2\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#lambda-dan-udl",
    "href": "greenhorn/feidlambda-2/presentation.html#lambda-dan-udl",
    "title": "Greenhorn:feidlambda II",
    "section": "LAMBDA dan UDL",
    "text": "LAMBDA dan UDL\n\nLAMBDA(...): Gunakan fungsi LAMBDA untuk membuat fungsi kustom yang dapat digunakan kembali dan memanggilnya dengan nama yang mudah dikenali. Fungsi baru tersedia di seluruh buku kerja dan disebut seperti fungsi asli Excel. 1\n\n=LAMBDA(parameter1, [parameter2, parameter3, ...], calculation)\n\nUser Defined Lambda (UDL) sama halnya dengan User Defined Function (UDF) hanya spesifik pada penggunaan LAMBDA. UDF sendiri adalah fungsi yang dibuat oleh pengguna.\n\nFungsi LAMBDA, Microsoft Support."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#lambda-dan-let",
    "href": "greenhorn/feidlambda-2/presentation.html#lambda-dan-let",
    "title": "Greenhorn:feidlambda II",
    "section": "LAMBDA dan LET",
    "text": "LAMBDA dan LET\n\nLAMBDA dan LET biasanya digunakan bersamaan untuk memudahkan pembuatan UDL ataupun membaca/troubleshooting.\nLAMBDA berfungsi menerima input dan membungkusnya sebagai fungsi baru di Excel sebagai UDL.\nLET digunakan untuk melakukan perhitungan/kalkulasi setelah menerima input dari LAMBDA.\nJika UDL cukup sederhana, LET tidak perlu digunakan."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(parameter1, [parameter2, parameter3, ...], calculation)\n\nUntuk memudahkan membaca kode, buat baris baru diantara (...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-1",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(\n  parameter1, \n  [parameter2, parameter3, ...],\n  calculation\n)\n\nUbah calculation dengan LET(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-2",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(\n  parameter1, \n  [parameter2, parameter3, ...],\n  LET(\n    name1, value1,\n    [name2, value2, name3, value3, ...],\n    calculation\n  )\n)\n\nArgumen parameter yang berasal dari LAMBDA, dapat langsung digunakan di LET tanpa melakukan pendefinisian ulang."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-3",
    "href": "greenhorn/feidlambda-2/presentation.html#sintaks-lambda-dan-let-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Sintaks LAMBDA dan LET",
    "text": "Sintaks LAMBDA dan LET\n=LAMBDA(\n  parameter1, \n  parameter2,\n  parameter3,\n  LET(\n    name1, parameter1 + parameter2,\n    name2, parameter3 - name1\n    name1 / parameter2\n  )\n)\n\n\nparameter2 bisa langsung digunakan pada LET tanpa pendefinisian ulang."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#deskripsi-kasus",
    "href": "greenhorn/feidlambda-2/presentation.html#deskripsi-kasus",
    "title": "Greenhorn:feidlambda II",
    "section": "Deskripsi Kasus",
    "text": "Deskripsi Kasus\n\nMengurangi setiap elemen dari numeric vector (\\(\\mathbf{x}\\)) dengan setengah dari rata-ratanya (\\(\\frac{\\texttt{mean}(\\mathbf{x})}{2}\\)).\n\n\\[\nf : \\mathbf{x} \\in \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x}) =\n\\mathbf{x} - \\frac{\\overline{\\mathbf{x}}}{2}\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#fungsi-lambda",
    "href": "greenhorn/feidlambda-2/presentation.html#fungsi-lambda",
    "title": "Greenhorn:feidlambda II",
    "section": "Fungsi LAMBDA",
    "text": "Fungsi LAMBDA\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  parameter1, \n  [parameter2, parameter3, ...],\n  calculation\n)\n\nmenentukan input variabel untuk fungsi LAMBDA.\n\\(f(\\mathbf{x})\\) menunjukkan input fungsi \\(f\\) hanya vektor \\(\\mathbf{x}\\)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#input-lambda",
    "href": "greenhorn/feidlambda-2/presentation.html#input-lambda",
    "title": "Greenhorn:feidlambda II",
    "section": "input LAMBDA",
    "text": "input LAMBDA\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  calculation\n)\n\nKarena fungsi \\(f\\) memiliki perhitungan AVERAGE(...), yang sebaiknya disimpan di variabel sementara, maka diperlukan kalkulasi menggunakan LET(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menggunakan-let",
    "href": "greenhorn/feidlambda-2/presentation.html#menggunakan-let",
    "title": "Greenhorn:feidlambda II",
    "section": "Menggunakan LET",
    "text": "Menggunakan LET\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    name1, value1,\n    [name2, value2, name3, value3, ...],\n    calculation\n  )\n)\n\nKarena pada persamaan asli \\(f\\) menggunakan simbol \\(\\mathbf{x}\\), bisa dilakukan assignment / pendefinisian berupa x <- vector."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#argumen-redundant-berulang",
    "href": "greenhorn/feidlambda-2/presentation.html#argumen-redundant-berulang",
    "title": "Greenhorn:feidlambda II",
    "section": "Argumen redundant / berulang",
    "text": "Argumen redundant / berulang\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    x, vector,\n    ..., ...,\n    calculation\n  )\n)\n\nx <- vector merupakan argumen yang tidak perlu (redundant / berulang) dikarenakan tidak ada modifikasi pada input vector.\nSelain itu, pada proses pengembangan LAMBDA lebih baik menggunakan nama variabel yang mudah diingat atau dipahami."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#perhitungan-dalam-fungsi-let",
    "href": "greenhorn/feidlambda-2/presentation.html#perhitungan-dalam-fungsi-let",
    "title": "Greenhorn:feidlambda II",
    "section": "Perhitungan dalam fungsi LET",
    "text": "Perhitungan dalam fungsi LET\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    ..., ...,\n    calculation\n  )\n)\n\nNilai rata-rata bisa disimpan sebagai variabel avg.\n\navg <- AVERAGE(vector)\n\nVariabel halfavg menyatakan nilai setengah dari rata-rata vektor.\n\nhalfavg <- avg / 2\n\nHasil akhir dapat disimpan sebagai variabel result.\n\nresult <- vector - halfavg"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#mengisi-hasil-dari-lambda",
    "href": "greenhorn/feidlambda-2/presentation.html#mengisi-hasil-dari-lambda",
    "title": "Greenhorn:feidlambda II",
    "section": "Mengisi hasil dari LAMBDA",
    "text": "Mengisi hasil dari LAMBDA\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    result, vector - halfavg,\n    ...\n  )\n)\n\nFungsi LAMBDA ini masih belum mengeluarkan hasil atau return dari fungsinya.\nPada argumen terakhir LET disampaikan kembali hasil yang diperoleh dari seluruh perhitungan. Yaitu result."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menghindari-pendefinisian-berulang",
    "href": "greenhorn/feidlambda-2/presentation.html#menghindari-pendefinisian-berulang",
    "title": "Greenhorn:feidlambda II",
    "section": "Menghindari pendefinisian berulang",
    "text": "Menghindari pendefinisian berulang\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    result, vector - halfavg,\n    result\n  )\n)\n\nPada baris ke-6 dan ke-7 bisa dibuat lebih sederhana menjadi satu baris dan langsung memberikan return atau hasil dari fungsi LAMBDA."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-akhir",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-akhir",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula akhir",
    "text": "Formula akhir\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)\n\nFungsi LAMBDA sudah lengkap dan bisa langsung digunakan."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#rekap",
    "href": "greenhorn/feidlambda-2/presentation.html#rekap",
    "title": "Greenhorn:feidlambda II",
    "section": "Rekap",
    "text": "Rekap\n\\[\nf : \\mathbf{x} \\in \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-1",
    "href": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Menggunakan formula di Excel (1)",
    "text": "Menggunakan formula di Excel (1)\n\\[\nf : \\mathbf{x} \\in \\mathbb{R} \\to \\mathbb{R}\n\\]\n\\[\nf(\\mathbf{x})\n=\n\\mathbf{x} - \\frac{\\texttt{AVERAGE}(\\mathbf{x})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)\n\nSalin formula diatas dan simpan sebagai fungsi bernama HALFAVG(...)."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-2",
    "href": "greenhorn/feidlambda-2/presentation.html#menggunakan-formula-di-excel-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Menggunakan formula di Excel (2)",
    "text": "Menggunakan formula di Excel (2)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-input-1",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-input-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi input (1)",
    "text": "Validasi input (1)\n\\[\ng : \\mathbf{y} \\in \\mathbb{?} \\to \\mathbb{R}\n\\]\n\\[\n\\mathbb{y}_{\\textit{filtered}} \\leftarrow \\text{VALIDASI}(\\mathbf{y})\n\\]\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    ...,...,\n    avg, AVERAGE(vector),\n    halfavg, avg / 2,\n    vector - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#validasi-input-2",
    "href": "greenhorn/feidlambda-2/presentation.html#validasi-input-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Validasi input (2)",
    "text": "Validasi input (2)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    avg, AVERAGE(vector_filtered),\n    halfavg, avg / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#refactoring-1",
    "href": "greenhorn/feidlambda-2/presentation.html#refactoring-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Refactoring (1)",
    "text": "Refactoring (1)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    avg, AVERAGE(vector_filtered),\n    halfavg, avg / 2,\n    vector_filtered - halfavg\n  )\n)\n\nRefactoring merupakan perubahan dari kode program yang sudah ada tanpa mengubah hasil dari program tersebut.\nvariabel avg bisa langsung diterapkan pada variabel halfavg."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#refactoring-2",
    "href": "greenhorn/feidlambda-2/presentation.html#refactoring-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Refactoring (2)",
    "text": "Refactoring (2)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-1",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (1)",
    "text": "Optional argument (1)\n\\[\ng(\\mathbf{y})\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{2}\n\\]\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n\\[\n\\begin{equation}\n  n =\n  \\begin{cases}\n    \\dots & \\mathbf{y}, n = 2 \\mapsto g(\\mathbf{y}, 2) = f(\\mathbf{y}_{\\textit{filtered}})\\\\\n    n & \\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n  \\end{cases}\n\\end{equation}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-2",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-2",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (2)",
    "text": "Optional argument (2)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  LET(\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-3",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-3",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (3)",
    "text": "Optional argument (3)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  ...,\n  LET(\n    ...,...,\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / 2,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-4",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-4",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (4)",
    "text": "Optional argument (4)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  [n],\n  LET(\n    ...,...,\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / n,\n    vector_filtered - halfavg\n  )\n)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#optional-argument-5",
    "href": "greenhorn/feidlambda-2/presentation.html#optional-argument-5",
    "title": "Greenhorn:feidlambda II",
    "section": "Optional argument (5)",
    "text": "Optional argument (5)\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  [n],\n  LET(\n    n, IF(ISOMITTED(n), 2, n),\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / n,\n    vector_filtered - halfavg\n  )\n)\n\\[\n\\begin{equation}\n  n \\mapsto \\texttt{ISOMITTED}(n) =\n  \\begin{cases}\n    \\texttt{TRUE} & n \\leftarrow 2 \\\\\n    \\texttt{FALSE} & n \\leftarrow n\n  \\end{cases}\n\\end{equation}\n\\]"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#formula-akhir-1",
    "href": "greenhorn/feidlambda-2/presentation.html#formula-akhir-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Formula Akhir",
    "text": "Formula Akhir\n\\[\n\\mathbf{y}, n \\mapsto g(\\mathbf{y}, n)\n=\n\\mathbf{y}_{\\textit{filtered}} - \\frac{\\texttt{AVERAGE}(\\mathbf{y}_{\\textit{filtered}})}{n}\n\\]\n=LAMBDA(\n  vector,\n  [n],\n  LET(\n    n, IF(ISOMITTED(n), 2, n),\n    vector_filtered, FILTER(vector, ISNUMBER(vector)),\n    halfavg, AVERAGE(vector_filtered) / n,\n    vector_filtered - halfavg\n  )\n)\n\nFormula tersebut disimpan sebagai HALFAVGN di Formulas Name Manager.\nSintaksnya =HALFAVGN(vector, [n]).\n=HALFAVGN(D5:D10) (maka \\(n=2\\)).\n=HALFAVGN(D5#, 4) (maka \\(n=4\\))."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#pengenalan-advanced-formula-environment-afe",
    "href": "greenhorn/feidlambda-2/presentation.html#pengenalan-advanced-formula-environment-afe",
    "title": "Greenhorn:feidlambda II",
    "section": "Pengenalan Advanced Formula Environment (AFE)",
    "text": "Pengenalan Advanced Formula Environment (AFE)\n\nExcel add-ins yang memudahkan mengatur kumpulan formula pada lembar kerja.\nAlternatif Formulas Name Manager.\nMemiliki fitur syntax highlighting dan shortcut umum untuk coding.\nDapat import UDL hasil dari orang lain menggunakan GitHub Gist."
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1",
    "href": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Demonstrasi menggunakan AFE (1)",
    "text": "Demonstrasi menggunakan AFE (1)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1-1",
    "href": "greenhorn/feidlambda-2/presentation.html#demonstrasi-menggunakan-afe-1-1",
    "title": "Greenhorn:feidlambda II",
    "section": "Demonstrasi menggunakan AFE (1)",
    "text": "Demonstrasi menggunakan AFE (1)"
  },
  {
    "objectID": "greenhorn/feidlambda-2/presentation.html#daftar-fungsi-yang-dibahas-di-feidlambda-iii",
    "href": "greenhorn/feidlambda-2/presentation.html#daftar-fungsi-yang-dibahas-di-feidlambda-iii",
    "title": "Greenhorn:feidlambda II",
    "section": "Daftar fungsi yang dibahas di feidlambda III",
    "text": "Daftar fungsi yang dibahas di feidlambda III\n\n\nFungsi vektorisasi SCAN, MAP, REDUCE.\nTransformasi kolom dengan TOCOL, TOROW, WRAPCOLS, WRAPROWS.\nMenggabungkan array dengan VSTACK dan HSTACK\nManipulasi array dengan DROP, EXPAND.\nMemilih kolom/baris dengan CHOOSECOLS dan CHOOSEROWS, TAKE\nFungsi teks TEXTAFTER, TEXTBEFORE, TEXTSPLIT, VALUETOTEXT, ARRAYTOTEXT.\nIterasi dengan BYCOL dan BYROW,"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html",
    "href": "release/feidlambda-0-1-0.html",
    "title": "feidlambda v0.1",
    "section": "",
    "text": "Official GIST feid_utils (v0.2.0)\n\n\n\nhttps://gist.github.com/taruma/60610672a9bd94724cba46f68b5614fa Pre-release Page (GitHub)\nBerikut daftar fungsi yang tersedia di koleksi feidlambda versi 0.1.0:"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#repeatcols",
    "href": "release/feidlambda-0-1-0.html#repeatcols",
    "title": "feidlambda v0.1",
    "section": "1 REPEATCOLS",
    "text": "1 REPEATCOLS\n\n\n\n\n\n\n\nfeid_utils.REPEATCOLS\n\nMengulangi vector sebanyak num_repeat dalam bentuk kolom.\n\nreturn\n\nCOLUMN VECTOR\n\n\n\n\n\n\n\n\n\n\n\n\nJika num_repeat tidak diisi, maka secara default bernilai 2.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.REPEATCOLS(vector, [num_repeat])\n\n\n\n\n\nfeid_utils.REPEATCOLS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#sortcols",
    "href": "release/feidlambda-0-1-0.html#sortcols",
    "title": "feidlambda v0.1",
    "section": "2 SORTCOLS",
    "text": "2 SORTCOLS\n\n\n\n\n\n\n\nfeid_utils.SORTCOLS\n\nMenyusun ulang urutan kolom table, berdasarkan table_header yang telah diurutkan.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\n\nJika input table sebagai array, maka pastikan memisahkan antara table_header dengan isinya.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.SORTCOLS(table, table_header)\n\n\n\n\n\nfeid_utils.SORTCOLS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#repeatrows",
    "href": "release/feidlambda-0-1-0.html#repeatrows",
    "title": "feidlambda v0.1",
    "section": "3 REPEATROWS",
    "text": "3 REPEATROWS\n\n\n\n\n\n\n\nfeid_utils.REPEATROWS\n\nMengulangi vector sebanyak num_repeat dalam bentuk baris.\n\nreturn\n\nROW VECTOR\n\n\n\n\n\n\n\n\n\n\n\n\nJika num_repeat tidak diisi, maka secara default bernilai 2.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.REPEATROWS(vector, [num_repeat])\n\n\n\n\n\nfeid_utils.REPEATROWS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#reshapecols",
    "href": "release/feidlambda-0-1-0.html#reshapecols",
    "title": "feidlambda v0.1",
    "section": "4 RESHAPECOLS",
    "text": "4 RESHAPECOLS\n\n\n\n\n\n\n\nfeid_utils.RESHAPECOLS\n\nMengubah dimensi array dari dimensi \\(\\text{rows} \\times \\text{cols}\\), menjadi \\(\\text{rows} + \\text{} \\times \\textrm{nsplit}\\) tanpa mengubah susunan baris array.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\n\nJika nsplit tidak diisi, maka default bernilai 2.\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.RESHAPECOLS(array, [nsplit])\n\n\n\n\n\nfeid_utils.RESHAPECOLS"
  },
  {
    "objectID": "release/feidlambda-0-1-0.html#findindex2d",
    "href": "release/feidlambda-0-1-0.html#findindex2d",
    "title": "feidlambda v0.1",
    "section": "5 FINDINDEX2D",
    "text": "5 FINDINDEX2D\n\n\n\n\n\n\n\nfeid_utils.FINDINDEX2D\n\nMencari index suatu elemen dari array dengan keluaran berupa urutan elemennya, posisi baris dan kolom.\n\nreturn\n\nARRAY / ROW VECTOR with {number element; index row; index column}\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.FINDINDEX2D(lookup_value, array)\n\n\n\n\n\nfeid_utils.FINDINDEX2D"
  },
  {
    "objectID": "release/feidmath-0-1.html",
    "href": "release/feidmath-0-1.html",
    "title": "feidmath v0.1",
    "section": "",
    "text": "Official GIST feidmath (v0.1.x)\n\n\n\nhttps://gist.github.com/taruma/b4df638ecb7af48ab63691951481d6b2\n\n\n\nINSTALASI WORKSHEET FEIDMATH v0.1.0\n\nfeidlambda-math atau feidmath merupakan kumpulan fungsi LAMBDA yang fokus menyelesaikan beberapa permasalahan matematis seperti perkalian matriks, rotasi, interpolasi, dlsbnya. Pengembangan feidmath diusahakan tidak memerlukan fungsi dari feidlambda sehingga fungsi yang tersedia feidmath terisolasi dan dapat digunakan secara langsung sesuai kebutuhan. feidmath dibuat untuk fokus pengembangan yang bersifat penerapan dengan fungsi matematika. feidmath merupakan langkah awal untuk pengembangan koleksi LAMBDA lainnya yang bersifat terapan.\nfeidmath v0.1 di rilis bersamaan dengan feidlambda v0.4.\n\n\n\n\nFungsi feidmath v0.1.x\nMengikuti panduan FIAKO LAMBDA Style Guide dan feidlambda v0.4, feidmath dipisahkan dengan kategori yang sesuai dengan fungsi yang tersedia. Berikut kategori yang tersedia di feidmath v0.1.x:\n\nNEW INTERPOLATION_*: Kategori ini berisi fungsi untuk estimasi nilai berdasarkan data yang sudah diketahui.\nNEW LINALG_*: Ini mencakup fungsi-fungsi yang berkaitan dengan aljabar linear, seperti operasi pada vektor dan matriks\nNEW GEOMETRY_*: Kategori ini melibatkan fungsi geometri, termasuk mengidentifikasi titik berada di dalam/luar poligon.\n\nDownload excel demonstrasi RELEASE_feidmath_v0_1_0.xlsx, untuk memudahkan mengeksplorasi fungsi baru di feidmath v0.1.x.\n\n\n\n\n\nKategori INTERPOLATION_*\nNEW v0.1 Kategori INTERPOLATION_* merupakan kumpulan fungsi untuk mengestimasi nilai berdasarkan data yang sudah diketahui. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 2.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE ---> _INTERPOLATION_LINEAR\n  _INTERPOLATION_LINEAR ---> INTERPOLATION_LINEAR\n\n\n\n\n\nGambar 2.1: Grafik dependencies kategori INTERPOLATION_*\n\n\n\n\nFungsi utama kategori INTERPOLATION_* yaitu INTERPOLATION_LINEAR().\n\n\nSource Code INTERPOLATION_*\n\n// NONE ---> _INTERPOLATION_LINEAR\n_INTERPOLATION_LINEAR = LAMBDA(x, known_ys, known_xs,\n    LET(\n        known_xs, TOCOL(known_xs),\n        known_ys, TOCOL(known_ys),\n        nrow, ROWS(known_ys),\n        known_table, HSTACK(known_xs, known_ys),\n        sorted_table, SORT(known_table, 1),\n        sorted_xs, CHOOSECOLS(sorted_table, 1),\n        sorted_ys, CHOOSECOLS(sorted_table, 2),\n        nearest_x, IFS(\n            x > MAX(sorted_xs),\n            XMATCH(x, sorted_xs, -1),\n            x < MIN(sorted_xs),\n            XMATCH(x, sorted_xs, 1),\n            TRUE,\n            XMATCH(x, sorted_xs, -1)\n        ),\n        index_ys, IF(\n            nearest_x < nrow,\n            VSTACK(nearest_x, nearest_x + 1),\n            VSTACK(nearest_x - 1, nearest_x)\n        ),\n        select_ys, CHOOSEROWS(sorted_ys, index_ys),\n        select_xs, CHOOSEROWS(sorted_xs, index_ys),\n        FORECAST.LINEAR(x, select_ys, select_xs)\n    )\n);\n\n// _INTERPOLATION_LINEAR ---> INTERPOLATION_LINEAR\nINTERPOLATION_LINEAR = LAMBDA(x_vector, known_ys, known_xs,\n    LET(\n        x_vector, TOCOL(x_vector),\n        y_vector, BYROW(\n            x_vector,\n            LAMBDA(x, _INTERPOLATION_LINEAR(x, known_ys, known_xs))\n        ),\n        y_vector\n    )\n);\n\n\nINTERPOLATION_LINEAR()\nFungsi INTERPOLATION_LINEAR(x_vector, known_y, known_x) digunakan untuk mencari nilai interpolasi linear. Fungsi ini dikembangkan menggunakan fungsi bawaan FORECAST.LINEAR(...). Fungsi ini bisa menerima input scalar maupun vector.\n\n\n\nSyntax\n\nINTERPOLATION_LINEAR(x_vector, known_y, known_x)\n\nOutput\n\nscalar / vector\n\n\n\n\n\nx_vector := [scalar | vector]\n\nPoin data yang ingin Anda prediksikan nilainya.\n\nknown_ys := [vector]\n\nvector atau rentang data terikat.\n\nknown_xs := [vector]\n\nvector atau rentang data terikat.\n\n\n\n\n\n\n\n\n\n\nscalar sebagai input\n\n\n\n\n\n\n\nvector sebagai input\n\n\n\n\nGambar 2.2: Demonstrasi INTERPOLATION_LINEAR()\n\n\n\n\n\n\n\n\nKategori LINALG_*\nNEW v0.1 Kategori LINALG_* merupakan kumpulan fungsi yang berkaitan dengan aljabar linear seperti operasi pada vektor atau matriks. LINALG merupakan singkatan dari LINEAR ALGEBRA. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 3.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE ---> LINALG_ROTATION_MATRIX\n  LINALG_ROTATION_MATRIX ---> LINALG_ROTATE_POINT\n  LINALG_ROTATE_POINT ---> _RECURSIVE_ROTATE_POINTS\n  _RECURSIVE_ROTATE_POINTS ---> _RECURSIVE_ROTATE_POINTS\n  _RECURSIVE_ROTATE_POINTS ---> LINALG_ROTATE_POINT_ARRAY\n\n\n\n\n\nGambar 3.1: Grafik dependencies kategori LINALG_*\n\n\n\n\nFungsi utama kategori LINALG_* yaitu LINALG_ROTATION_MATRIX(), LINALG_ROTATE_POINT(), dan LINALG_ROTATE_POINT_ARRAY().\n\n\nSource Code LINALG_*\n\n// NONE ---> LINALG_ROTATION_MATRIX\nLINALG_ROTATION_MATRIX = LAMBDA(theta_x, theta_y, theta_z, [num_digits],\n    LET(\n        round_number, IF(ISOMITTED(num_digits), 0, num_digits),\n        angle_x, RADIANS(theta_x),\n        angle_y, RADIANS(theta_y),\n        angle_z, RADIANS(theta_z),\n        cos_x, COS(angle_x),\n        sin_x, SIN(angle_x),\n        rotation_x, VSTACK(\n            HSTACK(1, 0, 0),\n            HSTACK(0, cos_x, -sin_x),\n            HSTACK(0, sin_x, cos_x)\n        ),\n        cos_y, COS(angle_y),\n        sin_y, SIN(angle_y),\n        rotation_y, VSTACK(\n            HSTACK(cos_y, 0, sin_y),\n            HSTACK(0, 1, 0),\n            HSTACK(-sin_y, 0, cos_y)\n        ),\n        cos_z, COS(angle_z),\n        sin_z, SIN(angle_z),\n        rotation_z, VSTACK(\n            HSTACK(cos_z, -sin_z, 0),\n            HSTACK(sin_z, cos_z, 0),\n            HSTACK(0, 0, 1)\n        ),\n        rotation_matrix, MMULT(rotation_z, MMULT(rotation_y, rotation_x)),\n        IF(\n            round_number,\n            ROUND(rotation_matrix, round_number),\n            rotation_matrix\n        )\n    )\n);\n\n// LINALG_ROTATION_MATRIX ---> LINALG_ROTATE_POINT\nLINALG_ROTATE_POINT = LAMBDA(\n    point_vector,\n    theta_x,\n    theta_y,\n    theta_z,\n    [active_rotation],\n    [num_digits],\n    LET(\n        active_rotation, IF(\n            ISOMITTED(active_rotation),\n            TRUE,\n            active_rotation\n        ),\n        rotation_matrix, LINALG_ROTATION_MATRIX(\n            theta_x,\n            theta_y,\n            theta_z,\n            num_digits\n        ),\n        point_vector, TOCOL(point_vector),\n        final_rotation, IF(\n            active_rotation,\n            rotation_matrix,\n            TRANSPOSE(rotation_matrix)\n        ),\n        point_rotation, MMULT(final_rotation, point_vector),\n        TOROW(point_rotation)\n    )\n);\n\n// LINALG_ROTATE_POINT ---> _RECURSIVE_ROTATE_POINTS\n// _RECURSIVE_ROTATE_POINTS ---> _RECURSIVE_ROTATE_POINTS\n_RECURSIVE_ROTATE_POINTS = LAMBDA(\n    ntry,\n    data_points,\n    theta_x,\n    theta_y,\n    theta_z,\n    [active_rotation],\n    [num_digits],\n    LET(\n        selected_row, CHOOSEROWS(data_points, ntry),\n        IF(\n            ntry = 1,\n            LINALG_ROTATE_POINT(\n                selected_row,\n                theta_x,\n                theta_y,\n                theta_z,\n                active_rotation,\n                num_digits\n            ),\n            LET(\n                next_try, ntry - 1,\n                result, LINALG_ROTATE_POINT(\n                    selected_row,\n                    theta_x,\n                    theta_y,\n                    theta_z,\n                    active_rotation,\n                    num_digits\n                ),\n                VSTACK(\n                    _RECURSIVE_ROTATE_POINTS(\n                        next_try,\n                        data_points,\n                        theta_x,\n                        theta_y,\n                        theta_z,\n                        active_rotation,\n                        num_digits\n                    ),\n                    result\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_ROTATE_POINTS ---> LINALG_ROTATE_POINT_ARRAY\nLINALG_ROTATE_POINT_ARRAY = LAMBDA(\n    data_points,\n    theta_x,\n    theta_y,\n    theta_z,\n    [active_rotation],\n    [num_digits],\n    _RECURSIVE_ROTATE_POINTS(\n        ROWS(data_points),\n        data_points,\n        theta_x,\n        theta_y,\n        theta_z,\n        active_rotation,\n        num_digits\n    )\n);\n\n\nLINALG_ROTATION_MATRIX()\nFungsi LINALG_ROTATION_MATRIX(theta_x, theta_y, theta_z, [num_digits]) digunakan untuk menghasilkan matriks rotasi berdasarkan tiga sudut rotasi (\\(\\theta_x\\), \\(\\theta_y\\), dan \\(\\theta_z\\)) yang ditentukan dalam derajat.\n\n\n\nSyntax\n\nLINALG_ROTATION_MATRIX(theta_x, theta_y, theta_z, [num_digits])\n\nOutput\n\n\\(3 \\times 3\\) array\n\n\n\n\n\ntheta_x | theta_y | theta_z := [number]\n\nRotasi terhadap sumbu-nya dalam satuan derajat.\n\n[num_digits] := 0 :: [number]\n\nNilai default yaitu 0 (tidak dibulatkan). Jumlah digit presisi yang diinginkan.\n\n\n\n\n\n\n\n\n\n\nmenghitung matriks rotasi\n\n\n\n\n\n\n\nimplementasi rotasi pada titik\n\n\n\n\nGambar 3.2: Demonstrasi LINALG_ROTATION_MATRIX()\n\n\n\n\nLINALG_ROTATE_POINT()\nFungsi LINALG_ROTATE_POINT(point_vector, theta_x, theta_y, theta_z, [active_rotation], [num_digits]) digunakan untuk melakukan rotasi pada titik dalam ruang tiga dimensi. Fungsi ini menerima input dalam bentuk vektor dengan tiga nilai yaitu \\(x\\), \\(y\\), dan \\(z\\).\n\n\n\nSyntax\n\nLINALG_ROTATE_POINT(point_vector, theta_x, theta_y, theta_z, [active_rotation], [num_digits])\n\nOutput\n\nvector\n\n\n\n\n\npoint_vector := [number vector]\n\nKoordinat titik dalam bentuk vektor (\\(x\\), \\(y\\), \\(z\\)).\n\ntheta_x | theta_y | theta_z := [number]\n\nRotasi terhadap sumbu-nya dalam satuan derajat.\n\n[active_rotation] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Rotasi aktif akan mengubah posisi objek, sedangkan rotasi pasif akan mengubah sistem koordinat.\n\n[num_digits] := 0 :: [number]\n\nNilai default yaitu 0 (tidak dibulatkan). Jumlah digit presisi yang diinginkan.\n\n\n\n\n\n\n\nGambar 3.3: Demonstrasi LINALG_ROTATE_POINT()\n\n\n\n\n\nLINALG_ROTATE_POINT_ARRAY()\nFungsi LINALG_ROTATE_POINT_ARRAY(data_points, theta_x, theta_y, theta_z, [active_rotation], [num_digits]) digunakan untuk melakukan rotasi pada sekumpulan titik dalam ruang tiga dimensi. Fungsi LINALG_ROTATE_POINT_ARRAY() sama dengan LINALG_ROTATE_POINT() tetapi dirancang untuk merotasikan sekumpulan titik sekaligus. Argumen data_points harus berupa array yang setiap barisnya merepresentasikan titik di ruang 3D. Fungsi ini menerima array dengan tiga kolom yaitu \\(x\\), \\(y\\), dan \\(z\\).\n\n\n\nSyntax\n\nLINALG_ROTATE_POINT_ARRAY(data_points, theta_x, theta_y, theta_z, [active_rotation], [num_digits])\n\nOutput\n\n\\(m \\times 3\\) array\n\n\n\n\n\ndata_points := [number array]\n\nSekumpulan koordinat titik dalam bentuk array dengan kolom \\(x\\), \\(y\\), \\(z\\).\n\ntheta_x | theta_y | theta_z := [number]\n\nRotasi terhadap sumbu-nya dalam satuan derajat.\n\n[active_rotation] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Rotasi aktif akan mengubah posisi objek, sedangkan rotasi pasif akan mengubah sistem koordinat.\n\n[num_digits] := 0 :: [number]\n\nNilai default yaitu 0 (tidak dibulatkan). Jumlah digit presisi yang diinginkan.\n\n\n\n\n\n\n\nGambar 3.4: Demonstrasi LINALG_ROTATE_POINT()\n\n\n\n\n\nVisualisasi Aktif vs. Pasif\nBerikut visualisasi perbedaan antara merotasikan objek (aktif) dan koordinatnya (pasif). Rotasi terhadap sumbu \\(z\\) dengan grafik hubungan \\(x\\) dan \\(y\\).\n\n\n\n\n\n\n\nrotasi aktif (objek)\n\n\n\n\n\n\n\nrotasi pasif (koordinat)\n\n\n\n\nGambar 3.5: Demonstrasi Rotasi Aktif dan Pasif\n\n\n\n\n\n\n\n\nKategori GEOMETRY_*\nNEW v0.1 Kategori GEOMETRY_* berisikan fungsi geometri seperti mengidentifikasi titik berada di dalam/luar poligon. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 4.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE ---> GEOMETRY_IS_POINT_IN_POLYGON\n  GEOMETRY_IS_POINT_IN_POLYGON ---> GEOMETRY_ARE_POINTS_IN_POLYGON\n\n\n\n\n\nGambar 4.1: Grafik dependencies kategori GEOMETRY_*\n\n\n\n\nFungsi utama kategori GEOMETRY_* yaitu GEOMETRY_POINT_IN_POLYGON() dan GEOMETRY_ARE_POINTS_IN_POLYGON().\n\n\nSource Code GEOMETRY_*\n\n// NONE ---> GEOMETRY_IS_POINT_IN_POLYGON\nGEOMETRY_IS_POINT_IN_POLYGON = LAMBDA(point_vector, data_polygon,\n    LET(\n        point_vector, TOCOL(point_vector),\n        xp, INDEX(point_vector, 1),\n        yp, INDEX(point_vector, 2),\n        data_1, DROP(data_polygon, -1),\n        data_2, DROP(data_polygon, 1),\n        data_joined, HSTACK(data_1, data_2),\n        _x1, CHOOSECOLS(data_joined, 1),\n        _y1, CHOOSECOLS(data_joined, 2),\n        _x2, CHOOSECOLS(data_joined, 3),\n        _y2, CHOOSECOLS(data_joined, 4),\n        first_condition, (yp < _y1) <> (yp < _y2),\n        second_condition, xp <\n            (_x1 + (((yp - _y1) / (_y2 - _y1)) * (_x2 - _x1))),\n        final_condition, IFERROR(\n            (first_condition * second_condition) = 1,\n            FALSE\n        ),\n        is_inside, MOD(SUM(INT(final_condition)), 2) = 1,\n        is_inside\n    )\n);\n\n// GEOMETRY_IS_POINT_IN_POLYGON ---> GEOMETRY_ARE_POINTS_IN_POLYGON\nGEOMETRY_ARE_POINTS_IN_POLYGON = LAMBDA(data_points, polygon_points,\n    BYROW(\n        data_points,\n        LAMBDA(row, GEOMETRY_IS_POINT_IN_POLYGON(row, polygon_points))\n    )\n);\n\n\nGEOMETRY_IS_POINT_IN_POLYGON()\nFungsi GEOMETRY_IS_POINT_IN_POLYGON(point_vector, polygon_points) digunakan untuk menentukan apakah sebuah titik berada di dalam atau di luar sebuah poligon yang tertutup. Titik yang akan dicek dinyatakan oleh point_vector, sedangkan polygon_points adalah array yang setiap barisnya merepresentasikan titik dari poligon. Fungsi ini mengembalikan nilai boolean/logical, yaitu TRUE jika titik berada di dalam poligon, dan FALSE jika tidak.\n\n\n\nSyntax\n\nGEOMETRY_IS_POINT_IN_POLYGON(point_vector, polygon_points)\n\nOutput\n\nlogical\n\n\n\n\n\npoint_vector := [number vector]\n\nKoordinat titik yang ingin dicek dalam bentuk vektor (\\(x\\), \\(y\\)).\n\npolygon_points := [number array]\n\nSekumpulan koordinat titik yang membentuk poligon dalam bentuk array dengan kolom \\(x\\), \\(y\\).\n\n\n\n\n\n\n\nGambar 4.2: Demonstrasi GEOMETRY_IS_POINT_IN_POLYGON()\n\n\n\n\n\nGEOMETRY_ARE_POINTS_IN_POLYGON()\nFungsi GEOMETRY_ARE_POINTS_IN_POLYGON(data_points, polygon_points) sama dengan GEOMETRY_IS_POINT_IN_POLYGON() tetapi dirancang untuk mengecek sejumlah titik sekaligus. Argumen data_points harus berupa array yang setiap barisnya merepresentasikan titik yang akan dicek. Seperti halnya fungsi GEOMETRY_IS_POINT_IN_POLYGON(), fungsi ini mengembalikan array nilai boolean, yaitu TRUE untuk titik-titik yang berada di dalam poligon dan FALSE untuk titik-titik yang berada di luar poligon.\n\n\n\nSyntax\n\nGEOMETRY_ARE_POINTS_IN_POLYGON(data_points, polygon_points)\n\nOutput\n\nlogical vector\n\n\n\n\n\ndata_points := [number array]\n\nSekumpulan koordinat titik yang ingin dicek dalam bentuk array \\(m \\times 2\\) dengan kolom (\\(x\\), \\(y\\)).\n\npolygon_points := [number array]\n\nSekumpulan koordinat titik yang membentuk poligon dalam bentuk array dengan kolom \\(x\\), \\(y\\).\n\n\n\n\n\n\n\nGambar 4.3: Demonstrasi GEOMETRY_ARE_POINTS_IN_POLYGON()\n\n\n\n\n\n\nFungsi feidmath v0.1 memiliki \\(3\\) kategori dengan total \\(6\\) fungsi utama.\nJika memiliki ide untuk pengembangan feidlambda atau fungsi baru bisa langsung disampaikan dengan membuat isu di github. Dan jika bertemu masalah saat penggunaan feidmath v0.1, bisa juga membuat isu di github.\n\n\n\n\n\n\nChangelog\n\n2023-05-26 (v0.1.0)\n\nRilis feidmath v0.1\n\nKategori baru: INTERPOLATION\n\nFungsi baru: INTERPOLATION_LINEAR()\n\nKategori baru: LINALG (LINEAR ALGEBRA)\n\nFungsi baru: LINALG_ROTATION_MATRIX()\nFungsi baru: LINALG_ROTATE_POINT()\nFungsi baru: LINALG_ROTATE_POINT_ARRAY()\n\nKategori baru: GEOMETRY\n\nFungsi baru: GEOMETRY_IS_POINT_IN_POLYGON()\nFungsi baru: GEOMETRY_ARE_POINTS_IN_POLYGON()"
  },
  {
    "objectID": "release/feidlambda-0-4.html",
    "href": "release/feidlambda-0-4.html",
    "title": "feidlambda v0.4",
    "section": "",
    "text": "Official GIST feidlambda (v0.4.x)\n\n\n\nhttps://gist.github.com/taruma/b4df638ecb7af48ab63691951481d6b2\n\n\n\nINSTALASI WORKSHEET FEIDLAMBDA v0.4.0\n\nfeidlambda v0.4 merupakan pengembangan lebih lanjut dari versi v0.3 sehingga fitur/fungsi yang telah tersedia di feidlambda v0.3 tersedia di versi feidlambda v0.4. Dan dengan dirilisnya feidlambda v0.4, tersedia paket feidlambda baru bernama feidmath. feidmath v0.1 merupakan kumpulan fungsi LAMBDA yang fokus menyelesaikan beberapa permasalahan matematika seperti perkalian matriks, rotasi, interpolasi, dlsbnya. Kunjungi halaman rilis feidmath.\n\n\n\n\nUpdate Log v0.4.x\nUpdate Log merupakan catatan pembaruan feidlambda. Berikut catatan perubahan/pembaruan secara umum beserta penjelasan perubahan/pembaruan. Untuk perubahan berdasarkan fungsinya, bisa dilihat di bagian Changelog.\n\nUpdate v0.4.0 (2023-05-26)\n\nKategori baru bernama APPLY_*.\n\nFungsi baru APPLY_COLUMN() yang dapat digunakan untuk menerapkan fungsi LAMBDA pada kolom tertentu di dataset.\n\nFungsi baru di kategori GET_*:\n\nFungsi baru GET_XLOOKUP() yang merupakan fungsi peningkatan dari fungsi bawaan XLOOKUP(). Fungsi GET_XLOOKUP() menerima input vector.\n\n\n\n\n\n\n\n\nFungsi feidlambda v0.4.x\nPada feidlambda v0.4.x, setiap fungsi dikategorikan sesuai kegunaannya. Berikut kategori yang tersedia di feidlambda v0.4.x:\n\nNEW APPLY_*: Memanipulasi data dengan menerapkan fungsi pada subset atau kolom tertentu.\nFILTER_*: Melakukan filtering atau subsetting (memilah) dari data.\nNEW GET_*: Mengambil informasi dari data.\nIS_*: Fungsi logical tambahan.\nMAKE_*: Membangkitkan data.\nREPEAT_*: Mengulangi/merepetisi data.\nRESHAPE_*: Mengubah dimensi data.\nROTATE_*: Merubah posisi data dengan diputar.\nSWAP_*: Menukar posisi data.\nTEXT_*: Fungsi tambahan yang berkaitan dengan teks.\n\nDownload excel demonstrasi RELEASE_feidlambda_v0_4_0.xlsx, untuk memudahkan mengeksplorasi fungsi baru di feidlambda v0.4.x.\n\n\n\n\n\n\nCatatan\n\n\n\nGambar yang ditampilkan pada halaman ini terdapat dari versi sebelumnya (feidlambda v0.3.x) dan tidak diperbarui jika fungsi tersebut tidak memiliki perubahan signifikan. Oleh karena itu, disarankan untuk mengeksplorasi langsung dari dokumen yang telah dilampirkan.\n\n\n\n\n\n\n\nKategori APPLY_*\nNEW v0.4 Kategori APPLY_* merupakan kumpulan fungsi yang menerapkan fungsi LAMBDA pada kolom spesifik atau subset tertentu. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 3.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> APPLY_COLUMN\n\n\n\n\n\nGambar 3.1: Grafik dependencies kategori APPLY_*\n\n\n\n\nFungsi utama kategori APPLY_* yaitu APPLY_COLUMN().\n\n\nSource Code APPLY_*\n\n// NONE --> APPLY_COLUMN\nAPPLY_COLUMN = LAMBDA(array, index_vector, LAMBDA_FUNCTION,\n    LET(\n        index_vector, SORT(index_vector),\n        selected_array, CHOOSECOLS(array, index_vector),\n        applied_array, LAMBDA_FUNCTION(selected_array),\n        sequence_vector, SEQUENCE(COLUMNS(array)),\n        logical_vector, BYROW(\n            sequence_vector,\n            LAMBDA(row, OR(row = index_vector))\n        ),\n        scan_vector, SCAN(\n            0,\n            logical_vector,\n            LAMBDA(acc, curr, IF(curr, acc + 1, acc))\n        ),\n        position_vector, scan_vector + COLUMNS(array),\n        all_array, HSTACK(array, applied_array),\n        selected_vector, MAP(\n            logical_vector,\n            sequence_vector,\n            position_vector,\n            LAMBDA(logical_el, seq_el, pos_el,\n                IF(logical_el, pos_el, seq_el)\n            )\n        ),\n        CHOOSECOLS(all_array, selected_vector)\n    )\n);\n\n\nAPPLY_COLUMN()\nNEW v0.4 Fungsi APPLY_COLUMN(array, index_vector, LAMBDA_FUNCTION) digunakan untuk menerapkan fungsi LAMBDA (LAMBDA_FUNCTION()) pada kolom tertentu di dalam array.\n\n\n\nSyntax\n\nAPPLY_COLUMN(array, index_vector, LAMBDA_FUNCTION)\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array yang memiliki kolom lebih dari satu.\n\nindex_vector := [integer number | integer vector]\n\nIndeks kolom yang ingin diterapkan fungsi lambda.\n\nLAMBDA_FUNCTION := [LAMBDA FUNCTION]\n\nFungsi LAMBDA yang ingin diterapkan pada kolom. Fungsi harus berupa formula LAMBDA (=LAMBDA(...)). Dapat berupa nama fungsi atau formula LAMBDA.\n\n\n\n\n\n\n\nGambar 3.2: Demonstrasi APPLY_COLUMN()\n\n\n\n\n\n\n\n\n\nKategori FILTER_*\nKategori FILTER_* merupakan kumpulan fungsi yang melakukan filtering atau subsetting (memilah) data berupa vector ataupun array. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 4.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> FILTER_DROP_ROWS\n  NONE --> FILTER_DROP_COLUMNS\n  NONE --> FILTER_FUNC_COLUMN\n  FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\n  FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n  _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n  _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\n\n\n\n\n\nGambar 4.1: Grafik dependencies kategori FILTER_*\n\n\n\n\nFungsi utama kategori FILTER_* yaitu FILTER_DROP_ROWS(), FILTER_DROP_COLUMNS(), dan FILTER_MINMAX_ARRAY().\n\n\nSource Code FILTER_*\n\n// NONE --> FILTER_DROP_ROWS\nFILTER_DROP_ROWS = LAMBDA(array, row_index,\n    LET(\n        row_index, TOCOL(row_index),\n        row_index_clean, FILTER(row_index, NOT(ISBLANK(row_index))),\n        nrows, ROWS(array),\n        row_sequence, SEQUENCE(nrows),\n        selected_row, BYROW(\n            row_sequence,\n            LAMBDA(each_row, OR(each_row = row_index_clean))\n        ),\n        FILTER(array, NOT(selected_row))\n    )\n);\n\n// NONE --> FILTER_DROP_COLUMNS\nFILTER_DROP_COLUMNS = LAMBDA(array, column_index,\n    LET(\n        column_index, TOROW(column_index),\n        column_index_clean, FILTER(\n            column_index,\n            NOT(ISBLANK(column_index))\n        ),\n        ncols, COLUMNS(array),\n        col_sequence, SEQUENCE(1, ncols),\n        selected_col, BYCOL(\n            col_sequence,\n            LAMBDA(each_col, OR(each_col = column_index_clean))\n        ),\n        FILTER(array, NOT(selected_col))\n    )\n);\n\n// NONE --> FILTER_FUNC_COLUMN\nFILTER_FUNC_COLUMN = LAMBDA(\n    array,\n    [column_index],\n    [with_label],\n    [label_col],\n    [function],\n    [label_function],\n    [take_first_only],\n    LET(\n        take_first_only, IF(\n            ISOMITTED(take_first_only),\n            FALSE,\n            take_first_only\n        ),\n        column_index, IF(ISOMITTED(column_index), 1, column_index),\n        label_col, IF(ISOMITTED(label_col), column_index, label_col),\n        with_label, IF(ISOMITTED(with_label), FALSE, with_label),\n        function, IF(ISOMITTED(function), LAMBDA(x, MAX(x)), function),\n        label_function, IF(\n            ISOMITTED(label_function),\n            \"func\",\n            label_function\n        ),\n        selected_vector, CHOOSECOLS(array, column_index),\n        func_value, function(selected_vector),\n        selected_logical, selected_vector = func_value,\n        array_filter, FILTER(array, selected_logical),\n        array_func, IF(\n            take_first_only,\n            TAKE(array_filter, 1),\n            array_filter\n        ),\n        label, MAKEARRAY(\n            ROWS(array_func),\n            1,\n            LAMBDA(x, y, CONCAT(label_col, \"_\", label_function))\n        ),\n        IF(with_label, HSTACK(label, array_func), array_func)\n    )\n);\n\n// FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\nFILTER_MINMAX_COLUMN = LAMBDA(\n    array,\n    [column_index],\n    [with_label],\n    [label_col],\n    [take_first_only],\n    LET(\n        func_1, LAMBDA(x, MIN(x)),\n        label_func_1, \"min\",\n        func_2, LAMBDA(x, MAX(x)),\n        label_func_2, \"max\",\n        func1_result, FILTER_FUNC_COLUMN(\n            array,\n            column_index,\n            with_label,\n            label_col,\n            func_1,\n            label_func_1,\n            take_first_only\n        ),\n        func2_result, FILTER_FUNC_COLUMN(\n            array,\n            column_index,\n            with_label,\n            label_col,\n            func_2,\n            label_func_2,\n            take_first_only\n        ),\n        VSTACK(func1_result, func2_result)\n    )\n);\n\n// FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n// _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n_RECURSIVE_FILTER_MINMAX = LAMBDA(\n    array,\n    ntry,\n    [ignore_first_column],\n    [with_label],\n    [label_vector],\n    [take_first_only],\n    LET(\n        ignore_first_column, IF(\n            ISOMITTED(ignore_first_column),\n            FALSE,\n            ignore_first_column\n        ),\n        stop_col, IF(ignore_first_column, 2, 1),\n        label_vector, IF(\n            ISOMITTED(label_vector),\n            SEQUENCE(1, COLUMNS(array)),\n            label_vector\n        ),\n        new_label, IF(\n            stop_col = 2,\n            HSTACK({\" \"}, label_vector),\n            label_vector\n        ),\n        label_col, CHOOSECOLS(new_label, ntry),\n        IF(\n            ntry = stop_col,\n            FILTER_MINMAX_COLUMN(\n                array,\n                ntry,\n                with_label,\n                label_col,\n                take_first_only\n            ),\n            LET(\n                results, FILTER_MINMAX_COLUMN(\n                    array,\n                    ntry,\n                    with_label,\n                    label_col,\n                    take_first_only\n                ),\n                next_try, ntry - 1,\n                VSTACK(\n                    _RECURSIVE_FILTER_MINMAX(\n                        array,\n                        next_try,\n                        ignore_first_column,\n                        with_label,\n                        label_vector,\n                        take_first_only\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\nFILTER_MINMAX_ARRAY = LAMBDA(\n    array,\n    [ignore_first_column],\n    [with_label],\n    [label_vector],\n    [take_first_only],\n    _RECURSIVE_FILTER_MINMAX(\n        array,\n        COLUMNS(array),\n        ignore_first_column,\n        with_label,\n        label_vector,\n        take_first_only\n    )\n);\n\n\nFILTER_DROP_ROWS()\nFungsi FILTER_DROP_ROWS(array, row_index) digunakan untuk menghapus baris dari data.\n\n\n\nSyntax\n\nFILTER_DROP_ROWS(array, row_index)\n\nOutput\n\narray\n\n\n\n\n\narray := [array | vector]\n\nData berupa array atau vector yang memiliki baris lebih dari satu.\n\nrow_index := [integer number | integer vector]\n\nIndeks baris yang ingin dihapus.\n\n\n\n\n\n\n\nGambar 4.2: Demonstrasi FILTER_DROP_ROWS()\n\n\n\n\n\nFILTER_DROP_COLUMNS()\nFungsi FILTER_DROP_COLUMNS(array, column_index) digunakan untuk menghapus kolom dari data.\n\n\n\nSyntax\n\nFILTER_DROP_COLUMNS(array, column_index)\n\nOutput\n\narray\n\n\n\n\n\narray := [array | vector]\n\nData berupa array atau vector yang memiliki kolom lebih dari satu.\n\ncolumn_index := [integer number | integer vector]\n\nIndeks kolom yang ingin dihapus.\n\n\n\n\n\n\n\nGambar 4.3: Demonstrasi FILTER_DROP_COLUMNS()\n\n\n\n\n\nFILTER_MINMAX_ARRAY()\nFungsi FILTER_MINMAX_ARRAY(array, [ignore_first_column], [with_label], [label_vector], [take_first_only]) digunakan untuk melakukan filtering (memilah) data berdasarkan nilai minimum dan maksimum setiap kolomnya dan mengeluarkan hasil dalam berupa dynamic array.\n\n\n\nSyntax\n\nFILTER_MINMAX_ARRAY(array, [ignore_first_column], [with_label], [label_vector], [take_first_only])\n\nOutput\n\narray\n\n\n\n\n\narray := [array | numeric array]\n\nData berupa array dengan ketentuan array berisikan angka kecuali kolom pertama jika menggunakan opsi ignore_first_column.\n\n[ignore_first_column] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka kolom pertama dari array akan diabaikan dan tidak dilakukan filtering nilai minimum/maksimum.\n\n[with_label] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka kolom pertama dari output adalah label informasi minimum dan maksimum seperti 1_min, 1_max, atau no.column_min dan no.column_max. Untuk menggunakan label sendiri, masukin vector label di argumen label_vector.\n\n[label_vector] := NONE :: [vector]\n\nNilai default yaitu NONE. Jika NONE, maka label setiap baris akan dinomori berdasarkan kolomnya (1_min, 1_max). Jika ingin menggunakan label dari nama kolom, jumlah elemen vector harus sama dengan jumlah kolom dari array. Untuk menggunakan label nilai with_label harus TRUE.\n\n[take_first_only] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka hanya baris pertama yang diambil dari hasil pencarian nilai minimum/maksimum.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGambar 4.4: Demonstrasi FILTER_MINMAX_ARRAY()\n\n\n\n\n\n\n\n\nKategori GET_*\nKategori GET_* merupakan kumpulan fungsi yang digunakan untuk mengambil informasi dari suatu data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 5.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> GET_INDEX_2D\n  _RECURSIVE_LOOKUP --> _RECURSIVE_LOOKUP\n  _RECURSIVE_LOOKUP --> GET_XLOOKUP\n\n\n\n\n\nGambar 5.1: Grafik dependencies kategori GET_*\n\n\n\n\nDari Gambar 5.1, diketahui untuk versi v0.4 tersedia fungsi utama GET_INDEX_2D() dan GET_XLOOKUP().\n\n\nSource Code GET_*\n\n// NONE --> GET_INDEX_2D\nGET_INDEX_2D = LAMBDA(lookup_value, array, [return_as_order],\n    LET(\n        return_as_order, IF(\n            ISOMITTED(return_as_order),\n            FALSE,\n            return_as_order\n        ),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        size, nrows * ncols,\n        array_flatten, TOCOL(array, , TRUE),\n        index_sequence, SEQUENCE(nrows, ncols, 1, 1),\n        rows_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, x)),\n        columns_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, y)),\n        rows_flatten, TOCOL(rows_sequence, , TRUE),\n        columns_flatten, TOCOL(columns_sequence, , TRUE),\n        index_flatten, TOCOL(index_sequence, , TRUE),\n        lookup_table, HSTACK(index_flatten, rows_flatten, columns_flatten),\n        lookup_result, FILTER(lookup_table, array_flatten = lookup_value),\n        IF(return_as_order, CHOOSECOLS(lookup_result, 1), lookup_result)\n    )\n);\n\n// _RECURSIVE_LOOKUP --> _RECURSIVE_LOOKUP\n_RECURSIVE_LOOKUP = LAMBDA(\n    ntry,\n    lookup_value,\n    lookup_vector,\n    return_array,\n    [if_not_found],\n    [match_mode],\n    [search_mode],\n    LET(\n        lookup_value, TOCOL(lookup_value),\n        LET(\n            selected_value, VALUE(\n                ARRAYTOTEXT(CHOOSEROWS(lookup_value, ntry))\n            ),\n            result, XLOOKUP(\n                selected_value,\n                lookup_vector,\n                return_array,\n                if_not_found,\n                match_mode,\n                search_mode\n            ),\n            IF(\n                ntry = 1,\n                result,\n                VSTACK(\n                    _RECURSIVE_LOOKUP(\n                        ntry - 1,\n                        lookup_value,\n                        lookup_vector,\n                        return_array,\n                        if_not_found,\n                        match_mode,\n                        search_mode\n                    ),\n                    result\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_LOOKUP --> GET_XLOOKUP\nGET_XLOOKUP = LAMBDA(\n    lookup_value,\n    lookup_vector,\n    return_array,\n    [if_not_found],\n    [match_mode],\n    [search_mode],\n    LET(\n        lookup_value, TOCOL(lookup_value),\n        ntry, ROWS(lookup_value),\n        _RECURSIVE_LOOKUP(\n            ntry,\n            lookup_value,\n            lookup_vector,\n            return_array,\n            if_not_found,\n            match_mode,\n            search_mode\n        )\n    )\n);\n\n\nGET_INDEX_2D()\nFungsi GET_INDEX_2D(lookup_value, array, [return_as_order]) dapat digunakan untuk mengambil informasi urutan nilai yang dicari ataupun posisi baris/kolom dari array.\n\n\n\nSyntax\n\nGET_INDEX_2D(lookup_value, array, [return_as_order])\n\nOutput\n\narray ([order, row index, column index]) atau number vector (order)\n\n\n\n\n\nlookup_value := [scalar]\n\nNilai yang dicari dalam array. Nilai lookup_value adalah nilai tunggal berupa scalar.\n\narray := [array]\n\nData berupa array.\n\n[return_as_order] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, hasil fungsi memberikan urutan angka nilai yang dicari. Urutan dimulai dari horizontal kiri teratas sampai kanan terbawah. Jika FALSE, maka output terdiri dari nomor urut, indeks kolom, dan indeks baris.\n\n\n\n\n\n\n\nGambar 5.2: Demonstrasi GET_INDEX_2D()\n\n\n\n\n\nGET_XLOOKUP()\nNEW v0.4 Fungsi GET_XLOOKUP(lookup_value, lookup_vector, return_array, [if_not_found], [match_mode], [search_mode]) dapat digunakan sebagai pengganti fungsi XLOOKUP() bagi input berupa vector.\n\n\n\nSyntax\n\nGET_XLOOKUP(lookup_value, lookup_vector, return_array, [if_not_found], [match_mode], [search_mode])\n\nOutput\n\narray\n\n\n\n\n\nlookup_value := [vector]\n\nNilai yang akan dicari. Menerima input berupa vector.\n\nlookup_array := [array]\n\nArray atau rentang untuk dicari.\n\nreturn_array := [array]\n\nArray atau rentang yang akan dikembalikan\n\n[if_not_found] := #N/A :: [text]\n\nJika kecocokan valid tidak ditemukan, kembalikan teks [if_not_found] yang Anda masukkan. Jika kecocokan valid tidak ditemukan, dan [if_not_found] hilang, #N/A dikembalikan.\n\n[match_mode] := 0 :: [0 | -1 | 1 | 2]\n\nTentukan tipe yang cocok:\n\n\n\n\n0 - Persis cocok. Jika tidak ditemukan, kembalikan #N/A. Ini adalah pengaturan default.\n-1 - Persis cocok. Jika tidak ada yang ditemukan, kembalikan item berikutnya yang lebih kecil.\n1 - Persis sama. Jika tidak ditemukan, kembalikan item berikutnya yang lebih besar.\n2 - A wildcard match where *, ?, and ~ have special meaning.\n\n\n\n[search_mode] := 1 :: [1 | -1 | 2 | -2]\n\nTentukan mode pencarian yang akan digunakan:\n\n\n\n\n1 - Melakukan pencarian dimulai dari item pertama. Ini adalah pengaturan default.\n-1 - Melakukan pencarian terbalik dimulai dari item terakhir.\n2 - Melakukan pencarian biner yang bergantung pada lookup_array diurutkan dalam urutan naik . Jika tidak diurutkan, hasil yang tidak valid akan dikembalikan.\n-2 - Melakukan pencarian biner yang mengandalkan lookup_array diurutkan dalam urutan menurun . Jika tidak diurutkan, hasil yang tidak valid akan dikembalikan.\n\n\n\nPenjelasan parameter diambil dari halaman bantuan XLOOKUP()\n\n\n\n\nGambar 5.3: Demonstrasi GET_XLOOKUP()\n\n\n\n\n\n\n\n\n\nKategori IS_*\nKategori IS_* merupakan kumpulan fungsi yang dapat digunakan untuk melakukan fungsi logical di data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 6.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> IS_ALL_IN_LOOKUP_VECTOR\n  NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\n  IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\n  NONE --> IS_ROWS_LOGICAL\n  NONE --> IS_COLUMNS_LOGICAL\n\n\n\n\n\nGambar 6.1: Grafik dependencies kategori IS_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code IS_*\n\n// NONE --> IS_ALL_IN_LOOKUP_VECTOR\nIS_ALL_IN_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOCOL(lookup_vector),\n        MAP(\n            array,\n            LAMBDA(element,\n                OR(BYROW(lookup_vector, LAMBDA(lookup, element = lookup)))\n            )\n        )\n    )\n);\n\n// NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\nIS_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOROW(lookup_vector),\n        ncols_vector, COLUMNS(lookup_vector),\n        ncols_array, COLUMNS(array),\n        nrows_array, ROWS(array),\n        IF(\n            ncols_array = ncols_vector,\n            LET(\n                repeat_array, CHOOSEROWS(\n                    lookup_vector,\n                    SEQUENCE(nrows_array, , 1, 0)\n                ),\n                MAP(array, repeat_array, LAMBDA(x, y, x = y))\n            ),\n            \"N/A\"\n        )\n    )\n);\n\n// IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\nIS_ALL_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        array_boolean, IS_COLS_EQUAL_VECTOR(lookup_vector, array),\n        BYROW(array_boolean, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_ROWS_LOGICAL\nIS_ROWS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        BYROW(logical_array, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_COLUMNS_LOGICAL\nIS_COLUMNS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        BYCOL(logical_array, LAMBDA(each_col, logical_function(each_col)))\n    )\n);\n\n\nIS_ALL_IN_VECTOR()\nFungsi IS_ALL_IN_VECTOR(lookup_vector, array) digunakan untuk memeriksa apakah setiap elemen di array termasuk dari lookup_vector.\n\n\n\nSyntax\n\nIS_ALL_IN_VECTOR(lookup_vector, array)\n\nOutput\n\nlogical array\n\n\n\n\n\nlookup_vector := [scalar | vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan.\n\narray := [array | vector]\n\nData berupa array atau vector.\n\n\n\n\n\n\n\nGambar 6.2: Demonstrasi IS_ALL_IN_VECTOR()\n\n\n\n\n\nIS_COLS_EQUAL_VECTOR()\nFungsi IS_COLS_EQUAL_VECTOR(lookup_vector, array) digunakan untuk memeriksa apakah setiap kolom di array termasuk dari setiap elemen di lookup_vector.\n\n\n\nSyntax\n\nIS_COLS_EQUAL_VECTOR(lookup_vector, array)\n\nOutput\n\nlogical array\n\n\n\n\n\nlookup_vector := [vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan. Jumlah elemen lookup_vector harus sama dengan jumlah kolom array.\n\narray := [array | vector]\n\nData berupa array .\n\n\n\n\n\n\n\nGambar 6.3: Demonstrasi IS_COLS_EQUAL_VECTOR()\n\n\n\n\n\nIS_ALL_COLS_EQUAL_VECTOR()\nFungsi IS_ALL_COLS_EQUAL_VECTOR(lookup_vector, array, [logical_function]) digunakan untuk memeriksa apakah setiap kolom di array termasuk dari setiap elemen di lookup_vector, dan diperiksa apakah setiap barisnya sesuai dengan logical_function. Fungsi ini menggunakan fungsi IS_COLS_EQUAL_VECTOR().\n\n\n\nSyntax\n\nIS_ALL_COLS_EQUAL_VECTOR(lookup_vector, array, [logical_function])\n\nOutput\n\ncolumn logical vector\n\n\n\n\n\nlookup_vector := [scalar | vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan. Jumlah elemen lookup_vector harus sama dengan jumlah kolom array.\n\narray := [array | vector]\n\nData berupa array .\n\nlogical_function := OR() :: [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap barisnya.\n\n\n\n\n\n\n\nGambar 6.4: Demonstrasi IS_ALL_COLS_EQUAL_VECTOR()\n\n\n\n\n\nIS_ROWS_LOGICAL()\nFungsi IS_ROWS_LOGICAL(logical_array, [logical_function]) mengaggregasi setiap baris dari logical_array menggunakan fungsi logical_function.\n\n\n\nSyntax\n\nIS_ROWS_LOGICAL(logical_array, [logical_function])\n\nOutput\n\ncolumn vector\n\n\n\n\n\nlogical_array := [logical array]\n\nData berupa logical array .\n\n[logical_function] := OR() [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap barisnya.\n\n\n\n\n\nIS_COLUMNS_LOGICAL()\nFungsi IS_COLUMNS_LOGICAL(logical_array, [logical_function]) mengaggregasi setiap kolom dari logical_array menggunakan fungsi logical_function.\n\n\n\nSyntax\n\nIS_COLUMNS_LOGICAL(logical_array, [logical_function])\n\nOutput\n\nrow vector\n\n\n\n\n\nlogical_array := [logical array]\n\nData berupa logical array .\n\n[logical_function] := OR() [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap kolomnya.\n\n\n\n\n\n\n\nGambar 6.5: Demonstrasi IS_ROWS_LOGICAL() dan IS_COLUMNS_LOGICAL()\n\n\n\n\n\n\n\n\n\nKategori MAKE_*\nKategori MAKE_* merupakan kumpulan fungsi yang membangkitkan (generate) data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 7.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n  _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\n\n\n\n\n\nGambar 7.1: Grafik dependencies kategori MAKE_*\n\n\n\n\nFungsi utama pada kategori ini adalah MAKE_SEQUENCE_FROM_VECTOR().\n\n\nSource Code MAKE_*\n\n// _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n_RECURSIVE_MAKE_SEQUENCE = LAMBDA(\n    start_vector,\n    end_vector,\n    ntry,\n    [stack_horizontally],\n    LET(\n        seq_start, INDEX(start_vector, ntry),\n        seq_end, INDEX(end_vector, ntry),\n        stack_horizontally, IF(\n            ISOMITTED(stack_horizontally),\n            FALSE,\n            stack_horizontally\n        ),\n        IF(\n            ntry = 1,\n            SEQUENCE(seq_end - seq_start + 1, , seq_start),\n            LET(\n                next_try, ntry - 1,\n                results, SEQUENCE(seq_end - seq_start + 1, , seq_start),\n                IF(\n                    stack_horizontally,\n                    HSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    ),\n                    VSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    )\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\nMAKE_SEQUENCE_FROM_VECTOR = LAMBDA(\n    start_vector,\n    end_vector,\n    [stack_horizontally],\n    _RECURSIVE_MAKE_SEQUENCE(\n        start_vector,\n        end_vector,\n        ROWS(start_vector),\n        stack_horizontally\n    )\n);\n\n\nMAKE_SEQUENCE_FROM_VECTOR()\nFungsi MAKE_SEQUENCE_FROM_VECTOR(start_vector, end_vector, [stack_horizontally]) digunakan untuk mebangkitkan sequence dari setiap baris/elemen di start_vector dan end_vector.\n\n\n\nSyntax\n\nMAKE_SEQUENCE_FROM_VECTOR(start_vector, end_vector, [stack_horizontally])\n\nOutput\n\ncolumn vector atau array\n\n\n\n\n\nstart_vector := [integer vector]\n\nVector yang terdiri dari bilangan bulat memulai sequence.\n\nend_vector := [integer vector]\n\nVector yang terdiri dari bilangan bulat akhir sequence.\n\n[stack_horizontally] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka setiap sequence yang dibangkitkan akan disusun horizontal.\n\n\n\n\n\n\n\nGambar 7.2: Demonstrasi MAKE_SEQUENCE_FROM_VECTOR()\n\n\n\n\n\n\n\n\n\nKategori REPEAT_*\nKategori REPEAT_* merupakan kumpulan fungsi yang digunakan untuk melakukan pengulangan array ataupun vector dan menghasilkannya dalam bentuk dynamic array. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 8.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\n  REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\n  REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\n\n\n\n\n\nGambar 8.1: Grafik dependencies kategori REPEAT_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code REPEAT_*\n\n// REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\nREPEAT_ARRAY = LAMBDA(array, [num_repeat], [by_row],\n    LET(\n        by_row, IF(ISOMITTED(by_row), TRUE, by_row),\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            by_row,\n            REPEAT_ARRAY_BY_ROW(array, num_repeat),\n            REPEAT_ARRAY_BY_COLUMN(array, num_repeat)\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\nREPEAT_ARRAY_BY_ROW = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                VSTACK(REPEAT_ARRAY_BY_ROW(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\nREPEAT_ARRAY_BY_COLUMN = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                HSTACK(REPEAT_ARRAY_BY_COLUMN(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n\nREPEAT_ARRAY_BY_ROW()\nFungsi REPEAT_ARRAY_BY_ROW(array, [num_repeat]) digunakan untuk mengulangi array sepanjang baris (ke bawah).\n\n\n\nSyntax\n\nREPEAT_ARRAY_BY_ROW(array, [num_repeat])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n\n\n\n\n\n\nGambar 8.2: Demonstrasi REPEAT_ARRAY_BY_ROW()\n\n\n\n\n\nREPEAT_ARRAY_BY_COLUMN()\nFungsi REPEAT_ARRAY_BY_COLUMN(array, [num_repeat]) digunakan untuk mengulangi array sepanjang kolom (ke kanan).\n\n\n\nSyntax\n\nREPEAT_ARRAY_BY_COLUMN(array, [num_repeat])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n\n\n\n\n\n\nGambar 8.3: Demonstrasi REPEAT_ARRAY_BY_COLUMN()\n\n\n\n\n\nREPEAT_ARRAY()\nFungsi REPEAT_ARRAY(array, [num_repeat], [by_row]) digunakan untuk mengulangi array sepanjang baris/kolom (ke bawah/ke kanan).\n\n\n\nSyntax\n\nREPEAT_ARRAY(array, [num_repeat], [by_row])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n[by_row] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka pengulangan akan sepanjang baris (ke bawah), dan berlaku sebaliknya juga.\n\n\n\n\n\n\n\nGambar 8.4: Demonstrasi REPEAT_ARRAY()\n\n\n\n\n\n\n\n\n\nKategori RESHAPE_*\nKategori RESHAPE_* merupakan kumpulan fungsi yang dapat digunakan untuk melakukan fungsi logical di data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 9.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> RESHAPE_BY_COLUMNS\n\n\n\n\n\nGambar 9.1: Grafik dependencies kategori RESHAPE_*\n\n\n\n\nFungsi utama yang tersedia saat ini hanya RESHAPE_BY_COLUMNS().\n\n\nSource Code RESHAPE_*\n\n// NONE --> RESHAPE_BY_COLUMNS\nRESHAPE_BY_COLUMNS = LAMBDA(array, [num_split],\n    LET(\n        num_split, IF(ISOMITTED(num_split), 2, num_split),\n        ncols, COLUMNS(array),\n        nrows, ROWS(array),\n        IF(\n            MOD(ncols, num_split) = 0,\n            LET(\n                divider, ncols / num_split,\n                divider_sequence, CHOOSEROWS(\n                    SEQUENCE(1, divider),\n                    SEQUENCE(num_split, , 1, 0)\n                ),\n                divider_flatten, TOCOL(divider_sequence, , TRUE),\n                divider_repeat, CHOOSEROWS(\n                    TOROW(divider_flatten),\n                    SEQUENCE(nrows, , 1, 0)\n                ),\n                divider_repeat_col, TOCOL(divider_repeat),\n                array_flatten, TOCOL(array),\n                array_sorted, SORTBY(array_flatten, divider_repeat_col),\n                WRAPROWS(array_sorted, num_split)\n            ),\n            NA()\n        )\n    )\n);\n\n\nRESHAPE_BY_COLUMNS()\nFungsi RESHAPE_BY_COLUMNS(array, [num_split]) digunakan untuk mengubah dimensi (transformasi) array berdasarkan jumlah pembagi kolomnya. Jika tidak jumlah kolom tidak habis dibagi oleh num_split akan mengeluarkan hasil #N/A.\n\n\n\nSyntax\n\nRESHAPE_BY_COLUMNS(array, [num_split])\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array atau vector.\n\n[num_split] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pembagi kolom. Jumlah kolom array harus habis dibagi (MOD()) dengan num_split.\n\n\n\n\n\n\n\nGambar 9.2: Demonstrasi RESHAPE_BY_COLUMNS()\n\n\n\n\n\n\n\n\n\nKategori ROTATE_*\nKategori ROTATE_* merupakan kumpulan fungsi yang digunakan untuk menggeser atau memutar array ataupun vector. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 10.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> ROTATE_VECTOR\n  ROTATE_VECTOR --> ROTATE_ARRAY\n\n\n\n\n\nGambar 10.1: Grafik dependencies kategori ROTATE_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code ROTATE_*\n\n// NONE --> ROTATE_VECTOR\nROTATE_VECTOR = LAMBDA(vector, num_rotation, [as_column_vector],\n    LET(\n        vector, TOCOL(vector),\n        rotated_array, IFS(\n            OR(\n                num_rotation = 0,\n                num_rotation >= ROWS(vector),\n                num_rotation <= -ROWS(vector)\n            ),\n            vector,\n            num_rotation > 0,\n            VSTACK(DROP(vector, num_rotation), TAKE(vector, num_rotation)),\n            num_rotation < 0,\n            VSTACK(TAKE(vector, num_rotation), DROP(vector, num_rotation))\n        ),\n        as_column_vector, IF(ISOMITTED(as_column_vector), FALSE, TRUE),\n        IF(as_column_vector, TOROW(rotated_array), TOCOL(rotated_array))\n    )\n);\n\n// ROTATE_VECTOR --> ROTATE_ARRAY\nROTATE_ARRAY = LAMBDA(array, num_rotation, [rotate_columns],\n    LET(\n        rotate_columns, IF(ISOMITTED(rotate_columns), TRUE, FALSE),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        seqrows, SEQUENCE(nrows),\n        seqcols, SEQUENCE(1, ncols),\n        results, IF(\n            rotate_columns,\n            CHOOSECOLS(array, ROTATE_VECTOR(seqcols, num_rotation, TRUE)),\n            CHOOSEROWS(array, ROTATE_VECTOR(seqrows, num_rotation, FALSE))\n        ),\n        results\n    )\n);\n\n\nROTATE_VECTOR()\nFungsi ROTATE_VECTOR(vector, num_rotation, [as_column_vector]) digunakan untuk menggeser/memutar elemen yang ada di vector sebanyak num_rotation.\n\n\n\nSyntax\n\nROTATE_VECTOR(vector, num_rotation, [as_column_vector])\n\nOutput\n\nvector\n\n\n\n\n\nvector := [vector]\n\nData berupa vector (column vector atau row vector).\n\nnum_rotation := [integer]\n\nJumlah berapa kali vector diputar/digeser. Nilai negatif untuk digeser berlawanan arah.\n\n[as_column_vector] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka output berupa column vector.\n\n\n\n\n\n\n\nGambar 10.2: Demonstrasi ROTATE_VECTOR()\n\n\n\n\n\nROTATE_ARRAY()\nFungsi ROTATE_ARRAY(array, num_rotation, [rotate_columns]) digunakan untuk menggeser/memutar elemen yang ada di array sebanyak num_rotation berdasarkan baris atau kolom.\n\n\n\nSyntax\n\nROTATE_ARRAY(array, num_rotation, [rotate_columns])\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array.\n\nnum_rotation := [scalar | vector]\n\nJumlah berapa kali vector diputar/digeser. Nilai negatif untuk digeser berlawanan arah.\n\n[rotate_columns] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka array diputar berdasarkan kolom. Jika FALSE, maka array diputar berdasarkan baris.\n\n\n\n\n\n\n\nGambar 10.3: Demonstrasi ROTATE_ARRAY()\n\n\n\n\n\n\n\n\n\nKategori SWAP_*\nKategori SWAP_* merupakan kumpulan fungsi yang digunakan untuk mengganti atau mengubah posisi elemen atau vector. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 11.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> SWAP_COLUMNS\n  NONE --> SWAP_ROWS\n\n\n\n\n\nGambar 11.1: Grafik dependencies kategori SWAP_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code SWAP_*\n\n// NONE --> SWAP_COLUMNS\nSWAP_COLUMNS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        ncols, COLUMNS(array),\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), -1, to_index),\n        from_value, IF(from_index < 0, from_index + ncols + 1, from_index),\n        to_value, IF(to_index < 0, to_index + ncols + 1, to_index),\n        column_sequence, SEQUENCE(1, COLUMNS(array)),\n        from_logical, column_sequence = from_value,\n        to_logical, column_sequence = to_value,\n        replace_from, IF(from_logical, to_value, column_sequence),\n        replace_to, IF(to_logical, from_value, replace_from),\n        CHOOSECOLS(array, replace_to)\n    )\n);\n\n// NONE --> SWAP_ROWS\nSWAP_ROWS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        nrows, ROWS(array),\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), -1, to_index),\n        from_value, IF(from_index < 0, from_index + nrows + 1, from_index),\n        to_value, IF(to_index < 0, to_index + nrows + 1, to_index),\n        row_sequence, SEQUENCE(ROWS(array)),\n        from_logical, row_sequence = from_value,\n        to_logical, row_sequence = to_value,\n        replace_from, IF(from_logical, to_value, row_sequence),\n        replace_to, IF(to_logical, from_value, replace_from),\n        CHOOSEROWS(array, replace_to)\n    )\n);\n\n\nSWAP_COLUMNS()\nFungsi SWAP_COLUMNS(array, [from_index], [to_index]) digunakan untuk menukar posisi kolom ke-from_index dengan kolom ke-to_index.\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [row vector | array]\n\nData dapat berupa array atau row vector.\n\n[from_index] := 1 :: [integer]\n\nNilai default yaitu 1. Posisi index kolom yang ingin dipindahkan. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n[to_index] := -1 :: [integer]\n\nNilai default yaitu -1. Posisi index tujuan kolom. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n\n\n\n\nSWAP_ROWS()\nFungsi SWAP_ROWS(array, [from_index], [to_index]) digunakan untuk menukar posisi baris ke-from_index dengan baris ke-to_index.\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [column vector | array]\n\nData dapat berupa array atau column vector.\n\n[from_index] := 1 :: [integer]\n\nNilai default yaitu 1. Posisi index baris yang ingin dipindahkan. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n[to_index] := -1 :: [integer]\n\nNilai default yaitu -1. Posisi index tujuan baris. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n\n\n\n\n\n\nGambar 11.2: Demonstrasi SWAP_COLUMNS() dan SWAP_ROWS()\n\n\n\n\n\n\n\n\n\nKategori TEXT_*\nKategori TEXT_* merupakan kumpulan fungsi yang digunakan untuk memproses data teks. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 12.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  _RECURSIVE_TEXT_SPLIT --> _RECURSIVE_TEXT_SPLIT\n  _RECURSIVE_TEXT_SPLIT --> TEXT_SPLIT_VECTOR\n\n\n\n\n\nGambar 12.1: Grafik dependencies kategori TEXT_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code TEXT_*\n\n// _RECURSIVE_TEXT_SPLIT --> _RECURSIVE_TEXT_SPLIT\n_RECURSIVE_TEXT_SPLIT = LAMBDA(\n    text_vector,\n    ntry,\n    col_delimiter,\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    LET(\n        text_vector, TOCOL(text_vector),\n        selected_row, ARRAYTOTEXT(INDEX(text_vector, ntry)),\n        IF(\n            ntry = 1,\n            TEXTSPLIT(\n                selected_row,\n                col_delimiter,\n                row_delimiter,\n                ignore_empty,\n                match_mode,\n                pad_with\n            ),\n            LET(\n                next_try, ntry - 1,\n                results, TEXTSPLIT(\n                    selected_row,\n                    col_delimiter,\n                    row_delimiter,\n                    ignore_empty,\n                    match_mode,\n                    pad_with\n                ),\n                VSTACK(\n                    _RECURSIVE_TEXT_SPLIT(\n                        text_vector,\n                        next_try,\n                        col_delimiter,\n                        row_delimiter,\n                        ignore_empty,\n                        match_mode,\n                        pad_with\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_TEXT_SPLIT --> TEXT_SPLIT_VECTOR\nTEXT_SPLIT_VECTOR = LAMBDA(\n    text_vector,\n    [col_delimiter],\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    [replace_na],\n    LET(\n        nrows, ROWS(text_vector),\n        col_delimiter, IF(ISOMITTED(col_delimiter), \" \", col_delimiter),\n        replace_na, IF(ISOMITTED(replace_na), NA(), replace_na),\n        pad_with, IF(ISOMITTED(pad_with), \"\", pad_with),\n        result, _RECURSIVE_TEXT_SPLIT(\n            text_vector,\n            nrows,\n            col_delimiter,\n            row_delimiter,\n            ignore_empty,\n            match_mode,\n            pad_with\n        ),\n        IFERROR(result, replace_na)\n    )\n);\n\n\nTEXT_SPLIT_VECTOR()\nFungsi TEXT_SPLIT_VECTOR(text_vector, [col_delimiter], [row_delimiter], [ignore_empty], [match_mode], [pad_with], [replace_na]) merupakan fungsi pengembangan lanjutan dari TEXTSPLIT() yang mampu menerima input data berupa vector dan menghasilkan dalam bentuk dynamic array.\n\n\n\nSyntax\n\nTEXT_SPLIT_VECTOR(text_vector, [col_delimiter], [row_delimiter], [ignore_empty], [match_mode], [pad_with], [replace_na])\n\nOutput\n\narray\n\n\n\n\n\ntext_vector := [text vector]\n\nData harus berupa text column vector.\n\n[col_delimiter] := \" \" :: [text]\n\nNilai default yaitu \" \" (spasi). Teks pemisah untuk setiap kolomnya.\n\n[row_delimiter] := \"\" :: [text]\n\nNilai default yaitu \"\" (tidak ada). Teks pemisah untuk setiap barisnya.\n\n[ignore_empty] := FALSE :: [TRUE | FALSE]\n\nTentukan TRUE untuk mengabaikan pemisah berurutan. Default ke FALSE, yang membuat sel kosong. Opsional.\n\n[match_mode] := 0 :: [0 | 1]\n\nTentukan 1 untuk melakukan kecocokan yang tidak peka huruf besar kecil. Default ke 0, yang melakukan kecocokan peka huruf besar kecil. Opsional.\n\n[pad_with] := #N/A :: [text | number]\n\nNilai untuk mengalihkan hasil. Defaultnya adalah #N/A.\n\n[replace_na] := #N/A :: [text | number]\n\nNilai untuk menggantikan nilai #N/A dari hasil akhir. Defaultnya adalah #N/A. Nilai #N/A yang ada dikarenakan proses VSTACK() yang memiliki dimensi hasil TEXTSPLIT() yang berbeda-beda.\n\n\n\nDeskripsi ignore_empty, match_mode, dan pad_with diambil dari halaman Fungsi TEXTSPLIT.\n\nLimitasi TEXT_SPLIT_VECTOR()\n\nHindari menggunakan TEXT_SPLIT_VECTOR() dengan jumlah baris yang banyak ataupun dimensi output yang besar. Pastikan hasil output fungsi memiliki dimensi yang kecil seperti jumlah kolom \\(\\le 10\\) dan jumlah baris \\(\\le 1,000\\).\nUkuran text_vector masih bisa lebih besar dari batasan diatas, akan tetapi disarankan untuk penggunaan TEXT_SPLIT_VECTOR() selalu bertahap, yaitu dari jumlah baris yang sedikit sampai jumlah baris optimal yang tidak menampilkan error atau crash.\nJika melebihi kemampuan, akan menghasilkan nilai error berupa #NUM / #CALC.\n\n\n\n\n\nGambar 12.2: Demonstrasi TEXT_SPLIT_VECTOR (outdated)\n\n\n\n\n\n\nJika ada ide untuk pengembangan feidlambda atau fungsi baru bisa langsung disampaikan dengan membuat isu di github. Dan jika bertemu masalah saat penggunaan feidlambda v0.4, bisa juga membuat isu di github.\n\n\n\n\n\n\n\nChangelog\n\n2023-05-26 (v0.4.0)\n\nRilis feidlambda v0.4"
  },
  {
    "objectID": "release/source-code.html",
    "href": "release/source-code.html",
    "title": "Source Code",
    "section": "",
    "text": "feidlambda v0.4\n/*\nfeidlambda v0.4.0 - LOGIC / UTILITIES FUNCTIONS BY FIAKO ENGINEERING\nOFFICIAL GIST (feidlambda v0.4.x): \n    https://gist.github.com/taruma/b4df638ecb7af48ab63691951481d6b2\nREPOSITORY: \n    https://github.com/fiakoenjiniring/feidlambda\nCONTRIBUTOR: @taruma, @iingLK\nTESTED: Microsoft Excel 365 v2304\n*/\n\n// BATAS MAKSMIMUM LAYAR EDITOR -------------------------------------------#\n\n/* \n---- APPLY ----\n*/\n\n// NONE --> APPLY_COLUMN\nAPPLY_COLUMN = LAMBDA(array, index_vector, LAMBDA_FUNCTION,\n    LET(\n        index_vector, SORT(index_vector),\n        selected_array, CHOOSECOLS(array, index_vector),\n        applied_array, LAMBDA_FUNCTION(selected_array),\n        sequence_vector, SEQUENCE(COLUMNS(array)),\n        logical_vector, BYROW(\n            sequence_vector,\n            LAMBDA(row, OR(row = index_vector))\n        ),\n        scan_vector, SCAN(\n            0,\n            logical_vector,\n            LAMBDA(acc, curr, IF(curr, acc + 1, acc))\n        ),\n        position_vector, scan_vector + COLUMNS(array),\n        all_array, HSTACK(array, applied_array),\n        selected_vector, MAP(\n            logical_vector,\n            sequence_vector,\n            position_vector,\n            LAMBDA(logical_el, seq_el, pos_el,\n                IF(logical_el, pos_el, seq_el)\n            )\n        ),\n        CHOOSECOLS(all_array, selected_vector)\n    )\n);\n\n/*\n---- FILTER ----\n*/\n\n// NONE --> FILTER_DROP_ROWS\nFILTER_DROP_ROWS = LAMBDA(array, row_index,\n    LET(\n        row_index, TOCOL(row_index),\n        row_index_clean, FILTER(row_index, NOT(ISBLANK(row_index))),\n        nrows, ROWS(array),\n        row_sequence, SEQUENCE(nrows),\n        selected_row, BYROW(\n            row_sequence,\n            LAMBDA(each_row, OR(each_row = row_index_clean))\n        ),\n        FILTER(array, NOT(selected_row))\n    )\n);\n\n// NONE --> FILTER_DROP_COLUMNS\nFILTER_DROP_COLUMNS = LAMBDA(array, column_index,\n    LET(\n        column_index, TOROW(column_index),\n        column_index_clean, FILTER(\n            column_index,\n            NOT(ISBLANK(column_index))\n        ),\n        ncols, COLUMNS(array),\n        col_sequence, SEQUENCE(1, ncols),\n        selected_col, BYCOL(\n            col_sequence,\n            LAMBDA(each_col, OR(each_col = column_index_clean))\n        ),\n        FILTER(array, NOT(selected_col))\n    )\n);\n\n// NONE --> FILTER_FUNC_COLUMN\nFILTER_FUNC_COLUMN = LAMBDA(\n    array,\n    [column_index],\n    [with_label],\n    [label_col],\n    [function],\n    [label_function],\n    [take_first_only],\n    LET(\n        take_first_only, IF(\n            ISOMITTED(take_first_only),\n            FALSE,\n            take_first_only\n        ),\n        column_index, IF(ISOMITTED(column_index), 1, column_index),\n        label_col, IF(ISOMITTED(label_col), column_index, label_col),\n        with_label, IF(ISOMITTED(with_label), FALSE, with_label),\n        function, IF(ISOMITTED(function), LAMBDA(x, MAX(x)), function),\n        label_function, IF(\n            ISOMITTED(label_function),\n            \"func\",\n            label_function\n        ),\n        selected_vector, CHOOSECOLS(array, column_index),\n        func_value, function(selected_vector),\n        selected_logical, selected_vector = func_value,\n        array_filter, FILTER(array, selected_logical),\n        array_func, IF(\n            take_first_only,\n            TAKE(array_filter, 1),\n            array_filter\n        ),\n        label, MAKEARRAY(\n            ROWS(array_func),\n            1,\n            LAMBDA(x, y, CONCAT(label_col, \"_\", label_function))\n        ),\n        IF(with_label, HSTACK(label, array_func), array_func)\n    )\n);\n\n// FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\nFILTER_MINMAX_COLUMN = LAMBDA(\n    array,\n    [column_index],\n    [with_label],\n    [label_col],\n    [take_first_only],\n    LET(\n        func_1, LAMBDA(x, MIN(x)),\n        label_func_1, \"min\",\n        func_2, LAMBDA(x, MAX(x)),\n        label_func_2, \"max\",\n        func1_result, FILTER_FUNC_COLUMN(\n            array,\n            column_index,\n            with_label,\n            label_col,\n            func_1,\n            label_func_1,\n            take_first_only\n        ),\n        func2_result, FILTER_FUNC_COLUMN(\n            array,\n            column_index,\n            with_label,\n            label_col,\n            func_2,\n            label_func_2,\n            take_first_only\n        ),\n        VSTACK(func1_result, func2_result)\n    )\n);\n\n// FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n// _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n_RECURSIVE_FILTER_MINMAX = LAMBDA(\n    array,\n    ntry,\n    [ignore_first_column],\n    [with_label],\n    [label_vector],\n    [take_first_only],\n    LET(\n        ignore_first_column, IF(\n            ISOMITTED(ignore_first_column),\n            FALSE,\n            ignore_first_column\n        ),\n        stop_col, IF(ignore_first_column, 2, 1),\n        label_vector, IF(\n            ISOMITTED(label_vector),\n            SEQUENCE(1, COLUMNS(array)),\n            label_vector\n        ),\n        new_label, IF(\n            stop_col = 2,\n            HSTACK({\" \"}, label_vector),\n            label_vector\n        ),\n        label_col, CHOOSECOLS(new_label, ntry),\n        IF(\n            ntry = stop_col,\n            FILTER_MINMAX_COLUMN(\n                array,\n                ntry,\n                with_label,\n                label_col,\n                take_first_only\n            ),\n            LET(\n                results, FILTER_MINMAX_COLUMN(\n                    array,\n                    ntry,\n                    with_label,\n                    label_col,\n                    take_first_only\n                ),\n                next_try, ntry - 1,\n                VSTACK(\n                    _RECURSIVE_FILTER_MINMAX(\n                        array,\n                        next_try,\n                        ignore_first_column,\n                        with_label,\n                        label_vector,\n                        take_first_only\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\nFILTER_MINMAX_ARRAY = LAMBDA(\n    array,\n    [ignore_first_column],\n    [with_label],\n    [label_vector],\n    [take_first_only],\n    _RECURSIVE_FILTER_MINMAX(\n        array,\n        COLUMNS(array),\n        ignore_first_column,\n        with_label,\n        label_vector,\n        take_first_only\n    )\n);\n\n/*\n---- GET ----\n*/\n\n// NONE --> GET_INDEX_2D\nGET_INDEX_2D = LAMBDA(lookup_value, array, [return_as_order],\n    LET(\n        return_as_order, IF(\n            ISOMITTED(return_as_order),\n            FALSE,\n            return_as_order\n        ),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        size, nrows * ncols,\n        array_flatten, TOCOL(array, , TRUE),\n        index_sequence, SEQUENCE(nrows, ncols, 1, 1),\n        rows_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, x)),\n        columns_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, y)),\n        rows_flatten, TOCOL(rows_sequence, , TRUE),\n        columns_flatten, TOCOL(columns_sequence, , TRUE),\n        index_flatten, TOCOL(index_sequence, , TRUE),\n        lookup_table, HSTACK(index_flatten, rows_flatten, columns_flatten),\n        lookup_result, FILTER(lookup_table, array_flatten = lookup_value),\n        IF(return_as_order, CHOOSECOLS(lookup_result, 1), lookup_result)\n    )\n);\n\n// _RECURSIVE_LOOKUP --> _RECURSIVE_LOOKUP\n_RECURSIVE_LOOKUP = LAMBDA(\n    ntry,\n    lookup_value,\n    lookup_vector,\n    return_array,\n    [if_not_found],\n    [match_mode],\n    [search_mode],\n    LET(\n        lookup_value, TOCOL(lookup_value),\n        LET(\n            selected_value, VALUE(\n                ARRAYTOTEXT(CHOOSEROWS(lookup_value, ntry))\n            ),\n            result, XLOOKUP(\n                selected_value,\n                lookup_vector,\n                return_array,\n                if_not_found,\n                match_mode,\n                search_mode\n            ),\n            IF(\n                ntry = 1,\n                result,\n                VSTACK(\n                    _RECURSIVE_LOOKUP(\n                        ntry - 1,\n                        lookup_value,\n                        lookup_vector,\n                        return_array,\n                        if_not_found,\n                        match_mode,\n                        search_mode\n                    ),\n                    result\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_LOOKUP --> GET_XLOOKUP\nGET_XLOOKUP = LAMBDA(\n    lookup_value,\n    lookup_vector,\n    return_array,\n    [if_not_found],\n    [match_mode],\n    [search_mode],\n    LET(\n        lookup_value, TOCOL(lookup_value),\n        ntry, ROWS(lookup_value),\n        _RECURSIVE_LOOKUP(\n            ntry,\n            lookup_value,\n            lookup_vector,\n            return_array,\n            if_not_found,\n            match_mode,\n            search_mode\n        )\n    )\n);\n\n/*\n---- IS ----\n*/\n\n// NONE --> IS_ALL_IN_LOOKUP_VECTOR\nIS_ALL_IN_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOCOL(lookup_vector),\n        MAP(\n            array,\n            LAMBDA(element,\n                OR(BYROW(lookup_vector, LAMBDA(lookup, element = lookup)))\n            )\n        )\n    )\n);\n\n// NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\nIS_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOROW(lookup_vector),\n        ncols_vector, COLUMNS(lookup_vector),\n        ncols_array, COLUMNS(array),\n        nrows_array, ROWS(array),\n        IF(\n            ncols_array = ncols_vector,\n            LET(\n                repeat_array, CHOOSEROWS(\n                    lookup_vector,\n                    SEQUENCE(nrows_array, , 1, 0)\n                ),\n                MAP(array, repeat_array, LAMBDA(x, y, x = y))\n            ),\n            \"N/A\"\n        )\n    )\n);\n\n// IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\nIS_ALL_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        array_boolean, IS_COLS_EQUAL_VECTOR(lookup_vector, array),\n        BYROW(array_boolean, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_ROWS_LOGICAL\nIS_ROWS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        BYROW(logical_array, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_COLUMNS_LOGICAL\nIS_COLUMNS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        BYCOL(logical_array, LAMBDA(each_col, logical_function(each_col)))\n    )\n);\n\n/*\n---- MAKE ----\n*/\n\n// _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n_RECURSIVE_MAKE_SEQUENCE = LAMBDA(\n    start_vector,\n    end_vector,\n    ntry,\n    [stack_horizontally],\n    LET(\n        seq_start, INDEX(start_vector, ntry),\n        seq_end, INDEX(end_vector, ntry),\n        stack_horizontally, IF(\n            ISOMITTED(stack_horizontally),\n            FALSE,\n            stack_horizontally\n        ),\n        IF(\n            ntry = 1,\n            SEQUENCE(seq_end - seq_start + 1, , seq_start),\n            LET(\n                next_try, ntry - 1,\n                results, SEQUENCE(seq_end - seq_start + 1, , seq_start),\n                IF(\n                    stack_horizontally,\n                    HSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    ),\n                    VSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    )\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\nMAKE_SEQUENCE_FROM_VECTOR = LAMBDA(\n    start_vector,\n    end_vector,\n    [stack_horizontally],\n    _RECURSIVE_MAKE_SEQUENCE(\n        start_vector,\n        end_vector,\n        ROWS(start_vector),\n        stack_horizontally\n    )\n);\n\n/*\n---- REPEAT ----\n*/\n\n// REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\nREPEAT_ARRAY = LAMBDA(array, [num_repeat], [by_row],\n    LET(\n        by_row, IF(ISOMITTED(by_row), TRUE, by_row),\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            by_row,\n            REPEAT_ARRAY_BY_ROW(array, num_repeat),\n            REPEAT_ARRAY_BY_COLUMN(array, num_repeat)\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\nREPEAT_ARRAY_BY_ROW = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                VSTACK(REPEAT_ARRAY_BY_ROW(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\nREPEAT_ARRAY_BY_COLUMN = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                HSTACK(REPEAT_ARRAY_BY_COLUMN(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n/*\n---- RESHAPE ----\n*/\n\n// NONE --> RESHAPE_BY_COLUMNS\nRESHAPE_BY_COLUMNS = LAMBDA(array, [num_split],\n    LET(\n        num_split, IF(ISOMITTED(num_split), 2, num_split),\n        ncols, COLUMNS(array),\n        nrows, ROWS(array),\n        IF(\n            MOD(ncols, num_split) = 0,\n            LET(\n                divider, ncols / num_split,\n                divider_sequence, CHOOSEROWS(\n                    SEQUENCE(1, divider),\n                    SEQUENCE(num_split, , 1, 0)\n                ),\n                divider_flatten, TOCOL(divider_sequence, , TRUE),\n                divider_repeat, CHOOSEROWS(\n                    TOROW(divider_flatten),\n                    SEQUENCE(nrows, , 1, 0)\n                ),\n                divider_repeat_col, TOCOL(divider_repeat),\n                array_flatten, TOCOL(array),\n                array_sorted, SORTBY(array_flatten, divider_repeat_col),\n                WRAPROWS(array_sorted, num_split)\n            ),\n            NA()\n        )\n    )\n);\n\n/*\n---- ROTATE ----\n*/\n\n// NONE --> ROTATE_VECTOR\nROTATE_VECTOR = LAMBDA(vector, num_rotation, [as_column_vector],\n    LET(\n        vector, TOCOL(vector),\n        rotated_array, IFS(\n            OR(\n                num_rotation = 0,\n                num_rotation >= ROWS(vector),\n                num_rotation <= -ROWS(vector)\n            ),\n            vector,\n            num_rotation > 0,\n            VSTACK(DROP(vector, num_rotation), TAKE(vector, num_rotation)),\n            num_rotation < 0,\n            VSTACK(TAKE(vector, num_rotation), DROP(vector, num_rotation))\n        ),\n        as_column_vector, IF(ISOMITTED(as_column_vector), FALSE, TRUE),\n        IF(as_column_vector, TOROW(rotated_array), TOCOL(rotated_array))\n    )\n);\n\n// ROTATE_VECTOR --> ROTATE_ARRAY\nROTATE_ARRAY = LAMBDA(array, num_rotation, [rotate_columns],\n    LET(\n        rotate_columns, IF(ISOMITTED(rotate_columns), TRUE, FALSE),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        seqrows, SEQUENCE(nrows),\n        seqcols, SEQUENCE(1, ncols),\n        results, IF(\n            rotate_columns,\n            CHOOSECOLS(array, ROTATE_VECTOR(seqcols, num_rotation, TRUE)),\n            CHOOSEROWS(array, ROTATE_VECTOR(seqrows, num_rotation, FALSE))\n        ),\n        results\n    )\n);\n\n/*\n---- SWAP ----\n*/\n\n// NONE --> SWAP_COLUMNS\nSWAP_COLUMNS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        ncols, COLUMNS(array),\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), -1, to_index),\n        from_value, IF(from_index < 0, from_index + ncols + 1, from_index),\n        to_value, IF(to_index < 0, to_index + ncols + 1, to_index),\n        column_sequence, SEQUENCE(1, COLUMNS(array)),\n        from_logical, column_sequence = from_value,\n        to_logical, column_sequence = to_value,\n        replace_from, IF(from_logical, to_value, column_sequence),\n        replace_to, IF(to_logical, from_value, replace_from),\n        CHOOSECOLS(array, replace_to)\n    )\n);\n\n// NONE --> SWAP_ROWS\nSWAP_ROWS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        nrows, ROWS(array),\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), -1, to_index),\n        from_value, IF(from_index < 0, from_index + nrows + 1, from_index),\n        to_value, IF(to_index < 0, to_index + nrows + 1, to_index),\n        row_sequence, SEQUENCE(ROWS(array)),\n        from_logical, row_sequence = from_value,\n        to_logical, row_sequence = to_value,\n        replace_from, IF(from_logical, to_value, row_sequence),\n        replace_to, IF(to_logical, from_value, replace_from),\n        CHOOSEROWS(array, replace_to)\n    )\n);\n\n/*\n---- TEXT ----\n*/\n\n// _RECURSIVE_TEXT_SPLIT --> _RECURSIVE_TEXT_SPLIT\n_RECURSIVE_TEXT_SPLIT = LAMBDA(\n    text_vector,\n    ntry,\n    col_delimiter,\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    LET(\n        text_vector, TOCOL(text_vector),\n        selected_row, ARRAYTOTEXT(INDEX(text_vector, ntry)),\n        IF(\n            ntry = 1,\n            TEXTSPLIT(\n                selected_row,\n                col_delimiter,\n                row_delimiter,\n                ignore_empty,\n                match_mode,\n                pad_with\n            ),\n            LET(\n                next_try, ntry - 1,\n                results, TEXTSPLIT(\n                    selected_row,\n                    col_delimiter,\n                    row_delimiter,\n                    ignore_empty,\n                    match_mode,\n                    pad_with\n                ),\n                VSTACK(\n                    _RECURSIVE_TEXT_SPLIT(\n                        text_vector,\n                        next_try,\n                        col_delimiter,\n                        row_delimiter,\n                        ignore_empty,\n                        match_mode,\n                        pad_with\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_TEXT_SPLIT --> TEXT_SPLIT_VECTOR\nTEXT_SPLIT_VECTOR = LAMBDA(\n    text_vector,\n    [col_delimiter],\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    [replace_na],\n    LET(\n        nrows, ROWS(text_vector),\n        col_delimiter, IF(ISOMITTED(col_delimiter), \" \", col_delimiter),\n        replace_na, IF(ISOMITTED(replace_na), NA(), replace_na),\n        pad_with, IF(ISOMITTED(pad_with), \"\", pad_with),\n        result, _RECURSIVE_TEXT_SPLIT(\n            text_vector,\n            nrows,\n            col_delimiter,\n            row_delimiter,\n            ignore_empty,\n            match_mode,\n            pad_with\n        ),\n        IFERROR(result, replace_na)\n    )\n);\n\n/*\nMIT License\n\nCopyright (c) 2022-2023 PT. FIAKO ENJINIRING INDONESIA\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n\nfeidmath v0.1\n/*\nfeidmath v0.1.0 - MATH FUNCTIONS BY FIAKO ENGINEERING\nOFFICIAL GIST (feidmath v0.1.x): \n    https://gist.github.com/taruma/8b0978227dffbee50c3a9d56e31d34f3\nREPOSITORY: \n    https://github.com/fiakoenjiniring/feidlambda\nCONTRIBUTOR: @taruma, @iingLK\nTESTED: Microsoft Excel 365 v2304\n*/\n\n// BATAS MAKSMIMUM LAYAR EDITOR -------------------------------------------#\n\n/*\n---- INTERPOLATION ----\n*/\n\n// NONE ---> _INTERPOLATION_LINEAR\n_INTERPOLATION_LINEAR = LAMBDA(x, known_ys, known_xs,\n    LET(\n        known_xs, TOCOL(known_xs),\n        known_ys, TOCOL(known_ys),\n        nrow, ROWS(known_ys),\n        known_table, HSTACK(known_xs, known_ys),\n        sorted_table, SORT(known_table, 1),\n        sorted_xs, CHOOSECOLS(sorted_table, 1),\n        sorted_ys, CHOOSECOLS(sorted_table, 2),\n        nearest_x, IFS(\n            x > MAX(sorted_xs),\n            XMATCH(x, sorted_xs, -1),\n            x < MIN(sorted_xs),\n            XMATCH(x, sorted_xs, 1),\n            TRUE,\n            XMATCH(x, sorted_xs, -1)\n        ),\n        index_ys, IF(\n            nearest_x < nrow,\n            VSTACK(nearest_x, nearest_x + 1),\n            VSTACK(nearest_x - 1, nearest_x)\n        ),\n        select_ys, CHOOSEROWS(sorted_ys, index_ys),\n        select_xs, CHOOSEROWS(sorted_xs, index_ys),\n        FORECAST.LINEAR(x, select_ys, select_xs)\n    )\n);\n\n// _INTERPOLATION_LINEAR ---> INTERPOLATION_LINEAR\nINTERPOLATION_LINEAR = LAMBDA(x_vector, known_ys, known_xs,\n    LET(\n        x_vector, TOCOL(x_vector),\n        y_vector, BYROW(\n            x_vector,\n            LAMBDA(x, _INTERPOLATION_LINEAR(x, known_ys, known_xs))\n        ),\n        y_vector\n    )\n);\n\n/*\n---- LINEAR ALGEBRA (LINALG) ----\n*/\n\n// NONE ---> LINALG_ROTATION_MATRIX\nLINALG_ROTATION_MATRIX = LAMBDA(theta_x, theta_y, theta_z, [num_digits],\n    LET(\n        round_number, IF(ISOMITTED(num_digits), 0, num_digits),\n        angle_x, RADIANS(theta_x),\n        angle_y, RADIANS(theta_y),\n        angle_z, RADIANS(theta_z),\n        cos_x, COS(angle_x),\n        sin_x, SIN(angle_x),\n        rotation_x, VSTACK(\n            HSTACK(1, 0, 0),\n            HSTACK(0, cos_x, -sin_x),\n            HSTACK(0, sin_x, cos_x)\n        ),\n        cos_y, COS(angle_y),\n        sin_y, SIN(angle_y),\n        rotation_y, VSTACK(\n            HSTACK(cos_y, 0, sin_y),\n            HSTACK(0, 1, 0),\n            HSTACK(-sin_y, 0, cos_y)\n        ),\n        cos_z, COS(angle_z),\n        sin_z, SIN(angle_z),\n        rotation_z, VSTACK(\n            HSTACK(cos_z, -sin_z, 0),\n            HSTACK(sin_z, cos_z, 0),\n            HSTACK(0, 0, 1)\n        ),\n        rotation_matrix, MMULT(rotation_z, MMULT(rotation_y, rotation_x)),\n        IF(\n            round_number,\n            ROUND(rotation_matrix, round_number),\n            rotation_matrix\n        )\n    )\n);\n\n// LINALG_ROTATION_MATRIX ---> LINALG_ROTATE_POINT\nLINALG_ROTATE_POINT = LAMBDA(\n    point_vector,\n    theta_x,\n    theta_y,\n    theta_z,\n    [active_rotation],\n    [num_digits],\n    LET(\n        active_rotation, IF(\n            ISOMITTED(active_rotation),\n            TRUE,\n            active_rotation\n        ),\n        rotation_matrix, LINALG_ROTATION_MATRIX(\n            theta_x,\n            theta_y,\n            theta_z,\n            num_digits\n        ),\n        point_vector, TOCOL(point_vector),\n        final_rotation, IF(\n            active_rotation,\n            rotation_matrix,\n            TRANSPOSE(rotation_matrix)\n        ),\n        point_rotation, MMULT(final_rotation, point_vector),\n        TOROW(point_rotation)\n    )\n);\n\n// LINALG_ROTATE_POINT ---> _RECURSIVE_ROTATE_POINTS\n// _RECURSIVE_ROTATE_POINTS ---> _RECURSIVE_ROTATE_POINTS\n_RECURSIVE_ROTATE_POINTS = LAMBDA(\n    ntry,\n    data_points,\n    theta_x,\n    theta_y,\n    theta_z,\n    [active_rotation],\n    [num_digits],\n    LET(\n        selected_row, CHOOSEROWS(data_points, ntry),\n        IF(\n            ntry = 1,\n            LINALG_ROTATE_POINT(\n                selected_row,\n                theta_x,\n                theta_y,\n                theta_z,\n                active_rotation,\n                num_digits\n            ),\n            LET(\n                next_try, ntry - 1,\n                result, LINALG_ROTATE_POINT(\n                    selected_row,\n                    theta_x,\n                    theta_y,\n                    theta_z,\n                    active_rotation,\n                    num_digits\n                ),\n                VSTACK(\n                    _RECURSIVE_ROTATE_POINTS(\n                        next_try,\n                        data_points,\n                        theta_x,\n                        theta_y,\n                        theta_z,\n                        active_rotation,\n                        num_digits\n                    ),\n                    result\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_ROTATE_POINTS ---> LINALG_ROTATE_POINT_ARRAY\nLINALG_ROTATE_POINT_ARRAY = LAMBDA(\n    data_points,\n    theta_x,\n    theta_y,\n    theta_z,\n    [active_rotation],\n    [num_digits],\n    _RECURSIVE_ROTATE_POINTS(\n        ROWS(data_points),\n        data_points,\n        theta_x,\n        theta_y,\n        theta_z,\n        active_rotation,\n        num_digits\n    )\n);\n\n/*\n---- GEOMETRY ----\n*/\n\n// NONE ---> GEOMETRY_IS_POINT_IN_POLYGON\nGEOMETRY_IS_POINT_IN_POLYGON = LAMBDA(point_vector, data_polygon,\n    LET(\n        point_vector, TOCOL(point_vector),\n        xp, INDEX(point_vector, 1),\n        yp, INDEX(point_vector, 2),\n        data_1, DROP(data_polygon, -1),\n        data_2, DROP(data_polygon, 1),\n        data_joined, HSTACK(data_1, data_2),\n        _x1, CHOOSECOLS(data_joined, 1),\n        _y1, CHOOSECOLS(data_joined, 2),\n        _x2, CHOOSECOLS(data_joined, 3),\n        _y2, CHOOSECOLS(data_joined, 4),\n        first_condition, (yp < _y1) <> (yp < _y2),\n        second_condition, xp <\n            (_x1 + (((yp - _y1) / (_y2 - _y1)) * (_x2 - _x1))),\n        final_condition, IFERROR(\n            (first_condition * second_condition) = 1,\n            FALSE\n        ),\n        is_inside, MOD(SUM(INT(final_condition)), 2) = 1,\n        is_inside\n    )\n);\n\n// GEOMETRY_IS_POINT_IN_POLYGON ---> GEOMETRY_ARE_POINTS_IN_POLYGON\nGEOMETRY_ARE_POINTS_IN_POLYGON = LAMBDA(data_points, polygon_points,\n    BYROW(\n        data_points,\n        LAMBDA(row, GEOMETRY_IS_POINT_IN_POLYGON(row, polygon_points))\n    )\n);\n\n\n\n\nPenggunaan KembaliMIT LICENSE"
  },
  {
    "objectID": "release/feidlambda-0-3.html",
    "href": "release/feidlambda-0-3.html",
    "title": "feidlambda v0.3.1",
    "section": "",
    "text": "Official GIST feidlambda (v0.3.x)\n\n\n\nhttps://gist.github.com/taruma/92bd33600a3d42dc9aead87558404a12\n\n\nPanduan instalasi feidlambda v0.3.x dapat dilihat di halaman Penggunaan.\nBagi yang sebelumnya menggunakan versi feidlambda v0.2 wajib untuk membaca perubahan penting dan migrasi v0.2 ke v0.3. Tapi, bagi yang baru menggunakan bisa langsung ke bagian fungsi feidlambda v0.3.x.\n\n\n\n\nUpdate Log v0.3.x\nUpdate Log merupakan catatan pembaruan feidlambda. Berikut catatan perubahan/pembaruan secara umum beserta penjelasan perubahan/pembaruan. Untuk perubahan berdasarkan fungsinya, bisa dilihat di bagian Changelog.\n\nUpdate v0.3.1 (2022-01-13)\n\nPada fungsi FILTER_MINMAX_ARRAY() terdapat argumen opsional baru yaitu take_first_only. Jika take_first_only = TRUE, maka hasil filter minimum/maksimum hanya mengambil baris pertamanya saja (jika terdapat minimum/maksimum lebih dari satu baris).\nPada fungsi SWAP_*(), nilai argumen from_index dan to_index menerima index negatif (indeks dari belakang). Bersamaan perubahan tersebut, nilai default to_index menjadi -1 yang artinya secara default (tanpa argumen) fungsi SWAP_*() menukar posisi terdepan dengan terbelakang (baik berdasarkan baris ataupun kolom).\nPerubahan nama argumen pada beberapa fungsi seperti:\n\nFILTER_MINMAX_COLUMN(): col -> column_index, with_lables -> with_label.\nGET_INDEX_2D(): return_order_only -> return_as_order.\nROTATE_*(): n -> num_rotation.\nTEXT_SPLIT_VECTOR(): text_delimiter -> col_delimiter.\n\nFungsi TEXT_SPLIT_VECTOR() menggunakan metode recursive dari fungsi TEXTSPLIT().\nPada fungsi TEXT_SPLIT_VECTOR() terdapat argumen opsional baru yaitu replace_na, yang berfungsi untuk mengubah nilai #NA dari hasil akhir.\nTambahan informasi limitasi pada fungsi TEXT_SPLIT_VECTOR().\n\n\n\n\n\n\n\nFungsi feidlambda v0.3.x\nPada feidlambda v0.3.x, setiap fungsi dikategorikan sesuai kegunaannya. Berikut kategori yang tersedia di feidlambda v0.3.x:\n\nFILTER_*: Melakukan filtering atau subsetting (memilah) dari data.\nGET_*: Mengambil informasi dari data.\nIS_*: Fungsi logical tambahan.\nMAKE_*: Membangkitkan data.\nREPEAT_*: Mengulangi/merepetisi data.\nRESHAPE_*: Mengubah dimensi data.\nROTATE_*: Merubah posisi data dengan diputar.\nSWAP_*: Menukar posisi data.\nTEXT_*: Fungsi tambahan yang berkaitan dengan teks.\n\nDownload excel demonstrasi RELEASE_feidlambda_v0_3_1.xlsx, untuk memudahkan mengeksplorasi fungsi baru di feidlambda v0.3.x.\n\n\n\n\n\n\nCatatan\n\n\n\nGambar yang ditampilkan pada halaman ini merupakan dari versi sebelumnya (feidlambda v0.3.0) dan tidak diperbarui untuk setiap update. Oleh karena itu, disarankan untuk mengeksplorasi langsung dari dokumen yang telah dilampirkan.\n\n\n\n\n\n\n\nKategori FILTER_*\nKategori FILTER_* merupakan kumpulan fungsi yang melakukan filtering atau subsetting (memilah) data berupa vector ataupun array. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 3.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> FILTER_DROP_ROWS\n  NONE --> FILTER_DROP_COLUMNS\n  NONE --> FILTER_FUNC_COLUMN\n  FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\n  FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n  _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n  _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\n\n\n\n\n\nGambar 3.1: Grafik dependencies kategori FILTER_*\n\n\n\n\nFungsi utama kategori FILTER_* yaitu FILTER_DROP_ROWS(), FILTER_DROP_COLUMNS(), dan FILTER_MINMAX_ARRAY().\n\n\nSource Code FILTER_*\n\n// NONE --> FILTER_DROP_ROWS\nFILTER_DROP_ROWS = LAMBDA(array, row_index,\n    LET(\n        row_index, TOCOL(row_index),\n        row_index_clean, FILTER(row_index, NOT(ISBLANK(row_index))),\n        nrows, ROWS(array),\n        row_sequence, SEQUENCE(nrows),\n        selected_row, BYROW(\n            row_sequence,\n            LAMBDA(each_row, OR(each_row = row_index_clean))\n        ),\n        FILTER(array, NOT(selected_row))\n    )\n);\n\n// NONE --> FILTER_DROP_COLUMNS\nFILTER_DROP_COLUMNS = LAMBDA(array, column_index,\n    LET(\n        column_index, TOROW(column_index),\n        column_index_clean, FILTER(\n            column_index,\n            NOT(ISBLANK(column_index))\n        ),\n        ncols, COLUMNS(array),\n        col_sequence, SEQUENCE(1, ncols),\n        selected_col, BYCOL(\n            col_sequence,\n            LAMBDA(each_col, OR(each_col = column_index_clean))\n        ),\n        FILTER(array, NOT(selected_col))\n    )\n);\n\n// NONE --> FILTER_FUNC_COLUMN\nFILTER_FUNC_COLUMN = LAMBDA(\n    array,\n    [column_index],\n    [with_label],\n    [label_col],\n    [function],\n    [label_function],\n    [take_first_only],\n    LET(\n        take_first_only, IF(\n            ISOMITTED(take_first_only),\n            FALSE,\n            take_first_only\n        ),\n        column_index, IF(ISOMITTED(column_index), 1, column_index),\n        label_col, IF(ISOMITTED(label_col), column_index, label_col),\n        with_label, IF(ISOMITTED(with_label), FALSE, with_label),\n        function, IF(ISOMITTED(function), LAMBDA(x, MAX(x)), function),\n        label_function, IF(\n            ISOMITTED(label_function),\n            \"func\",\n            label_function\n        ),\n        selected_vector, CHOOSECOLS(array, column_index),\n        func_value, function(selected_vector),\n        selected_logical, selected_vector = func_value,\n        array_filter, FILTER(array, selected_logical),\n        array_func, IF(\n            take_first_only,\n            TAKE(array_filter, 1),\n            array_filter\n        ),\n        label, MAKEARRAY(\n            ROWS(array_func),\n            1,\n            LAMBDA(x, y, CONCAT(label_col, \"_\", label_function))\n        ),\n        IF(with_label, HSTACK(label, array_func), array_func)\n    )\n);\n\n// FILTER_FUNC_COLUMN --> FILTER_MINMAX_COLUMN\nFILTER_MINMAX_COLUMN = LAMBDA(\n    array,\n    [column_index],\n    [with_label],\n    [label_col],\n    [take_first_only],\n    LET(\n        func_1, LAMBDA(x, MIN(x)),\n        label_func_1, \"min\",\n        func_2, LAMBDA(x, MAX(x)),\n        label_func_2, \"max\",\n        func1_result, FILTER_FUNC_COLUMN(\n            array,\n            column_index,\n            with_label,\n            label_col,\n            func_1,\n            label_func_1,\n            take_first_only\n        ),\n        func2_result, FILTER_FUNC_COLUMN(\n            array,\n            column_index,\n            with_label,\n            label_col,\n            func_2,\n            label_func_2,\n            take_first_only\n        ),\n        VSTACK(func1_result, func2_result)\n    )\n);\n\n// FILTER_MINMAX_COLUMN --> _RECURSIVE_FILTER_MINMAX\n// _RECURSIVE_FILTER_MINMAX --> _RECURSIVE_FILTER_MINMAX\n_RECURSIVE_FILTER_MINMAX = LAMBDA(\n    array,\n    ntry,\n    [ignore_first_column],\n    [with_label],\n    [label_vector],\n    [take_first_only],\n    LET(\n        ignore_first_column, IF(\n            ISOMITTED(ignore_first_column),\n            FALSE,\n            ignore_first_column\n        ),\n        stop_col, IF(ignore_first_column, 2, 1),\n        label_vector, IF(\n            ISOMITTED(label_vector),\n            SEQUENCE(1, COLUMNS(array)),\n            label_vector\n        ),\n        new_label, IF(\n            stop_col = 2,\n            HSTACK({\" \"}, label_vector),\n            label_vector\n        ),\n        label_col, CHOOSECOLS(new_label, ntry),\n        IF(\n            ntry = stop_col,\n            FILTER_MINMAX_COLUMN(\n                array,\n                ntry,\n                with_label,\n                label_col,\n                take_first_only\n            ),\n            LET(\n                results, FILTER_MINMAX_COLUMN(\n                    array,\n                    ntry,\n                    with_label,\n                    label_col,\n                    take_first_only\n                ),\n                next_try, ntry - 1,\n                VSTACK(\n                    _RECURSIVE_FILTER_MINMAX(\n                        array,\n                        next_try,\n                        ignore_first_column,\n                        with_label,\n                        label_vector,\n                        take_first_only\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_FILTER_MINMAX --> FILTER_MINMAX_ARRAY\nFILTER_MINMAX_ARRAY = LAMBDA(\n    array,\n    [ignore_first_column],\n    [with_label],\n    [label_vector],\n    [take_first_only],\n    _RECURSIVE_FILTER_MINMAX(\n        array,\n        COLUMNS(array),\n        ignore_first_column,\n        with_label,\n        label_vector,\n        take_first_only\n    )\n);\n\n\nFILTER_DROP_ROWS()\nFungsi FILTER_DROP_ROWS(array, row_index) digunakan untuk menghapus baris dari data.\n\n\n\nSyntax\n\nFILTER_DROP_ROWS(array, row_index)\n\nOutput\n\narray\n\n\n\n\n\narray := [array | vector]\n\nData berupa array atau vector yang memiliki baris lebih dari satu.\n\nrow_index := [integer number | integer vector]\n\nIndeks baris yang ingin dihapus.\n\n\n\n\n\n\n\nGambar 3.2: Demonstrasi FILTER_DROP_ROWS()\n\n\n\n\n\nFILTER_DROP_COLUMNS()\nFungsi FILTER_DROP_COLUMNS(array, column_index) digunakan untuk menghapus kolom dari data.\n\n\n\nSyntax\n\nFILTER_DROP_COLUMNS(array, column_index)\n\nOutput\n\narray\n\n\n\n\n\narray := [array | vector]\n\nData berupa array atau vector yang memiliki kolom lebih dari satu.\n\ncolumn_index := [integer number | integer vector]\n\nIndeks kolom yang ingin dihapus.\n\n\n\n\n\n\n\nGambar 3.3: Demonstrasi FILTER_DROP_COLUMNS()\n\n\n\n\n\nFILTER_MINMAX_ARRAY()\nFungsi FILTER_MINMAX_ARRAY(array, [ignore_first_column], [with_label], [label_vector], [take_first_only]) digunakan untuk melakukan filtering (memilah) data berdasarkan nilai minimum dan maksimum setiap kolomnya dan mengeluarkan hasil dalam berupa dynamic array.\n\n\n\nSyntax\n\nFILTER_MINMAX_ARRAY(array, [ignore_first_column], [with_label], [label_vector], [take_first_only])\n\nOutput\n\narray\n\n\n\n\n\narray := [array | numeric array]\n\nData berupa array dengan ketentuan array berisikan angka kecuali kolom pertama jika menggunakan opsi ignore_first_column.\n\n[ignore_first_column] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka kolom pertama dari array akan diabaikan dan tidak dilakukan filtering nilai minimum/maksimum.\n\n[with_label] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka kolom pertama dari output adalah label informasi minimum dan maksimum seperti 1_min, 1_max, atau no.column_min dan no.column_max. Untuk menggunakan label sendiri, masukin vector label di argumen label_vector.\n\n[label_vector] := NONE :: [vector]\n\nNilai default yaitu NONE. Jika NONE, maka label setiap baris akan dinomori berdasarkan kolomnya (1_min, 1_max). Jika ingin menggunakan label dari nama kolom, jumlah elemen vector harus sama dengan jumlah kolom dari array. Untuk menggunakan label nilai with_label harus TRUE.\n\n[take_first_only] := FALSE :: [TRUE | FALSE]\n\n(New in v0.3.1). Nilai default yaitu FALSE. Jika TRUE, maka hanya baris pertama yang diambil dari hasil pencarian nilai minimum/maksimum.\n\n\n\n\n\n\n\n\n\n\n\n\n\nGambar 3.4: Demonstrasi FILTER_MINMAX_ARRAY()\n\n\n\n\n\n\n\n\nKategori GET_*\nKategori GET_* merupakan kumpulan fungsi yang digunakan untuk mengambil informasi dari suatu data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 4.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> GET_INDEX_2D\n\n\n\n\n\nGambar 4.1: Grafik dependencies kategori GET_*\n\n\n\n\nDari Gambar 4.1, diketahui untuk versi v0.3 hanya tersedia fungsi GET_INDEX_2D().\n\n\nSource Code GET_*\n\n// NONE --> GET_INDEX_2D\nGET_INDEX_2D = LAMBDA(lookup_value, array, [return_as_order],\n    LET(\n        return_as_order, IF(\n            ISOMITTED(return_as_order),\n            FALSE,\n            return_as_order\n        ),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        size, nrows * ncols,\n        array_flatten, TOCOL(array, , TRUE),\n        index_sequence, SEQUENCE(nrows, ncols, 1, 1),\n        rows_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, x)),\n        columns_sequence, MAKEARRAY(nrows, ncols, LAMBDA(x, y, y)),\n        rows_flatten, TOCOL(rows_sequence, , TRUE),\n        columns_flatten, TOCOL(columns_sequence, , TRUE),\n        index_flatten, TOCOL(index_sequence, , TRUE),\n        lookup_table, HSTACK(index_flatten, rows_flatten, columns_flatten),\n        lookup_result, FILTER(lookup_table, array_flatten = lookup_value),\n        IF(return_as_order, CHOOSECOLS(lookup_result, 1), lookup_result)\n    )\n);\n\n// _RECURSIVE_LOOKUP --> _RECURSIVE_LOOKUP\n_RECURSIVE_LOOKUP = LAMBDA(\n    ntry,\n    lookup_value,\n    lookup_vector,\n    return_array,\n    [if_not_found],\n    [match_mode],\n    [search_mode],\n    LET(\n        lookup_value, TOCOL(lookup_value),\n        LET(\n            selected_value, VALUE(\n                ARRAYTOTEXT(CHOOSEROWS(lookup_value, ntry))\n            ),\n            result, XLOOKUP(\n                selected_value,\n                lookup_vector,\n                return_array,\n                if_not_found,\n                match_mode,\n                search_mode\n            ),\n            IF(\n                ntry = 1,\n                result,\n                VSTACK(\n                    _RECURSIVE_LOOKUP(\n                        ntry - 1,\n                        lookup_value,\n                        lookup_vector,\n                        return_array,\n                        if_not_found,\n                        match_mode,\n                        search_mode\n                    ),\n                    result\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_LOOKUP --> GET_XLOOKUP\nGET_XLOOKUP = LAMBDA(\n    lookup_value,\n    lookup_vector,\n    return_array,\n    [if_not_found],\n    [match_mode],\n    [search_mode],\n    LET(\n        lookup_value, TOCOL(lookup_value),\n        ntry, ROWS(lookup_value),\n        _RECURSIVE_LOOKUP(\n            ntry,\n            lookup_value,\n            lookup_vector,\n            return_array,\n            if_not_found,\n            match_mode,\n            search_mode\n        )\n    )\n);\n\n\nGET_INDEX_2D()\nFungsi GET_INDEX_2D(lookup_value, array, [return_as_order]) dapat digunakan untuk mengambil informasi urutan nilai yang dicari ataupun posisi baris/kolom dari array.\n\n\n\nSyntax\n\nGET_INDEX_2D(lookup_value, array, [return_as_order])\n\nOutput\n\narray ([order, row index, column index]) atau number vector (order)\n\n\n\n\n\nlookup_value := [scalar]\n\nNilai yang dicari dalam array. Nilai lookup_value adalah nilai tunggal berupa scalar.\n\narray := [array]\n\nData berupa array.\n\n[return_as_order] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, hasil fungsi memberikan urutan angka nilai yang dicari. Urutan dimulai dari horizontal kiri teratas sampai kanan terbawah. Jika FALSE, maka output terdiri dari nomor urut, indeks kolom, dan indeks baris.\n\n\n\n\n\n\n\nGambar 4.2: Demonstrasi GET_INDEX_2D()\n\n\n\n\n\n\n\n\n\nKategori IS_*\nKategori IS_* merupakan kumpulan fungsi yang dapat digunakan untuk melakukan fungsi logical di data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 5.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> IS_ALL_IN_LOOKUP_VECTOR\n  NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\n  IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\n  NONE --> IS_ROWS_LOGICAL\n  NONE --> IS_COLUMNS_LOGICAL\n\n\n\n\n\nGambar 5.1: Grafik dependencies kategori IS_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code IS_*\n\n// NONE --> IS_ALL_IN_LOOKUP_VECTOR\nIS_ALL_IN_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOCOL(lookup_vector),\n        MAP(\n            array,\n            LAMBDA(element,\n                OR(BYROW(lookup_vector, LAMBDA(lookup, element = lookup)))\n            )\n        )\n    )\n);\n\n// NONE --> IS_COLS_EQUAL_LOOKUP_VECTOR\nIS_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array,\n    LET(\n        lookup_vector, TOROW(lookup_vector),\n        ncols_vector, COLUMNS(lookup_vector),\n        ncols_array, COLUMNS(array),\n        nrows_array, ROWS(array),\n        IF(\n            ncols_array = ncols_vector,\n            LET(\n                repeat_array, CHOOSEROWS(\n                    lookup_vector,\n                    SEQUENCE(nrows_array, , 1, 0)\n                ),\n                MAP(array, repeat_array, LAMBDA(x, y, x = y))\n            ),\n            \"N/A\"\n        )\n    )\n);\n\n// IS_COLS_EQUAL_LOOKUP_VECTOR --> IS_ALL_COLS_EQUAL_LOOKUP_VECTOR\nIS_ALL_COLS_EQUAL_VECTOR = LAMBDA(lookup_vector, array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        array_boolean, IS_COLS_EQUAL_VECTOR(lookup_vector, array),\n        BYROW(array_boolean, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_ROWS_LOGICAL\nIS_ROWS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        BYROW(logical_array, LAMBDA(each_row, logical_function(each_row)))\n    )\n);\n\n// NONE --> IS_COLUMNS_LOGICAL\nIS_COLUMNS_LOGICAL = LAMBDA(logical_array, [logical_function],\n    LET(\n        logical_function, IF(\n            ISOMITTED(logical_function),\n            LAMBDA(x, OR(x)),\n            logical_function\n        ),\n        BYCOL(logical_array, LAMBDA(each_col, logical_function(each_col)))\n    )\n);\n\n\nIS_ALL_IN_VECTOR()\nFungsi IS_ALL_IN_VECTOR(lookup_vector, array) digunakan untuk memeriksa apakah setiap elemen di array termasuk dari lookup_vector.\n\n\n\nSyntax\n\nIS_ALL_IN_VECTOR(lookup_vector, array)\n\nOutput\n\nlogical array\n\n\n\n\n\nlookup_vector := [scalar | vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan.\n\narray := [array | vector]\n\nData berupa array atau vector.\n\n\n\n\n\n\n\nGambar 5.2: Demonstrasi IS_ALL_IN_VECTOR()\n\n\n\n\n\nIS_COLS_EQUAL_VECTOR()\nFungsi IS_COLS_EQUAL_VECTOR(lookup_vector, array) digunakan untuk memeriksa apakah setiap kolom di array termasuk dari setiap elemen di lookup_vector.\n\n\n\nSyntax\n\nIS_COLS_EQUAL_VECTOR(lookup_vector, array)\n\nOutput\n\nlogical array\n\n\n\n\n\nlookup_vector := [vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan. Jumlah elemen lookup_vector harus sama dengan jumlah kolom array.\n\narray := [array | vector]\n\nData berupa array .\n\n\n\n\n\n\n\nGambar 5.3: Demonstrasi IS_COLS_EQUAL_VECTOR()\n\n\n\n\n\nIS_ALL_COLS_EQUAL_VECTOR()\nFungsi IS_ALL_COLS_EQUAL_VECTOR(lookup_vector, array, [logical_function]) digunakan untuk memeriksa apakah setiap kolom di array termasuk dari setiap elemen di lookup_vector, dan diperiksa apakah setiap barisnya sesuai dengan logical_function. Fungsi ini menggunakan fungsi IS_COLS_EQUAL_VECTOR().\n\n\n\nSyntax\n\nIS_ALL_COLS_EQUAL_VECTOR(lookup_vector, array, [logical_function])\n\nOutput\n\ncolumn logical vector\n\n\n\n\n\nlookup_vector := [scalar | vector]\n\nVector yang terdiri dari nilai yang ingin dicocokkan. Jumlah elemen lookup_vector harus sama dengan jumlah kolom array.\n\narray := [array | vector]\n\nData berupa array .\n\nlogical_function := OR() :: [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap barisnya.\n\n\n\n\n\n\n\nGambar 5.4: Demonstrasi IS_ALL_COLS_EQUAL_VECTOR()\n\n\n\n\n\nIS_ROWS_LOGICAL()\nFungsi IS_ROWS_LOGICAL(logical_array, [logical_function]) mengaggregasi setiap baris dari logical_array menggunakan fungsi logical_function.\n\n\n\nSyntax\n\nIS_ROWS_LOGICAL(logical_array, [logical_function])\n\nOutput\n\ncolumn vector\n\n\n\n\n\nlogical_array := [logical array]\n\nData berupa logical array .\n\n[logical_function] := OR() [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap barisnya.\n\n\n\n\n\nIS_COLUMNS_LOGICAL()\nFungsi IS_COLUMNS_LOGICAL(logical_array, [logical_function]) mengaggregasi setiap kolom dari logical_array menggunakan fungsi logical_function.\n\n\n\nSyntax\n\nIS_COLUMNS_LOGICAL(logical_array, [logical_function])\n\nOutput\n\nrow vector\n\n\n\n\n\nlogical_array := [logical array]\n\nData berupa logical array .\n\n[logical_function] := OR() [LAMBDA scalar function]\n\nNilai default adalah fungsi lambda OR(). Fungsi logical yang digunakan untuk mengaggregasi setiap kolomnya.\n\n\n\n\n\n\n\nGambar 5.5: Demonstrasi IS_ROWS_LOGICAL() dan IS_COLUMNS_LOGICAL()\n\n\n\n\n\n\n\n\n\nKategori MAKE_*\nKategori MAKE_* merupakan kumpulan fungsi yang membangkitkan (generate) data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 6.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n  _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\n\n\n\n\n\nGambar 6.1: Grafik dependencies kategori MAKE_*\n\n\n\n\nFungsi utama pada kategori ini adalah MAKE_SEQUENCE_FROM_VECTOR().\n\n\nSource Code MAKE_*\n\n// _RECURSIVE_MAKE_SEQUENCE --> _RECURSIVE_MAKE_SEQUENCE\n_RECURSIVE_MAKE_SEQUENCE = LAMBDA(\n    start_vector,\n    end_vector,\n    ntry,\n    [stack_horizontally],\n    LET(\n        seq_start, INDEX(start_vector, ntry),\n        seq_end, INDEX(end_vector, ntry),\n        stack_horizontally, IF(\n            ISOMITTED(stack_horizontally),\n            FALSE,\n            stack_horizontally\n        ),\n        IF(\n            ntry = 1,\n            SEQUENCE(seq_end - seq_start + 1, , seq_start),\n            LET(\n                next_try, ntry - 1,\n                results, SEQUENCE(seq_end - seq_start + 1, , seq_start),\n                IF(\n                    stack_horizontally,\n                    HSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    ),\n                    VSTACK(\n                        _RECURSIVE_MAKE_SEQUENCE(\n                            start_vector,\n                            end_vector,\n                            next_try,\n                            stack_horizontally\n                        ),\n                        results\n                    )\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_MAKE_SEQUENCE --> MAKE_SEQUENCE_FROM_VECTOR\nMAKE_SEQUENCE_FROM_VECTOR = LAMBDA(\n    start_vector,\n    end_vector,\n    [stack_horizontally],\n    _RECURSIVE_MAKE_SEQUENCE(\n        start_vector,\n        end_vector,\n        ROWS(start_vector),\n        stack_horizontally\n    )\n);\n\n\nMAKE_SEQUENCE_FROM_VECTOR()\nFungsi MAKE_SEQUENCE_FROM_VECTOR(start_vector, end_vector, [stack_horizontally]) digunakan untuk mebangkitkan sequence dari setiap baris/elemen di start_vector dan end_vector.\n\n\n\nSyntax\n\nMAKE_SEQUENCE_FROM_VECTOR(start_vector, end_vector, [stack_horizontally])\n\nOutput\n\ncolumn vector atau array\n\n\n\n\n\nstart_vector := [integer vector]\n\nVector yang terdiri dari bilangan bulat memulai sequence.\n\nend_vector := [integer vector]\n\nVector yang terdiri dari bilangan bulat akhir sequence.\n\n[stack_horizontally] := FALSE :: [TRUE | FALSE]\n\nNilai default yaitu FALSE. Jika TRUE, maka setiap sequence yang dibangkitkan akan disusun horizontal.\n\n\n\n\n\n\n\nGambar 6.2: Demonstrasi MAKE_SEQUENCE_FROM_VECTOR()\n\n\n\n\n\n\n\n\n\nKategori REPEAT_*\nKategori REPEAT_* merupakan kumpulan fungsi yang digunakan untuk melakukan pengulangan array ataupun vector dan menghasilkannya dalam bentuk dynamic array. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 7.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\n  REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\n  REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\n\n\n\n\n\nGambar 7.1: Grafik dependencies kategori REPEAT_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code REPEAT_*\n\n// REPEAT_ARRAY_BY_ROW & REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY\nREPEAT_ARRAY = LAMBDA(array, [num_repeat], [by_row],\n    LET(\n        by_row, IF(ISOMITTED(by_row), TRUE, by_row),\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            by_row,\n            REPEAT_ARRAY_BY_ROW(array, num_repeat),\n            REPEAT_ARRAY_BY_COLUMN(array, num_repeat)\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_ROW --> REPEAT_ARRAY_BY_ROW\nREPEAT_ARRAY_BY_ROW = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                VSTACK(REPEAT_ARRAY_BY_ROW(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n// REPEAT_ARRAY_BY_COLUMN --> REPEAT_ARRAY_BY_COLUMN\nREPEAT_ARRAY_BY_COLUMN = LAMBDA(array, [num_repeat],\n    LET(\n        num_repeat, IF(ISOMITTED(num_repeat), 2, num_repeat),\n        IF(\n            num_repeat = 1,\n            array,\n            LET(\n                next_repeat, num_repeat - 1,\n                HSTACK(REPEAT_ARRAY_BY_COLUMN(array, next_repeat), array)\n            )\n        )\n    )\n);\n\n\nREPEAT_ARRAY_BY_ROW()\nFungsi REPEAT_ARRAY_BY_ROW(array, [num_repeat]) digunakan untuk mengulangi array sepanjang baris (ke bawah).\n\n\n\nSyntax\n\nREPEAT_ARRAY_BY_ROW(array, [num_repeat])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n\n\n\n\n\n\nGambar 7.2: Demonstrasi REPEAT_ARRAY_BY_ROW()\n\n\n\n\n\nREPEAT_ARRAY_BY_COLUMN()\nFungsi REPEAT_ARRAY_BY_COLUMN(array, [num_repeat]) digunakan untuk mengulangi array sepanjang kolom (ke kanan).\n\n\n\nSyntax\n\nREPEAT_ARRAY_BY_COLUMN(array, [num_repeat])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n\n\n\n\n\n\nGambar 7.3: Demonstrasi REPEAT_ARRAY_BY_COLUMN()\n\n\n\n\n\nREPEAT_ARRAY()\nFungsi REPEAT_ARRAY(array, [num_repeat], [by_row]) digunakan untuk mengulangi array sepanjang baris/kolom (ke bawah/ke kanan).\n\n\n\nSyntax\n\nREPEAT_ARRAY(array, [num_repeat], [by_row])\n\nOutput\n\narray\n\n\n\n\n\narray := [scalar | vector | array]\n\nData dapat berupa scalar, vector, ataupun array.\n\n[num_repeat] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pengulangannya.\n\n[by_row] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka pengulangan akan sepanjang baris (ke bawah), dan berlaku sebaliknya juga.\n\n\n\n\n\n\n\nGambar 7.4: Demonstrasi REPEAT_ARRAY()\n\n\n\n\n\n\n\n\n\nKategori RESHAPE_*\nKategori RESHAPE_* merupakan kumpulan fungsi yang dapat digunakan untuk melakukan fungsi logical di data. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 8.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> RESHAPE_BY_COLUMNS\n\n\n\n\n\nGambar 8.1: Grafik dependencies kategori RESHAPE_*\n\n\n\n\nFungsi utama yang tersedia saat ini hanya RESHAPE_BY_COLUMNS().\n\n\nSource Code RESHAPE_*\n\n// NONE --> RESHAPE_BY_COLUMNS\nRESHAPE_BY_COLUMNS = LAMBDA(array, [num_split],\n    LET(\n        num_split, IF(ISOMITTED(num_split), 2, num_split),\n        ncols, COLUMNS(array),\n        nrows, ROWS(array),\n        IF(\n            MOD(ncols, num_split) = 0,\n            LET(\n                divider, ncols / num_split,\n                divider_sequence, CHOOSEROWS(\n                    SEQUENCE(1, divider),\n                    SEQUENCE(num_split, , 1, 0)\n                ),\n                divider_flatten, TOCOL(divider_sequence, , TRUE),\n                divider_repeat, CHOOSEROWS(\n                    TOROW(divider_flatten),\n                    SEQUENCE(nrows, , 1, 0)\n                ),\n                divider_repeat_col, TOCOL(divider_repeat),\n                array_flatten, TOCOL(array),\n                array_sorted, SORTBY(array_flatten, divider_repeat_col),\n                WRAPROWS(array_sorted, num_split)\n            ),\n            NA()\n        )\n    )\n);\n\n\nRESHAPE_BY_COLUMNS()\nFungsi RESHAPE_BY_COLUMNS(array, [num_split]) digunakan untuk mengubah dimensi (transformasi) array berdasarkan jumlah pembagi kolomnya. Jika tidak jumlah kolom tidak habis dibagi oleh num_split akan mengeluarkan hasil #N/A.\n\n\n\nSyntax\n\nRESHAPE_BY_COLUMNS(array, [num_split])\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array atau vector.\n\n[num_split] := 2 :: [integer]\n\nNilai default yaitu 2. Jumlah pembagi kolom. Jumlah kolom array harus habis dibagi (MOD()) dengan num_split.\n\n\n\n\n\n\n\nGambar 8.2: Demonstrasi RESHAPE_BY_COLUMNS()\n\n\n\n\n\n\n\n\n\nKategori ROTATE_*\nKategori ROTATE_* merupakan kumpulan fungsi yang digunakan untuk menggeser atau memutar array ataupun vector. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 9.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> ROTATE_VECTOR\n  ROTATE_VECTOR --> ROTATE_ARRAY\n\n\n\n\n\nGambar 9.1: Grafik dependencies kategori ROTATE_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code ROTATE_*\n\n// NONE --> ROTATE_VECTOR\nROTATE_VECTOR = LAMBDA(vector, num_rotation, [as_column_vector],\n    LET(\n        vector, TOCOL(vector),\n        rotated_array, IFS(\n            OR(\n                num_rotation = 0,\n                num_rotation >= ROWS(vector),\n                num_rotation <= -ROWS(vector)\n            ),\n            vector,\n            num_rotation > 0,\n            VSTACK(DROP(vector, num_rotation), TAKE(vector, num_rotation)),\n            num_rotation < 0,\n            VSTACK(TAKE(vector, num_rotation), DROP(vector, num_rotation))\n        ),\n        as_column_vector, IF(ISOMITTED(as_column_vector), FALSE, TRUE),\n        IF(as_column_vector, TOROW(rotated_array), TOCOL(rotated_array))\n    )\n);\n\n// ROTATE_VECTOR --> ROTATE_ARRAY\nROTATE_ARRAY = LAMBDA(array, num_rotation, [rotate_columns],\n    LET(\n        rotate_columns, IF(ISOMITTED(rotate_columns), TRUE, FALSE),\n        nrows, ROWS(array),\n        ncols, COLUMNS(array),\n        seqrows, SEQUENCE(nrows),\n        seqcols, SEQUENCE(1, ncols),\n        results, IF(\n            rotate_columns,\n            CHOOSECOLS(array, ROTATE_VECTOR(seqcols, num_rotation, TRUE)),\n            CHOOSEROWS(array, ROTATE_VECTOR(seqrows, num_rotation, FALSE))\n        ),\n        results\n    )\n);\n\n\nROTATE_VECTOR()\nFungsi ROTATE_VECTOR(vector, num_rotation, [as_column_vector]) digunakan untuk menggeser/memutar elemen yang ada di vector sebanyak num_rotation.\n\n\n\nSyntax\n\nROTATE_VECTOR(vector, num_rotation, [as_column_vector])\n\nOutput\n\nvector\n\n\n\n\n\nvector := [vector]\n\nData berupa vector (column vector atau row vector).\n\nnum_rotation := [integer]\n\nJumlah berapa kali vector diputar/digeser. Nilai negatif untuk digeser berlawanan arah.\n\n[as_column_vector] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka output berupa column vector.\n\n\n\n\n\n\n\nGambar 9.2: Demonstrasi ROTATE_VECTOR()\n\n\n\n\n\nROTATE_ARRAY()\nFungsi ROTATE_ARRAY(array, num_rotation, [rotate_columns]) digunakan untuk menggeser/memutar elemen yang ada di array sebanyak num_rotation berdasarkan baris atau kolom.\n\n\n\nSyntax\n\nROTATE_ARRAY(array, num_rotation, [rotate_columns])\n\nOutput\n\narray\n\n\n\n\n\narray := [array]\n\nData berupa array.\n\nnum_rotation := [scalar | vector]\n\nJumlah berapa kali vector diputar/digeser. Nilai negatif untuk digeser berlawanan arah.\n\n[rotate_columns] := TRUE :: [TRUE | FALSE]\n\nNilai default yaitu TRUE. Jika TRUE, maka array diputar berdasarkan kolom. Jika FALSE, maka array diputar berdasarkan baris.\n\n\n\n\n\n\n\nGambar 9.3: Demonstrasi ROTATE_ARRAY()\n\n\n\n\n\n\n\n\n\nKategori SWAP_*\nKategori SWAP_* merupakan kumpulan fungsi yang digunakan untuk mengganti atau mengubah posisi elemen atau vector. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 10.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  NONE --> SWAP_COLUMNS\n  NONE --> SWAP_ROWS\n\n\n\n\n\nGambar 10.1: Grafik dependencies kategori SWAP_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code SWAP_*\n\n// NONE --> SWAP_COLUMNS\nSWAP_COLUMNS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        ncols, COLUMNS(array),\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), -1, to_index),\n        from_value, IF(from_index < 0, from_index + ncols + 1, from_index),\n        to_value, IF(to_index < 0, to_index + ncols + 1, to_index),\n        column_sequence, SEQUENCE(1, COLUMNS(array)),\n        from_logical, column_sequence = from_value,\n        to_logical, column_sequence = to_value,\n        replace_from, IF(from_logical, to_value, column_sequence),\n        replace_to, IF(to_logical, from_value, replace_from),\n        CHOOSECOLS(array, replace_to)\n    )\n);\n\n// NONE --> SWAP_ROWS\nSWAP_ROWS = LAMBDA(array, [from_index], [to_index],\n    LET(\n        nrows, ROWS(array),\n        from_index, IF(ISOMITTED(from_index), 1, from_index),\n        to_index, IF(ISOMITTED(to_index), -1, to_index),\n        from_value, IF(from_index < 0, from_index + nrows + 1, from_index),\n        to_value, IF(to_index < 0, to_index + nrows + 1, to_index),\n        row_sequence, SEQUENCE(ROWS(array)),\n        from_logical, row_sequence = from_value,\n        to_logical, row_sequence = to_value,\n        replace_from, IF(from_logical, to_value, row_sequence),\n        replace_to, IF(to_logical, from_value, replace_from),\n        CHOOSEROWS(array, replace_to)\n    )\n);\n\n\nSWAP_COLUMNS()\nFungsi SWAP_COLUMNS(array, [from_index], [to_index]) digunakan untuk menukar posisi kolom ke-from_index dengan kolom ke-to_index.\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [row vector | array]\n\nData dapat berupa array atau row vector.\n\n[from_index] := 1 :: [integer]\n\n(Change in v0.3.1). Nilai default yaitu 1. Posisi index kolom yang ingin dipindahkan. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n[to_index] := -1 :: [integer]\n\n(Change in v0.3.1). Nilai default yaitu -1. Posisi index tujuan kolom. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n\n\n\n\nSWAP_ROWS()\nFungsi SWAP_ROWS(array, [from_index], [to_index]) digunakan untuk menukar posisi baris ke-from_index dengan baris ke-to_index.\n\n\n\nSyntax\n\nSWAP_COLUMNS(array, [from_index], [to_index])\n\nOutput\n\nvector atau array\n\n\n\n\n\narray := [column vector | array]\n\nData dapat berupa array atau column vector.\n\n[from_index] := 1 :: [integer]\n\n(Change in v0.3.1). Nilai default yaitu 1. Posisi index baris yang ingin dipindahkan. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n[to_index] := -1 :: [integer]\n\n(Change in v0.3.1). Nilai default yaitu -1. Posisi index tujuan baris. Jika menggunakan indeks negatif, maka posisi diambil dari belakang.\n\n\n\n\n\n\n\nGambar 10.2: Demonstrasi SWAP_COLUMNS() dan SWAP_ROWS()\n\n\n\n\n\n\n\n\n\nKategori TEXT_*\nKategori TEXT_* merupakan kumpulan fungsi yang digunakan untuk memproses data teks. Hubungan antar fungsi di kategori ini bisa dilihat di Gambar 11.1.\n\n\n\n\n\n%%{ init: { 'theme': 'forest' } }%%\n\nflowchart LR\n  _RECURSIVE_TEXT_SPLIT --> _RECURSIVE_TEXT_SPLIT\n  _RECURSIVE_TEXT_SPLIT --> TEXT_SPLIT_VECTOR\n\n\n\n\n\nGambar 11.1: Grafik dependencies kategori TEXT_*\n\n\n\n\nSeluruh fungsi yang tersedia di kategori ini akan dijelaskan.\n\n\nSource Code TEXT_*\n\n// _RECURSIVE_TEXT_SPLIT --> _RECURSIVE_TEXT_SPLIT\n_RECURSIVE_TEXT_SPLIT = LAMBDA(\n    text_vector,\n    ntry,\n    col_delimiter,\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    LET(\n        text_vector, TOCOL(text_vector),\n        selected_row, ARRAYTOTEXT(INDEX(text_vector, ntry)),\n        IF(\n            ntry = 1,\n            TEXTSPLIT(\n                selected_row,\n                col_delimiter,\n                row_delimiter,\n                ignore_empty,\n                match_mode,\n                pad_with\n            ),\n            LET(\n                next_try, ntry - 1,\n                results, TEXTSPLIT(\n                    selected_row,\n                    col_delimiter,\n                    row_delimiter,\n                    ignore_empty,\n                    match_mode,\n                    pad_with\n                ),\n                VSTACK(\n                    _RECURSIVE_TEXT_SPLIT(\n                        text_vector,\n                        next_try,\n                        col_delimiter,\n                        row_delimiter,\n                        ignore_empty,\n                        match_mode,\n                        pad_with\n                    ),\n                    results\n                )\n            )\n        )\n    )\n);\n\n// _RECURSIVE_TEXT_SPLIT --> TEXT_SPLIT_VECTOR\nTEXT_SPLIT_VECTOR = LAMBDA(\n    text_vector,\n    [col_delimiter],\n    [row_delimiter],\n    [ignore_empty],\n    [match_mode],\n    [pad_with],\n    [replace_na],\n    LET(\n        nrows, ROWS(text_vector),\n        col_delimiter, IF(ISOMITTED(col_delimiter), \" \", col_delimiter),\n        replace_na, IF(ISOMITTED(replace_na), NA(), replace_na),\n        pad_with, IF(ISOMITTED(pad_with), \"\", pad_with),\n        result, _RECURSIVE_TEXT_SPLIT(\n            text_vector,\n            nrows,\n            col_delimiter,\n            row_delimiter,\n            ignore_empty,\n            match_mode,\n            pad_with\n        ),\n        IFERROR(result, replace_na)\n    )\n);\n\n\nTEXT_SPLIT_VECTOR()\nFungsi TEXT_SPLIT_VECTOR(text_vector, [col_delimiter], [row_delimiter], [ignore_empty], [match_mode], [pad_with], [replace_na]) merupakan fungsi pengembangan lanjutan dari TEXTSPLIT() yang mampu menerima input data berupa vector dan menghasilkan dalam bentuk dynamic array.\n\n\n\nSyntax\n\nTEXT_SPLIT_VECTOR(text_vector, [col_delimiter], [row_delimiter], [ignore_empty], [match_mode], [pad_with], [replace_na])\n\nOutput\n\narray\n\n\n\n\n\ntext_vector := [text vector]\n\nData harus berupa text column vector.\n\n[col_delimiter] := \" \" :: [text]\n\nNilai default yaitu \" \" (spasi). Teks pemisah untuk setiap kolomnya.\n\n[row_delimiter] := \"\" :: [text]\n\n(Change in v0.3.1). Nilai default yaitu \"\" (tidak ada). Teks pemisah untuk setiap barisnya.\n\n[ignore_empty] := FALSE :: [TRUE | FALSE]\n\nTentukan TRUE untuk mengabaikan pemisah berurutan. Default ke FALSE, yang membuat sel kosong. Opsional.\n\n[match_mode] := 0 :: [0 | 1]\n\nTentukan 1 untuk melakukan kecocokan yang tidak peka huruf besar kecil. Default ke 0, yang melakukan kecocokan peka huruf besar kecil. Opsional.\n\n[pad_with] := #N/A :: [text | number]\n\nNilai untuk mengalihkan hasil. Defaultnya adalah #N/A.\n\n[replace_na] := #N/A :: [text | number]\n\n(New in v0.3.1). Nilai untuk menggantikan nilai #N/A dari hasil akhir. Defaultnya adalah #N/A. Nilai #N/A yang ada dikarenakan proses VSTACK() yang memiliki dimensi hasil TEXTSPLIT() yang berbeda-beda.\n\n\n\nDeskripsi ignore_empty, match_mode, dan pad_with diambil dari halaman Fungsi TEXTSPLIT.\n\nLimitasi TEXT_SPLIT_VECTOR()\n\nHindari menggunakan TEXT_SPLIT_VECTOR() dengan jumlah baris yang banyak ataupun dimensi output yang besar. Pastikan hasil output fungsi memiliki dimensi yang kecil seperti jumlah kolom \\(\\le 10\\) dan jumlah baris \\(\\le 1,000\\).\nUkuran text_vector masih bisa lebih besar dari batasan diatas, akan tetapi disarankan untuk penggunaan TEXT_SPLIT_VECTOR() selalu bertahap, yaitu dari jumlah baris yang sedikit sampai jumlah baris optimal yang tidak menampilkan error atau crash.\nJika melebihi kemampuan, akan menghasilkan nilai error berupa #NUM / #CALC.\n\n\n\n\n\nGambar 11.2: Demonstrasi TEXT_SPLIT_VECTOR (outdated)\n\n\n\n\n\n\nFungsi feidlambda v0.3 memiliki \\(9\\) kategori dengan total \\(23\\) fungsi utama dan pendukung. Dengan perombakan struktur dan penamaan dari v0.2 ke v0.3, harapannya v0.3 sudah memiliki struktur dan penamaan yang konsisten sehingga untuk memproduksi fungsi ataupun fitur barunya lebih cepat di versi-versi berikutnya.\nJika ada ide untuk pengembangan feidlambda atau fungsi baru bisa langsung membuat isu di github. Dan jika bertemu masalah saat penggunaan feidlambda v0.3, bisa juga membuat isu di github.\n\n\n\n\n\n\n\nChangelog\n\n2022-01-13 (v0.3.1)\n\nPerubahan fungsi utama:\n\nPerubahan FILTER_MINMAX_ARRAY():\n\nMenambah optional argumen take_first_only.\nMengganti nama argumen: with_labels -> with_label.\nPenyesuaian _RECURSIVE_FILTER_MINMAX() dengan posisi dan opsi argumen terbaru.\n\nPerubahan GET_INDEX_2D():\n\nMengubah nama argumen: return_order_only -> return_as_order.\n\nPerubahan RESHAPE_BY_COLUMNS():\n\nMengubah hasil error menjadi NA().\n\nPerubahan ROTATE_VECTOR() dan ROTATE_ARRAY():\n\nMengubah nama argumen: n -> num_rotation.\n\nPerubahan SWAP_COLUMNS() dan SWAP_ROWS():\n\nArgumen from_index dan to_index dapat menggunakan indeks negatif.\nNilai default to_index menjadi -1.\n\nPerubahan TEXT_SPLIT_VECTOR():\n\nMengubah metode menjadi recursive.\nMengubah nama argumen: text_delimiter -> col_delimiter.\nMenambah optional argumen replace_na.\n\n\nPerubahan fungsi pendukung:\n\nPerubahan FILTER_FUNC_COLUMN():\n\nMengganti nama argumen: col -> column_index.\nMenukar posisi argumen label_col dan with_label.\nMenambah optional argumen take_first_only.\n\nPerubahan FILTER_MINMAX_COLUMN():\n\nMengganti nama argumen: col -> column_index.\nMenukar posisi argumen label_col dan with_label.\nMenambah optional argumen take_first_only.\nPenyesuaian FILTER_FUNC_COLUMN() dengan posisi dan opsi argumen terbaru.\n\nPerubahan _RECURSIVE_FILTER_MINMAX():\n\nMengubah posisi argumen label_col dan with_label.\nPenyesuaian FILTER_MINMAX_COLUMN() dengan posisi dan opsi argumen terbaru.\n\nFungsi baru _RECURSIVE_TEXT_SPLIT():\n\nFungsi pendukung TEXT_SPLIT_VECTOR().\n\n\n\n2022-01-06 (v0.3.0)\n\nRilis feidlambda v0.3"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html",
    "href": "release/feidlambda-0-2-0.html",
    "title": "feidlambda v0.2",
    "section": "",
    "text": "Official GIST feid_utils (v0.2.0)\n\n\n\nhttps://gist.github.com/taruma/60610672a9bd94724cba46f68b5614fa Pre-release Page (GitHub)\nBerikut daftar fungsi yang tersedia di koleksi feidlambda versi 0.2.0:"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#comparevector",
    "href": "release/feidlambda-0-2-0.html#comparevector",
    "title": "feidlambda v0.2",
    "section": "6 COMPAREVECTOR",
    "text": "6 COMPAREVECTOR\n\n\n\n\n\n\n\nfeid_utils.COMPAREVECTOR\n\nMemeriksa apakah setiap elemen di left_vector memiliki nilai yang sama di isian right_vector.\n\nreturn\n\nLOGICAL VECTOR\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.COMPAREVECTOR(left_vector, right_vector)\n\n\n\n\n\nfeid_utils.COMPAREVECTOR"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#multicheck",
    "href": "release/feidlambda-0-2-0.html#multicheck",
    "title": "feidlambda v0.2",
    "section": "7 MULTICHECK",
    "text": "7 MULTICHECK\n\n\n\n\n\n\n\nfeid_utils.MULTICHECK\n\nMemeriksa apakah setiap kolom pada array memiliki nilai isian search_vector. Dan diproses setiap barisnya menggunakan check_condition yang dapat diisi dengan \"AND\" atau \"OR\".\n\nreturn\n\nBOOLEAN VECTOR\n\n\n\n\n\n\n\n\n\n\n\n\nPeringatan\n\n\n\ncheck_condition diisi \"OR\" atau \"AND\", jika tidak diisi dianggap \"AND\".\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.MULTICHECK(array, search_vector, [check_condition])\n\n\n\n\n\nfeid_utils.MULTICHECK"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#droprows",
    "href": "release/feidlambda-0-2-0.html#droprows",
    "title": "feidlambda v0.2",
    "section": "8 DROPROWS",
    "text": "8 DROPROWS\n\n\n\n\n\n\n\nfeid_utils.DROPROWS\n\nMenghapus baris berdasarkan index_to_drop dari array.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.DROPROWS(array, index_to_drop)\n\n\n\n\n\nfeid_utils.DROPROWS"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#dropcols",
    "href": "release/feidlambda-0-2-0.html#dropcols",
    "title": "feidlambda v0.2",
    "section": "9 DROPCOLS",
    "text": "9 DROPCOLS\n\n\n\n\n\n\n\nfeid_utils.DROPCOLS\n\nMenghapus kolom berdasarkan index_to_drop dari array.\n\nreturn\n\nARRAY\n\n\n\n\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.DROPCOLS(array, index_to_drop)\n\n\n\n\n\nfeid_utils.DROPCOLS"
  },
  {
    "objectID": "release/feidlambda-0-2-0.html#countmulticheck",
    "href": "release/feidlambda-0-2-0.html#countmulticheck",
    "title": "feidlambda v0.2",
    "section": "10 COUNTMULTICHECK",
    "text": "10 COUNTMULTICHECK\n\n\n\n\n\n\n\nfeid_utils.COUNTMULTICHECK\n\nMenghitung jumlah TRUE dari MULTICHECK.\n\nreturn\n\nINTEGER\n\n\n\n\n\n\n\n\n\n\n\n\nPeringatan\n\n\n\ncheck_condition diisi \"OR\" atau \"AND\", jika tidak diisi dianggap \"AND\".\n\n\n\n\n\n\n\nSYNTAX\n\n\n\n=feid_utils.COUNTMULTICHECK(array, search_vector, [check_condition])\n\n\n\n\n\nfeid_utils.COUNTMULTICHECK"
  }
]